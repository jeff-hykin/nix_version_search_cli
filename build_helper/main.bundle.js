var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/_utils/distance.ts
function distance(a, b) {
  if (a.length == 0) {
    return b.length;
  }
  if (b.length == 0) {
    return a.length;
  }
  const matrix = [];
  for (let i2 = 0; i2 <= b.length; i2++) {
    matrix[i2] = [i2];
  }
  for (let j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }
  for (let i2 = 1; i2 <= b.length; i2++) {
    for (let j = 1; j <= a.length; j++) {
      if (b.charAt(i2 - 1) == a.charAt(j - 1)) {
        matrix[i2][j] = matrix[i2 - 1][j - 1];
      } else {
        matrix[i2][j] = Math.min(
          matrix[i2 - 1][j - 1] + 1,
          Math.min(matrix[i2][j - 1] + 1, matrix[i2 - 1][j] + 1)
        );
      }
    }
  }
  return matrix[b.length][a.length];
}

// https://deno.land/x/cliffy@v1.0.0-rc.3/flags/_utils.ts
function paramCaseToCamelCase(str2) {
  return str2.replace(
    /-([a-z])/g,
    (g) => g[1].toUpperCase()
  );
}
function underscoreToCamelCase(str2) {
  return str2.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase().replace(
    /_([a-z])/g,
    (g) => g[1].toUpperCase()
  );
}
function getOption(flags, name) {
  while (name[0] === "-") {
    name = name.slice(1);
  }
  for (const flag of flags) {
    if (isOption(flag, name)) {
      return flag;
    }
  }
  return;
}
function didYouMeanOption(option, options) {
  const optionNames = options.map((option2) => [option2.name, ...option2.aliases ?? []]).flat().map((option2) => getFlag(option2));
  return didYouMean(" Did you mean option", getFlag(option), optionNames);
}
function didYouMeanType(type, types) {
  return didYouMean(" Did you mean type", type, types);
}
function didYouMean(message, type, types) {
  const match = closest(type, types);
  return match ? `${message} "${match}"?` : "";
}
function getFlag(name) {
  if (name.startsWith("-")) {
    return name;
  }
  if (name.length > 1) {
    return `--${name}`;
  }
  return `-${name}`;
}
function isOption(option, name) {
  return option.name === name || option.aliases && option.aliases.indexOf(name) !== -1;
}
function matchWildCardOptions(name, flags) {
  for (const option of flags) {
    if (option.name.indexOf("*") === -1) {
      continue;
    }
    let matched = matchWildCardOption(name, option);
    if (matched) {
      matched = { ...matched, name };
      flags.push(matched);
      return matched;
    }
  }
}
function matchWildCardOption(name, option) {
  const parts = option.name.split(".");
  const parts2 = name.split(".");
  if (parts.length !== parts2.length) {
    return false;
  }
  const count4 = Math.max(parts.length, parts2.length);
  for (let i2 = 0; i2 < count4; i2++) {
    if (parts[i2] !== parts2[i2] && parts[i2] !== "*") {
      return false;
    }
  }
  return option;
}
function closest(str2, arr) {
  let minDistance = Infinity;
  let minIndex = 0;
  for (let i2 = 0; i2 < arr.length; i2++) {
    const dist = distance(str2, arr[i2]);
    if (dist < minDistance) {
      minDistance = dist;
      minIndex = i2;
    }
  }
  return arr[minIndex];
}
function getDefaultValue(option) {
  return typeof option.default === "function" ? option.default() : option.default;
}

// https://deno.land/x/cliffy@v1.0.0-rc.3/flags/_errors.ts
var FlagsError = class _FlagsError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _FlagsError.prototype);
  }
};
var UnknownRequiredOptionError = class _UnknownRequiredOptionError extends FlagsError {
  constructor(option, options) {
    super(
      `Unknown required option "${getFlag(option)}".${didYouMeanOption(option, options)}`
    );
    Object.setPrototypeOf(this, _UnknownRequiredOptionError.prototype);
  }
};
var UnknownConflictingOptionError = class _UnknownConflictingOptionError extends FlagsError {
  constructor(option, options) {
    super(
      `Unknown conflicting option "${getFlag(option)}".${didYouMeanOption(option, options)}`
    );
    Object.setPrototypeOf(this, _UnknownConflictingOptionError.prototype);
  }
};
var UnknownTypeError = class _UnknownTypeError extends FlagsError {
  constructor(type, types) {
    super(`Unknown type "${type}".${didYouMeanType(type, types)}`);
    Object.setPrototypeOf(this, _UnknownTypeError.prototype);
  }
};
var ValidationError = class _ValidationError extends FlagsError {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
};
var DuplicateOptionError = class _DuplicateOptionError extends ValidationError {
  constructor(name) {
    super(
      `Option "${getFlag(name).replace(/^--no-/, "--")}" can only occur once, but was found several times.`
    );
    Object.setPrototypeOf(this, _DuplicateOptionError.prototype);
  }
};
var InvalidOptionError = class _InvalidOptionError extends ValidationError {
  constructor(option, options) {
    super(
      `Invalid option "${getFlag(option)}".${didYouMeanOption(option, options)}`
    );
    Object.setPrototypeOf(this, _InvalidOptionError.prototype);
  }
};
var UnknownOptionError = class _UnknownOptionError extends ValidationError {
  constructor(option, options) {
    super(
      `Unknown option "${getFlag(option)}".${didYouMeanOption(option, options)}`
    );
    Object.setPrototypeOf(this, _UnknownOptionError.prototype);
  }
};
var MissingOptionValueError = class _MissingOptionValueError extends ValidationError {
  constructor(option) {
    super(`Missing value for option "${getFlag(option)}".`);
    Object.setPrototypeOf(this, _MissingOptionValueError.prototype);
  }
};
var InvalidOptionValueError = class _InvalidOptionValueError extends ValidationError {
  constructor(option, expected, value) {
    super(
      `Option "${getFlag(option)}" must be of type "${expected}", but got "${value}".`
    );
    Object.setPrototypeOf(this, _InvalidOptionValueError.prototype);
  }
};
var UnexpectedOptionValueError = class extends ValidationError {
  constructor(option, value) {
    super(
      `Option "${getFlag(option)}" doesn't take a value, but got "${value}".`
    );
    Object.setPrototypeOf(this, InvalidOptionValueError.prototype);
  }
};
var OptionNotCombinableError = class _OptionNotCombinableError extends ValidationError {
  constructor(option) {
    super(`Option "${getFlag(option)}" cannot be combined with other options.`);
    Object.setPrototypeOf(this, _OptionNotCombinableError.prototype);
  }
};
var ConflictingOptionError = class _ConflictingOptionError extends ValidationError {
  constructor(option, conflictingOption) {
    super(
      `Option "${getFlag(option)}" conflicts with option "${getFlag(conflictingOption)}".`
    );
    Object.setPrototypeOf(this, _ConflictingOptionError.prototype);
  }
};
var DependingOptionError = class _DependingOptionError extends ValidationError {
  constructor(option, dependingOption) {
    super(
      `Option "${getFlag(option)}" depends on option "${getFlag(dependingOption)}".`
    );
    Object.setPrototypeOf(this, _DependingOptionError.prototype);
  }
};
var MissingRequiredOptionError = class _MissingRequiredOptionError extends ValidationError {
  constructor(option) {
    super(`Missing required option "${getFlag(option)}".`);
    Object.setPrototypeOf(this, _MissingRequiredOptionError.prototype);
  }
};
var UnexpectedRequiredArgumentError = class _UnexpectedRequiredArgumentError extends ValidationError {
  constructor(arg) {
    super(
      `An required argument cannot follow an optional argument, but "${arg}"  is defined as required.`
    );
    Object.setPrototypeOf(
      this,
      _UnexpectedRequiredArgumentError.prototype
    );
  }
};
var UnexpectedArgumentAfterVariadicArgumentError = class _UnexpectedArgumentAfterVariadicArgumentError extends ValidationError {
  constructor(arg) {
    super(`An argument cannot follow an variadic argument, but got "${arg}".`);
    Object.setPrototypeOf(
      this,
      _UnexpectedArgumentAfterVariadicArgumentError.prototype
    );
  }
};
var InvalidTypeError = class extends ValidationError {
  constructor({ label, name, value, type }, expected) {
    super(
      `${label} "${name}" must be of type "${type}", but got "${value}".` + (expected ? ` Expected values: ${expected.map((value2) => `"${value2}"`).join(", ")}` : "")
    );
    Object.setPrototypeOf(this, MissingOptionValueError.prototype);
  }
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/flags/types/boolean.ts
var boolean = (type) => {
  if (~["1", "true"].indexOf(type.value)) {
    return true;
  }
  if (~["0", "false"].indexOf(type.value)) {
    return false;
  }
  throw new InvalidTypeError(type, ["true", "false", "1", "0"]);
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/flags/types/number.ts
var number = (type) => {
  const value = Number(type.value);
  if (Number.isFinite(value)) {
    return value;
  }
  throw new InvalidTypeError(type);
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/flags/types/string.ts
var string = ({ value }) => {
  return value;
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/flags/_validate_flags.ts
function validateFlags(ctx, opts, options = /* @__PURE__ */ new Map()) {
  if (!opts.flags) {
    return;
  }
  setDefaultValues(ctx, opts);
  const optionNames = Object.keys(ctx.flags);
  if (!optionNames.length && opts.allowEmpty) {
    return;
  }
  if (ctx.standalone) {
    validateStandaloneOption(
      ctx,
      options,
      optionNames
    );
    return;
  }
  for (const [name, option] of options) {
    validateUnknownOption(option, opts);
    validateConflictingOptions(ctx, option);
    validateDependingOptions(ctx, option);
    validateRequiredValues(ctx, option, name);
  }
  validateRequiredOptions(ctx, options, opts);
}
function validateUnknownOption(option, opts) {
  if (!getOption(opts.flags ?? [], option.name)) {
    throw new UnknownOptionError(option.name, opts.flags ?? []);
  }
}
function setDefaultValues(ctx, opts) {
  if (!opts.flags?.length) {
    return;
  }
  for (const option of opts.flags) {
    let name;
    let defaultValue = void 0;
    if (option.name.startsWith("no-")) {
      const propName = option.name.replace(/^no-/, "");
      if (typeof ctx.flags[propName] !== "undefined") {
        continue;
      }
      const positiveOption = getOption(opts.flags, propName);
      if (positiveOption) {
        continue;
      }
      name = paramCaseToCamelCase(propName);
      defaultValue = true;
    }
    if (!name) {
      name = paramCaseToCamelCase(option.name);
    }
    const hasDefaultValue = (!opts.ignoreDefaults || typeof opts.ignoreDefaults[name] === "undefined") && typeof ctx.flags[name] === "undefined" && (typeof option.default !== "undefined" || typeof defaultValue !== "undefined");
    if (hasDefaultValue) {
      ctx.flags[name] = getDefaultValue(option) ?? defaultValue;
      ctx.defaults[option.name] = true;
      if (typeof option.value === "function") {
        ctx.flags[name] = option.value(ctx.flags[name]);
      }
    }
  }
}
function validateStandaloneOption(ctx, options, optionNames) {
  if (!ctx.standalone || optionNames.length === 1) {
    return;
  }
  for (const [_, opt] of options) {
    if (!ctx.defaults[opt.name] && opt !== ctx.standalone) {
      throw new OptionNotCombinableError(ctx.standalone.name);
    }
  }
}
function validateConflictingOptions(ctx, option) {
  if (!option.conflicts?.length) {
    return;
  }
  for (const flag of option.conflicts) {
    if (isset(flag, ctx.flags)) {
      throw new ConflictingOptionError(option.name, flag);
    }
  }
}
function validateDependingOptions(ctx, option) {
  if (!option.depends) {
    return;
  }
  for (const flag of option.depends) {
    if (!isset(flag, ctx.flags) && !ctx.defaults[option.name]) {
      throw new DependingOptionError(option.name, flag);
    }
  }
}
function validateRequiredValues(ctx, option, name) {
  if (!option.args) {
    return;
  }
  const isArray = option.args.length > 1;
  for (let i2 = 0; i2 < option.args.length; i2++) {
    const arg = option.args[i2];
    if (arg.optional) {
      continue;
    }
    const hasValue = isArray ? typeof ctx.flags[name][i2] !== "undefined" : typeof ctx.flags[name] !== "undefined";
    if (!hasValue) {
      throw new MissingOptionValueError(option.name);
    }
  }
}
function validateRequiredOptions(ctx, options, opts) {
  if (!opts.flags?.length) {
    return;
  }
  const optionsValues = [...options.values()];
  for (const option of opts.flags) {
    if (!option.required || paramCaseToCamelCase(option.name) in ctx.flags) {
      continue;
    }
    const conflicts = option.conflicts ?? [];
    const hasConflict = conflicts.find((flag) => !!ctx.flags[flag]);
    const hasConflicts = hasConflict || optionsValues.find(
      (opt) => opt.conflicts?.find((flag) => flag === option.name)
    );
    if (hasConflicts) {
      continue;
    }
    throw new MissingRequiredOptionError(option.name);
  }
}
function isset(flagName, flags) {
  const name = paramCaseToCamelCase(flagName);
  return typeof flags[name] !== "undefined";
}

// https://deno.land/x/cliffy@v1.0.0-rc.3/flags/types/integer.ts
var integer = (type) => {
  const value = Number(type.value);
  if (Number.isInteger(value)) {
    return value;
  }
  throw new InvalidTypeError(type);
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/flags/flags.ts
var DefaultTypes = {
  string,
  number,
  integer,
  boolean
};
function parseFlags(argsOrCtx, opts = {}) {
  let args;
  let ctx;
  if (Array.isArray(argsOrCtx)) {
    ctx = {};
    args = argsOrCtx;
  } else {
    ctx = argsOrCtx;
    args = argsOrCtx.unknown;
    argsOrCtx.unknown = [];
  }
  args = args.slice();
  ctx.flags ??= {};
  ctx.literal ??= [];
  ctx.unknown ??= [];
  ctx.stopEarly = false;
  ctx.stopOnUnknown = false;
  ctx.defaults ??= {};
  opts.dotted ??= true;
  validateOptions(opts);
  const options = parseArgs(ctx, args, opts);
  validateFlags(ctx, opts, options);
  if (opts.dotted) {
    parseDottedOptions(ctx);
  }
  return ctx;
}
function validateOptions(opts) {
  opts.flags?.forEach((opt) => {
    opt.depends?.forEach((flag) => {
      if (!opts.flags || !getOption(opts.flags, flag)) {
        throw new UnknownRequiredOptionError(flag, opts.flags ?? []);
      }
    });
    opt.conflicts?.forEach((flag) => {
      if (!opts.flags || !getOption(opts.flags, flag)) {
        throw new UnknownConflictingOptionError(flag, opts.flags ?? []);
      }
    });
  });
}
function parseArgs(ctx, args, opts) {
  const optionsMap = /* @__PURE__ */ new Map();
  let inLiteral = false;
  for (let argsIndex = 0; argsIndex < args.length; argsIndex++) {
    let parseNext = function(option2) {
      if (negate) {
        setFlagValue(false);
        return;
      } else if (!option2.args?.length) {
        setFlagValue(void 0);
        return;
      }
      const arg = option2.args[optionArgsIndex];
      if (!arg) {
        const flag = next();
        throw new UnknownOptionError(flag, opts.flags ?? []);
      }
      if (!arg.type) {
        arg.type = "boolean" /* BOOLEAN */;
      }
      if (!option2.args?.length && arg.type === "boolean" /* BOOLEAN */ && arg.optional === void 0) {
        arg.optional = true;
      }
      if (arg.optional) {
        inOptionalArg = true;
      } else if (inOptionalArg) {
        throw new UnexpectedRequiredArgumentError(option2.name);
      }
      let result2;
      let increase = false;
      if (arg.list && hasNext(arg)) {
        const parsed = next().split(arg.separator || ",").map((nextValue) => {
          const value = parseValue(option2, arg, nextValue);
          if (typeof value === "undefined") {
            throw new InvalidOptionValueError(
              option2.name,
              arg.type ?? "?",
              nextValue
            );
          }
          return value;
        });
        if (parsed?.length) {
          result2 = parsed;
        }
      } else {
        if (hasNext(arg)) {
          result2 = parseValue(option2, arg, next());
        } else if (arg.optional && arg.type === "boolean" /* BOOLEAN */) {
          result2 = true;
        }
      }
      if (increase && typeof currentValue === "undefined") {
        argsIndex++;
        if (!arg.variadic) {
          optionArgsIndex++;
        } else if (option2.args[optionArgsIndex + 1]) {
          throw new UnexpectedArgumentAfterVariadicArgumentError(next());
        }
      }
      if (typeof result2 !== "undefined" && (option2.args.length > 1 || arg.variadic)) {
        if (!ctx.flags[propName]) {
          setFlagValue([]);
        }
        ctx.flags[propName].push(result2);
        if (hasNext(arg)) {
          parseNext(option2);
        }
      } else {
        setFlagValue(result2);
      }
      function hasNext(arg2) {
        if (!option2.args?.length) {
          return false;
        }
        const nextValue = currentValue ?? args[argsIndex + 1];
        if (!nextValue) {
          return false;
        }
        if (option2.args.length > 1 && optionArgsIndex >= option2.args.length) {
          return false;
        }
        if (!arg2.optional) {
          return true;
        }
        if (option2.equalsSign && arg2.optional && !arg2.variadic && typeof currentValue === "undefined") {
          return false;
        }
        if (arg2.optional || arg2.variadic) {
          return nextValue[0] !== "-" || typeof currentValue !== "undefined" || arg2.type === "number" /* NUMBER */ && !isNaN(Number(nextValue));
        }
        return false;
      }
      function parseValue(option3, arg2, value) {
        const result3 = opts.parse ? opts.parse({
          label: "Option",
          type: arg2.type || "string" /* STRING */,
          name: `--${option3.name}`,
          value
        }) : parseDefaultType(option3, arg2, value);
        if (typeof result3 !== "undefined") {
          increase = true;
        }
        return result3;
      }
    }, setFlagValue = function(value) {
      ctx.flags[propName] = value;
      if (ctx.defaults[propName]) {
        delete ctx.defaults[propName];
      }
    };
    let option;
    let current2 = args[argsIndex];
    let currentValue;
    let negate = false;
    if (inLiteral) {
      ctx.literal.push(current2);
      continue;
    } else if (current2 === "--") {
      inLiteral = true;
      continue;
    } else if (ctx.stopEarly || ctx.stopOnUnknown) {
      ctx.unknown.push(current2);
      continue;
    }
    const isFlag = current2.length > 1 && current2[0] === "-";
    if (!isFlag) {
      if (opts.stopEarly) {
        ctx.stopEarly = true;
      }
      ctx.unknown.push(current2);
      continue;
    }
    const isShort = current2[1] !== "-";
    const isLong = isShort ? false : current2.length > 3 && current2[2] !== "-";
    if (!isShort && !isLong) {
      throw new InvalidOptionError(current2, opts.flags ?? []);
    }
    if (isShort && current2.length > 2 && current2[2] !== ".") {
      args.splice(argsIndex, 1, ...splitFlags(current2));
      current2 = args[argsIndex];
    } else if (isLong && current2.startsWith("--no-")) {
      negate = true;
    }
    const equalSignIndex = current2.indexOf("=");
    if (equalSignIndex !== -1) {
      currentValue = current2.slice(equalSignIndex + 1) || void 0;
      current2 = current2.slice(0, equalSignIndex);
    }
    if (opts.flags) {
      option = getOption(opts.flags, current2);
      if (!option) {
        const name = current2.replace(/^-+/, "");
        option = matchWildCardOptions(name, opts.flags);
        if (!option) {
          if (opts.stopOnUnknown) {
            ctx.stopOnUnknown = true;
            ctx.unknown.push(args[argsIndex]);
            continue;
          }
          throw new UnknownOptionError(current2, opts.flags);
        }
      }
    } else {
      option = {
        name: current2.replace(/^-+/, ""),
        optionalValue: true,
        type: "string" /* STRING */
      };
    }
    if (option.standalone) {
      ctx.standalone = option;
    }
    const positiveName = negate ? option.name.replace(/^no-?/, "") : option.name;
    const propName = paramCaseToCamelCase(positiveName);
    if (typeof ctx.flags[propName] !== "undefined") {
      if (!opts.flags?.length) {
        option.collect = true;
      } else if (!option.collect && !ctx.defaults[option.name]) {
        throw new DuplicateOptionError(current2);
      }
    }
    if (option.type && !option.args?.length) {
      option.args = [{
        type: option.type,
        optional: option.optionalValue,
        variadic: option.variadic,
        list: option.list,
        separator: option.separator
      }];
    }
    if (opts.flags?.length && !option.args?.length && typeof currentValue !== "undefined") {
      throw new UnexpectedOptionValueError(option.name, currentValue);
    }
    let optionArgsIndex = 0;
    let inOptionalArg = false;
    const next = () => currentValue ?? args[argsIndex + 1];
    const previous = ctx.flags[propName];
    parseNext(option);
    if (typeof ctx.flags[propName] === "undefined") {
      if (option.args?.length && !option.args?.[optionArgsIndex].optional) {
        throw new MissingOptionValueError(option.name);
      } else if (typeof option.default !== "undefined" && (option.type || option.value || option.args?.length)) {
        ctx.flags[propName] = getDefaultValue(option);
      } else {
        setFlagValue(true);
      }
    }
    if (option.value) {
      const value = option.value(ctx.flags[propName], previous);
      setFlagValue(value);
    } else if (option.collect) {
      const value = typeof previous !== "undefined" ? Array.isArray(previous) ? previous : [previous] : [];
      value.push(ctx.flags[propName]);
      setFlagValue(value);
    }
    optionsMap.set(propName, option);
    opts.option?.(option, ctx.flags[propName]);
  }
  return optionsMap;
}
function parseDottedOptions(ctx) {
  ctx.flags = Object.keys(ctx.flags).reduce(
    (result2, key) => {
      if (~key.indexOf(".")) {
        key.split(".").reduce(
          (result3, subKey, index, parts) => {
            if (index === parts.length - 1) {
              result3[subKey] = ctx.flags[key];
            } else {
              result3[subKey] = result3[subKey] ?? {};
            }
            return result3[subKey];
          },
          result2
        );
      } else {
        result2[key] = ctx.flags[key];
      }
      return result2;
    },
    {}
  );
}
function splitFlags(flag) {
  flag = flag.slice(1);
  const normalized = [];
  const index = flag.indexOf("=");
  const flags = (index !== -1 ? flag.slice(0, index) : flag).split("");
  if (isNaN(Number(flag[flag.length - 1]))) {
    flags.forEach((val) => normalized.push(`-${val}`));
  } else {
    normalized.push(`-${flags.shift()}`);
    if (flags.length) {
      normalized.push(flags.join(""));
    }
  }
  if (index !== -1) {
    normalized[normalized.length - 1] += flag.slice(index);
  }
  return normalized;
}
function parseDefaultType(option, arg, value) {
  const type = arg.type || "string" /* STRING */;
  const parseType = DefaultTypes[type];
  if (!parseType) {
    throw new UnknownTypeError(type, Object.keys(DefaultTypes));
  }
  return parseType({
    label: "Option",
    type,
    name: `--${option.name}`,
    value
  });
}

// https://deno.land/x/cliffy@v1.0.0-rc.3/command/_utils.ts
function didYouMeanCommand(command2, commands, excludes = []) {
  const commandNames = commands.map((command3) => command3.getName()).filter((command3) => !excludes.includes(command3));
  return didYouMean(" Did you mean command", command2, commandNames);
}
var ARGUMENT_REGEX = /^[<\[].+[\]>]$/;
var ARGUMENT_DETAILS_REGEX = /[<\[:>\]]/;
function splitArguments(args) {
  const parts = args.trim().split(/[, =] */g);
  const typeParts = [];
  while (parts[parts.length - 1] && ARGUMENT_REGEX.test(parts[parts.length - 1])) {
    typeParts.unshift(parts.pop());
  }
  const typeDefinition = typeParts.join(" ");
  return { flags: parts, typeDefinition, equalsSign: args.includes("=") };
}
function parseArgumentsDefinition(argsDefinition, validate = true, all) {
  const argumentDetails = [];
  let hasOptional = false;
  let hasVariadic = false;
  const parts = argsDefinition.split(/ +/);
  for (const arg of parts) {
    if (validate && hasVariadic) {
      throw new UnexpectedArgumentAfterVariadicArgumentError(arg);
    }
    const parts2 = arg.split(ARGUMENT_DETAILS_REGEX);
    if (!parts2[1]) {
      if (all) {
        argumentDetails.push(parts2[0]);
      }
      continue;
    }
    const type = parts2[2] || "string" /* STRING */;
    const details = {
      optional: arg[0] === "[",
      name: parts2[1],
      action: parts2[3] || type,
      variadic: false,
      list: type ? arg.indexOf(type + "[]") !== -1 : false,
      type
    };
    if (validate && !details.optional && hasOptional) {
      throw new UnexpectedRequiredArgumentError(details.name);
    }
    if (arg[0] === "[") {
      hasOptional = true;
    }
    if (details.name.length > 3) {
      const istVariadicLeft = details.name.slice(0, 3) === "...";
      const istVariadicRight = details.name.slice(-3) === "...";
      hasVariadic = details.variadic = istVariadicLeft || istVariadicRight;
      if (istVariadicLeft) {
        details.name = details.name.slice(3);
      } else if (istVariadicRight) {
        details.name = details.name.slice(0, -3);
      }
    }
    argumentDetails.push(details);
  }
  return argumentDetails;
}
function dedent(str2) {
  const lines = str2.split(/\r?\n|\r/g);
  let text = "";
  let indent4 = 0;
  for (const line of lines) {
    if (text || line.trim()) {
      if (!text) {
        text = line.trimStart();
        indent4 = line.length - text.length;
      } else {
        text += line.slice(indent4);
      }
      text += "\n";
    }
  }
  return text.trimEnd();
}
function getDescription(description, short) {
  return short ? description.trim().split("\n", 1)[0].trim() : dedent(description);
}

// https://deno.land/std@0.196.0/fmt/colors.ts
var { Deno: Deno2 } = globalThis;
var noColor = typeof Deno2?.noColor === "boolean" ? Deno2.noColor : false;
var enabled = !noColor;
function setColorEnabled(value) {
  if (Deno2?.noColor) {
    return;
  }
  enabled = value;
}
function getColorEnabled() {
  return enabled;
}
function code(open, close) {
  return {
    open: `\x1B[${open.join(";")}m`,
    close: `\x1B[${close}m`,
    regexp: new RegExp(`\\x1b\\[${close}m`, "g")
  };
}
function run(str2, code2) {
  return enabled ? `${code2.open}${str2.replace(code2.regexp, code2.open)}${code2.close}` : str2;
}
function reset(str2) {
  return run(str2, code([0], 0));
}
function bold(str2) {
  return run(str2, code([1], 22));
}
function dim(str2) {
  return run(str2, code([2], 22));
}
function italic(str2) {
  return run(str2, code([3], 23));
}
function underline(str2) {
  return run(str2, code([4], 24));
}
function red(str2) {
  return run(str2, code([31], 39));
}
function green(str2) {
  return run(str2, code([32], 39));
}
function yellow(str2) {
  return run(str2, code([33], 39));
}
function cyan(str2) {
  return run(str2, code([36], 39));
}
function brightBlue(str2) {
  return run(str2, code([94], 39));
}
function brightMagenta(str2) {
  return run(str2, code([95], 39));
}
var ANSI_PATTERN = new RegExp(
  [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"
  ].join("|"),
  "g"
);
function stripColor(string2) {
  return string2.replace(ANSI_PATTERN, "");
}

// https://deno.land/x/cliffy@v1.0.0-rc.3/command/_errors.ts
var CommandError = class _CommandError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, _CommandError.prototype);
  }
};
var ValidationError2 = class _ValidationError extends CommandError {
  exitCode;
  cmd;
  constructor(message, { exitCode } = {}) {
    super(message);
    Object.setPrototypeOf(this, _ValidationError.prototype);
    this.exitCode = exitCode ?? 2;
  }
};
var DuplicateOptionNameError = class _DuplicateOptionNameError extends CommandError {
  constructor(optionName, commandName) {
    super(
      `An option with name '${bold(getFlag(optionName))}' is already registered on command '${bold(commandName)}'. If it is intended to override the option, set the '${bold("override")}' option of the '${bold("option")}' method to true.`
    );
    Object.setPrototypeOf(this, _DuplicateOptionNameError.prototype);
  }
};
var MissingCommandNameError = class _MissingCommandNameError extends CommandError {
  constructor() {
    super("Missing command name.");
    Object.setPrototypeOf(this, _MissingCommandNameError.prototype);
  }
};
var DuplicateCommandNameError = class _DuplicateCommandNameError extends CommandError {
  constructor(name) {
    super(`Duplicate command name "${name}".`);
    Object.setPrototypeOf(this, _DuplicateCommandNameError.prototype);
  }
};
var DuplicateCommandAliasError = class _DuplicateCommandAliasError extends CommandError {
  constructor(alias) {
    super(`Duplicate command alias "${alias}".`);
    Object.setPrototypeOf(this, _DuplicateCommandAliasError.prototype);
  }
};
var CommandNotFoundError = class _CommandNotFoundError extends CommandError {
  constructor(name, commands, excluded) {
    super(
      `Unknown command "${name}".${didYouMeanCommand(name, commands, excluded)}`
    );
    Object.setPrototypeOf(this, _CommandNotFoundError.prototype);
  }
};
var DuplicateTypeError = class _DuplicateTypeError extends CommandError {
  constructor(name) {
    super(`Type with name "${name}" already exists.`);
    Object.setPrototypeOf(this, _DuplicateTypeError.prototype);
  }
};
var DuplicateCompletionError = class _DuplicateCompletionError extends CommandError {
  constructor(name) {
    super(`Completion with name "${name}" already exists.`);
    Object.setPrototypeOf(this, _DuplicateCompletionError.prototype);
  }
};
var DuplicateExampleError = class _DuplicateExampleError extends CommandError {
  constructor(name) {
    super(`Example with name "${name}" already exists.`);
    Object.setPrototypeOf(this, _DuplicateExampleError.prototype);
  }
};
var DuplicateEnvVarError = class _DuplicateEnvVarError extends CommandError {
  constructor(name) {
    super(`Environment variable with name "${name}" already exists.`);
    Object.setPrototypeOf(this, _DuplicateEnvVarError.prototype);
  }
};
var MissingRequiredEnvVarError = class _MissingRequiredEnvVarError extends ValidationError2 {
  constructor(envVar) {
    super(`Missing required environment variable "${envVar.names[0]}".`);
    Object.setPrototypeOf(this, _MissingRequiredEnvVarError.prototype);
  }
};
var TooManyEnvVarValuesError = class _TooManyEnvVarValuesError extends CommandError {
  constructor(name) {
    super(
      `An environment variable can only have one value, but "${name}" has more than one.`
    );
    Object.setPrototypeOf(this, _TooManyEnvVarValuesError.prototype);
  }
};
var UnexpectedOptionalEnvVarValueError = class _UnexpectedOptionalEnvVarValueError extends CommandError {
  constructor(name) {
    super(
      `An environment variable cannot have an optional value, but "${name}" is defined as optional.`
    );
    Object.setPrototypeOf(this, _UnexpectedOptionalEnvVarValueError.prototype);
  }
};
var UnexpectedVariadicEnvVarValueError = class _UnexpectedVariadicEnvVarValueError extends CommandError {
  constructor(name) {
    super(
      `An environment variable cannot have an variadic value, but "${name}" is defined as variadic.`
    );
    Object.setPrototypeOf(this, _UnexpectedVariadicEnvVarValueError.prototype);
  }
};
var DefaultCommandNotFoundError = class _DefaultCommandNotFoundError extends CommandError {
  constructor(name, commands) {
    super(
      `Default command "${name}" not found.${didYouMeanCommand(name, commands)}`
    );
    Object.setPrototypeOf(this, _DefaultCommandNotFoundError.prototype);
  }
};
var CommandExecutableNotFoundError = class _CommandExecutableNotFoundError extends CommandError {
  constructor(name) {
    super(
      `Command executable not found: ${name}`
    );
    Object.setPrototypeOf(this, _CommandExecutableNotFoundError.prototype);
  }
};
var UnknownCommandError = class _UnknownCommandError extends ValidationError2 {
  constructor(name, commands, excluded) {
    super(
      `Unknown command "${name}".${didYouMeanCommand(name, commands, excluded)}`
    );
    Object.setPrototypeOf(this, _UnknownCommandError.prototype);
  }
};
var NoArgumentsAllowedError = class _NoArgumentsAllowedError extends ValidationError2 {
  constructor(name) {
    super(`No arguments allowed for command "${name}".`);
    Object.setPrototypeOf(this, _NoArgumentsAllowedError.prototype);
  }
};
var MissingArgumentsError = class _MissingArgumentsError extends ValidationError2 {
  constructor(names) {
    super(`Missing argument(s): ${names.join(", ")}`);
    Object.setPrototypeOf(this, _MissingArgumentsError.prototype);
  }
};
var MissingArgumentError = class _MissingArgumentError extends ValidationError2 {
  constructor(name) {
    super(`Missing argument: ${name}`);
    Object.setPrototypeOf(this, _MissingArgumentError.prototype);
  }
};
var TooManyArgumentsError = class _TooManyArgumentsError extends ValidationError2 {
  constructor(args) {
    super(`Too many arguments: ${args.join(" ")}`);
    Object.setPrototypeOf(this, _TooManyArgumentsError.prototype);
  }
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/command/type.ts
var Type = class {
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/command/types/boolean.ts
var BooleanType = class extends Type {
  /** Parse boolean type. */
  parse(type) {
    return boolean(type);
  }
  /** Complete boolean type. */
  complete() {
    return ["true", "false"];
  }
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/command/types/string.ts
var StringType = class extends Type {
  /** Complete string type. */
  parse(type) {
    return string(type);
  }
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/command/types/file.ts
var FileType = class extends StringType {
  constructor() {
    super();
  }
  // getOptions(): FileTypeOptions {
  //   return this.opts;
  // }
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/command/types/integer.ts
var IntegerType = class extends Type {
  /** Parse integer type. */
  parse(type) {
    return integer(type);
  }
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/command/types/number.ts
var NumberType = class extends Type {
  /** Parse number type. */
  parse(type) {
    return number(type);
  }
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/table/border.ts
var border = {
  top: "\u2500",
  topMid: "\u252C",
  topLeft: "\u250C",
  topRight: "\u2510",
  bottom: "\u2500",
  bottomMid: "\u2534",
  bottomLeft: "\u2514",
  bottomRight: "\u2518",
  left: "\u2502",
  leftMid: "\u251C",
  mid: "\u2500",
  midMid: "\u253C",
  right: "\u2502",
  rightMid: "\u2524",
  middle: "\u2502"
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/table/cell.ts
var Cell = class _Cell {
  /**
   * Cell constructor.
   *
   * @param value Cell value.
   */
  constructor(value) {
    this.value = value;
  }
  options = {};
  /** Get cell length. */
  get length() {
    return this.toString().length;
  }
  /**
   * Create a new cell. If value is a cell, the value and all options of the cell
   * will be copied to the new cell.
   *
   * @param value Cell or cell value.
   */
  static from(value) {
    let cell;
    if (value instanceof _Cell) {
      cell = new this(value.getValue());
      cell.options = { ...value.options };
    } else {
      cell = new this(value);
    }
    return cell;
  }
  /** Get cell string value. */
  toString() {
    return this.value.toString();
  }
  /** Get cell value. */
  getValue() {
    return this.value;
  }
  /**
   * Set cell value.
   *
   * @param value Cell or cell value.
   */
  setValue(value) {
    this.value = value;
    return this;
  }
  /**
   * Clone cell with all options.
   *
   * @param value Cell or cell value.
   */
  clone(value) {
    return _Cell.from(value ?? this);
  }
  /**
   * Setter:
   */
  /**
   * Enable/disable cell border.
   *
   * @param enable    Enable/disable cell border.
   * @param override  Override existing value.
   */
  border(enable = true, override = true) {
    if (override || typeof this.options.border === "undefined") {
      this.options.border = enable;
    }
    return this;
  }
  /**
   * Set col span.
   *
   * ```ts
   * import { Cell, Table } from "./mod.ts";
   *
   * new Table()
   *   .body([
   *     [
   *       new Cell("Row 1 & 2 Column 1").rowSpan(2),
   *       "Row 1 Column 2",
   *       "Row 1 Column 3",
   *     ],
   *     [new Cell("Row 2 Column 2 & 3").colSpan(2)],
   *   ])
   *   .border()
   *   .render();
   * ```
   *
   * @param span      Number of cols to span.
   * @param override  Override existing value.
   */
  colSpan(span, override = true) {
    if (override || typeof this.options.colSpan === "undefined") {
      this.options.colSpan = span;
    }
    return this;
  }
  /**
   * Set row span.
   *
   * ```ts
   * import { Cell, Table } from "./mod.ts";
   *
   * new Table()
   *   .body([
   *     [
   *       new Cell("Row 1 & 2 Column 1").rowSpan(2),
   *       "Row 1 Column 2",
   *       "Row 1 Column 3",
   *     ],
   *     [new Cell("Row 2 Column 2 & 3").colSpan(2)],
   *   ])
   *   .border()
   *   .render();
   * ```
   *
   * @param span      Number of rows to span.
   * @param override  Override existing value.
   */
  rowSpan(span, override = true) {
    if (override || typeof this.options.rowSpan === "undefined") {
      this.options.rowSpan = span;
    }
    return this;
  }
  /**
   * Align cell content.
   *
   * @param direction Align direction.
   * @param override  Override existing value.
   */
  align(direction, override = true) {
    if (override || typeof this.options.align === "undefined") {
      this.options.align = direction;
    }
    return this;
  }
  /**
   * Getter:
   */
  /** Check if cell has border. */
  getBorder() {
    return this.options.border === true;
  }
  /** Get col span. */
  getColSpan() {
    return typeof this.options.colSpan === "number" && this.options.colSpan > 0 ? this.options.colSpan : 1;
  }
  /** Get row span. */
  getRowSpan() {
    return typeof this.options.rowSpan === "number" && this.options.rowSpan > 0 ? this.options.rowSpan : 1;
  }
  /** Get row span. */
  getAlign() {
    return this.options.align ?? "left";
  }
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/table/column.ts
var Column = class _Column {
  /**
   * Create a new cell from column options or an existing column.
   * @param options
   */
  static from(options) {
    const opts = options instanceof _Column ? options.opts : options;
    return new _Column().options(opts);
  }
  opts = {};
  /** Set column options. */
  options(options) {
    Object.assign(this.opts, options);
    return this;
  }
  /** Set min column width. */
  minWidth(width) {
    this.opts.minWidth = width;
    return this;
  }
  /** Set max column width. */
  maxWidth(width) {
    this.opts.maxWidth = width;
    return this;
  }
  /** Set column border. */
  border(border2 = true) {
    this.opts.border = border2;
    return this;
  }
  /** Set column padding. */
  padding(padding) {
    this.opts.padding = padding;
    return this;
  }
  /** Set column alignment. */
  align(direction) {
    this.opts.align = direction;
    return this;
  }
  /** Get min column width. */
  getMinWidth() {
    return this.opts.minWidth;
  }
  /** Get max column width. */
  getMaxWidth() {
    return this.opts.maxWidth;
  }
  /** Get column border. */
  getBorder() {
    return this.opts.border;
  }
  /** Get column padding. */
  getPadding() {
    return this.opts.padding;
  }
  /** Get column alignment. */
  getAlign() {
    return this.opts.align;
  }
};

// https://deno.land/std@0.196.0/console/_data.json
var data_default = {
  UNICODE_VERSION: "15.0.0",
  tables: [
    {
      d: "AAECAwQFBgcICQoLDA0OAw8DDwkQCRESERIA",
      r: "AQEBAgEBAQEBAQEBAQEBBwEHAVABBwcBBwF4"
    },
    {
      d: "AAECAwQFBgcGCAYJCgsMDQ4PEAYREhMUBhUWFxgZGhscHR4fICEiIyIkJSYnKCkqJSssLS4vMDEyMzQ1Njc4OToGOzwKBj0GPj9AQUIGQwZEBkVGR0hJSktMTQZOBgoGT1BRUlNUVVZXWFkGWgZbBlxdXl1fYGFiY2RlZmdoBmlqBmsGAQZsBm1uO29wcXI7czt0dXZ3OwY7eHkGent8Bn0Gfn+AgYKDhIWGBoc7iAZdO4kGiosGAXGMBo0GjgaPBpAGkQaSBpMGlJUGlpcGmJmam5ydnp+gLgahLKIGo6SlpganqKmqqwasBq0Grq8GsLGyswa0BrUGtre4Brm6uwZHvAa9vga/wME7wjvDxAbFO8bHO8gGyQbKywbMzQbOBs/Q0QbSBr8GvgbT1AbUBtUG1gbXBtjZ2tsG3N0G3t/g4eLjO+Tl5ufoO+k76gbrBuztOwbu7/AGO+XxCgYKCwZd8g==",
      r: "AQEBAQEBAQEBAQEBAQEBAQEBAQMBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQECBQEOAQEBAQEBAQEBAwEBAQEBAQEBAQIBAwEIAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBDQEBBQEBAQEBAgEBAwEBAQEBAQEBAQEBbQHaAQEFAQEBBAECAQEBAQEBAQEBAwGuASFkCAELAQEBAQEBAQEHAQMBAQEaAQIBCAEFAQEBAQEBAQEBAQEBAQEBAQEBAQECAQEBAQIBAQEBAQEBAwEDAQEBAQEBAQUBAQEBAQEBBAEBAVIBAdkBARABAQFfARMBAYoBBAEBBQEmAUkBAQcBAQIBHgEBARUBAQEBAQUBAQcBDwEBARoBAgEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQMBBAEBAgEBAQEUfwEBAQIDAXj/AQ=="
    },
    {
      d: "AFUVAF3Xd3X/93//VXVVV9VX9V91f1/31X93XVXdVdVV9dVV/VVX1X9X/131VfXVVXV3V1VdVV1V1/1dV1X/3VUAVf3/3/9fVf3/3/9fVV1V/11VFQBQVQEAEEEQVQBQVQBAVFUVAFVUVQUAEAAUBFBVFVFVAEBVBQBUVRUAVVFVBRAAAVBVAVVQVQBVBQBAVUVUAQBUUQEAVQVVUVVUAVRVUVUFVUVBVVRBFRRQUVVQUVUBEFRRVQVVBQBRVRQBVFVRVUFVBVVFVVRVUVVUVQRUBQRQVUFVBVVFVVBVBVVQVRVUAVRVUVUFVVFVRVUFRFVRAEBVFQBAVVEAVFUAQFVQVRFRVQEAQAAEVQEAAQBUVUVVAQQAQVVQBVRVAVRVRUFVUVVRVaoAVQFVBVRVBVUFVQVVEABQVUUBAFVRVRUAVUFVUVVAFVRVRVUBVRUUVUUAQEQBAFQVABRVAEBVAFUEQFRFVRUAVVBVBVAQUFVFUBFQVQAFVUAABABUUVVUUFUVANd/X3//BUD3XdV1VQAEAFVXVdX9V1VXVQBUVdVdVdV1VX111VXVV9V//1X/X1VdVf9fVV9VdVdV1VX31dfVXXX9193/d1X/VV9VV3VVX//1VfVVXVVdVdVVdVWlVWlVqVaWVf/f/1X/Vf/1X1Xf/19V9VVf9df1X1X1X1XVVWlVfV31VVpVd1V3VapV33/fVZVVlVX1WVWlVelV+v/v//7/31Xv/6/77/tVWaVVVlVdVWaVmlX1/1WpVVZVlVWVVlVW+V9VFVBVAKqaqlWqWlWqVaoKoKpqqapqgapVqaqpqmqqVapqqv+qVqpqVRVAAFBVBVVQVUUVVUFVVFVQVQBQVRVVBQBQVRUAUFWqVkBVFQVQVVFVAUBBVRVVVFVUVQQUVAVRVVBVRVVRVFFVqlVFVQCqWlUAqmqqaqpVqlZVqmpVAV1VUVVUVQVAVQFBVQBVQBVVQVUAVRVUVQFVBQBUVQVQVVFVAEBVFFRVFVBVFUBBUUVVUVVAVRUAAQBUVRVVUFUFAEBVARRVFVAEVUVVFQBAVVRVBQBUAFRVAAVEVUVVFQBEFQRVBVBVEFRVUFUVAEARVFUVUQAQVQEFEABVFQBBVRVEFVUABVVUVQEAQFUVABRAVRVVAUABVQUAQFBVAEAAEFUFAAUABEFVAUBFEAAQVVARVRVUVVBVBUBVRFVUFQBQVQBUVQBAVRVVFUBVqlRVWlWqVapaVapWVaqpqmmqalVlVWpZVapVqlVBAFUAUABAVRVQVRUAQAEAVQVQVQVUVQBAFQBUVVFVVFUVAAEAVQBAABQAEARAVUVVAFUAQFUAQFVWVZVV/39V/1//X1X/76uq6v9XVWpVqlWqVlVaVapaVapWVamqmqqmqlWqapWqVapWqmqmqpaqWlWVaqpVZVVpVVZVlapVqlpVVmqpVapVlVZVqlZVqlVWVapqqpqqVapWqlZVqpqqWlWlqlWqVlWqVlVRVQD/Xw==",
      r: "CBcBCAEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQMBAQECAQEBAQEBAQEBAQEBBAEBGAEDAQwBAwEIAQEBAQEBAQgcCAEDAQEBAQEDAQEBDQEDEAELAQEBEQEKAQEBDgEBAgIBAQoBBQQBCAEBAQEBAQEHAQEHBgEWAQIBDQECAgEFAQECAgEKAQ0BAQIKAQ0BDQEBAQEBAQEBAgEHAQ4BAQEBAQQBBgEBDgEBAQEBAQcBAQIBAQEBBAEFAQEBDgEBAQEBAQECAQcBDwECAQwCDQEBAQEBAQECAQgBAQEEAQcBDQEBAQEBAQQBBwERAQEBARYBAQECAQEBGAECAQIBARIBBgEBDQECAQEBAQECAQgBAQEZAQEBAgYBAQEDAQECAQEBAQMBCBgIBwEMAQEGAQcBBwEQAQEBAQEBAgIBCgEBDQEIAQ0BAQEBAQEBBgEBDgEBAQEBAQEBAgEMBwEMAQwBAQEBCQECAwEHAQEBAQ0BAQEBDgIBBgEDAQEBAQEBAQMBAQEBAgEBAQEBAQEBCAEBAgEBAQEBAQkBCAgBAwECAQEBAgEBAQkBAQEBAwECAQMBAQIBBwEFAQEDAQYBAQEBAgEBAQEBAQEBAQECAgEDAQECBAIDAgIBBQEEAQEBAwEPAQEBCyIBCAEJAwQBAQIBAQEBAgECAQEBAQMBAQEBAwEBAQEBAQEBAQgBAQMDAgEBAwEEAQIBAQEBBAEBAQEBAQECAQEBAQEBAQEBAQEHAQQBAwEBAQcBAgUBBgECAQYBAQwBAQEUAQELCAYBFgMFAQYDAQoBAQMBARQBAQkBAQoBBgEVAwsBCgIPAQ0BGQEBAgEHARQBAwIBBgEBAQUBBgQBAgEJAQEBBQECAQMHAQELAQECCQEQAQECAgECAQsBDAEBAQEBCgEBAQsBAQEECQ4BCAQCAQEECAEEAQEFCAEPAQEEAQEPAQgBFAEBAQEBAQEKAQEJAQ8BEAEBEwEBAQIBCwEBDgENAwEKAQEBAQELAQEBAQECAQwBCAEBAQEBDgEDAQwBAQECAQEXAQEBAQEHAgEBBQEIAQEBAQEQAgEBBQEUAQEBAQEbAQEBAQEGARQBAQEBARkBAQEBCQEBAQEQAQIBDwEBARQBAQEBBwEBAQkBAQEBAQECAQEBCwECAQEVAQEBAQQBBQEBAQEOAQEBAQEBEgEBFgEBAgEMAQEBAQ8BAQMBFgEBDgEBBQEPAQETAQECAQMOAgUBCgIBGQEBAQEIAQMBBwEBAwECEwgBAQcLAQUBFwEBAQEDAQEBBwEBBAEBDg0BAQwBAQEDAQQBAQEDBAEBBAEBAQEBEAEPAQgBAQsBAQ4BEQEMAgEBBwEOAQEHAQEBAQQBBAEDCwECAQEBAwEBBggBAgEBAREBBQMKAQEBAwQCEQEBHgEPAQIBAQYEAQYBAwEUAQUMAQEBAQEBAQECAQEBAgEIAwEBBgsBAgEODAMBAgEBCwEBAQEBAwECAQECAQEBBwgPAQ=="
    }
  ]
};

// https://deno.land/std@0.196.0/assert/assertion_error.ts
var AssertionError = class extends Error {
  name = "AssertionError";
  constructor(message) {
    super(message);
  }
};

// https://deno.land/std@0.196.0/assert/assert.ts
function assert(expr, msg = "") {
  if (!expr) {
    throw new AssertionError(msg);
  }
}

// https://deno.land/std@0.196.0/console/_rle.ts
function runLengthDecode({ d, r }) {
  const data = atob(d);
  const runLengths = atob(r);
  let out = "";
  for (const [i2, ch] of [...runLengths].entries()) {
    out += data[i2].repeat(ch.codePointAt(0));
  }
  return Uint8Array.from([...out].map((x) => x.codePointAt(0)));
}

// https://deno.land/std@0.196.0/console/unicode_width.ts
var tables = null;
function lookupWidth(cp) {
  if (!tables)
    tables = data_default.tables.map(runLengthDecode);
  const t1Offset = tables[0][cp >> 13 & 255];
  const t2Offset = tables[1][128 * t1Offset + (cp >> 6 & 127)];
  const packedWidths = tables[2][16 * t2Offset + (cp >> 2 & 15)];
  const width = packedWidths >> 2 * (cp & 3) & 3;
  return width === 3 ? 1 : width;
}
var cache = /* @__PURE__ */ new Map();
function charWidth(ch) {
  if (cache.has(ch))
    return cache.get(ch);
  const cp = ch.codePointAt(0);
  let v = null;
  if (cp < 127) {
    v = cp >= 32 ? 1 : cp === 0 ? 0 : null;
  } else if (cp >= 160) {
    v = lookupWidth(cp);
  } else {
    v = null;
  }
  cache.set(ch, v);
  return v;
}
function unicodeWidth(str2) {
  return [...str2].map((ch) => charWidth(ch) ?? 0).reduce((a, b) => a + b, 0);
}

// https://deno.land/x/cliffy@v1.0.0-rc.3/table/_utils.ts
function longest(index, rows, maxWidth) {
  const cellLengths = rows.map((row) => {
    const cell = row[index];
    const cellValue = cell instanceof Cell && cell.getColSpan() > 1 ? "" : cell?.toString() || "";
    return cellValue.split("\n").map((line) => {
      const str2 = typeof maxWidth === "undefined" ? line : consumeWords(maxWidth, line);
      return strLength(str2) || 0;
    });
  }).flat();
  return Math.max(...cellLengths);
}
var strLength = (str2) => {
  return unicodeWidth(stripColor(str2));
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/table/consume_words.ts
function consumeWords(length, content) {
  let consumed = "";
  const words = content.split("\n")[0]?.split(/ /g);
  for (let i2 = 0; i2 < words.length; i2++) {
    const word = words[i2];
    if (consumed) {
      const nextLength = strLength(word);
      const consumedLength = strLength(consumed);
      if (consumedLength + nextLength >= length) {
        break;
      }
    }
    consumed += (i2 > 0 ? " " : "") + word;
  }
  return consumed;
}

// https://deno.land/x/cliffy@v1.0.0-rc.3/table/row.ts
var Row = class _Row extends Array {
  options = {};
  /**
   * Create a new row. If cells is a row, all cells and options of the row will
   * be copied to the new row.
   *
   * @param cells Cells or row.
   */
  static from(cells) {
    const row = new this(...cells);
    if (cells instanceof _Row) {
      row.options = { ...cells.options };
    }
    return row;
  }
  /** Clone row recursively with all options. */
  clone() {
    const row = new _Row(
      ...this.map((cell) => cell instanceof Cell ? cell.clone() : cell)
    );
    row.options = { ...this.options };
    return row;
  }
  /**
   * Setter:
   */
  /**
   * Enable/disable cell border.
   *
   * @param enable    Enable/disable cell border.
   * @param override  Override existing value.
   */
  border(enable = true, override = true) {
    if (override || typeof this.options.border === "undefined") {
      this.options.border = enable;
    }
    return this;
  }
  /**
   * Align row content.
   *
   * @param direction Align direction.
   * @param override  Override existing value.
   */
  align(direction, override = true) {
    if (override || typeof this.options.align === "undefined") {
      this.options.align = direction;
    }
    return this;
  }
  /**
   * Getter:
   */
  /** Check if row has border. */
  getBorder() {
    return this.options.border === true;
  }
  /** Check if row or any child cell has border. */
  hasBorder() {
    return this.getBorder() || this.some((cell) => cell instanceof Cell && cell.getBorder());
  }
  /** Get row alignment. */
  getAlign() {
    return this.options.align ?? "left";
  }
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/table/_layout.ts
var TableLayout = class {
  /**
   * Table layout constructor.
   * @param table   Table instance.
   * @param options Render options.
   */
  constructor(table, options) {
    this.table = table;
    this.options = options;
  }
  /** Generate table string. */
  toString() {
    const opts = this.createLayout();
    return opts.rows.length ? this.renderRows(opts) : "";
  }
  /**
   * Generates table layout including row and col span, converts all none
   * Cell/Row values to Cells and Rows and returns the layout rendering
   * settings.
   */
  createLayout() {
    Object.keys(this.options.chars).forEach((key) => {
      if (typeof this.options.chars[key] !== "string") {
        this.options.chars[key] = "";
      }
    });
    const hasBodyBorder = this.table.getBorder() || this.table.hasBodyBorder();
    const hasHeaderBorder = this.table.hasHeaderBorder();
    const hasBorder = hasHeaderBorder || hasBodyBorder;
    const rows = this.#getRows();
    const columns = Math.max(...rows.map((row) => row.length));
    for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
      const row = rows[rowIndex];
      const length = row.length;
      if (length < columns) {
        const diff2 = columns - length;
        for (let i2 = 0; i2 < diff2; i2++) {
          row.push(this.createCell(null, row, rowIndex, length + i2));
        }
      }
    }
    const padding = [];
    const width = [];
    for (let colIndex = 0; colIndex < columns; colIndex++) {
      const column = this.options.columns.at(colIndex);
      const minColWidth = column?.getMinWidth() ?? (Array.isArray(this.options.minColWidth) ? this.options.minColWidth[colIndex] : this.options.minColWidth);
      const maxColWidth = column?.getMaxWidth() ?? (Array.isArray(this.options.maxColWidth) ? this.options.maxColWidth[colIndex] : this.options.maxColWidth);
      const colWidth = longest(colIndex, rows, maxColWidth);
      width[colIndex] = Math.min(maxColWidth, Math.max(minColWidth, colWidth));
      padding[colIndex] = column?.getPadding() ?? (Array.isArray(this.options.padding) ? this.options.padding[colIndex] : this.options.padding);
    }
    return {
      padding,
      width,
      rows,
      columns,
      hasBorder,
      hasBodyBorder,
      hasHeaderBorder
    };
  }
  #getRows() {
    const header = this.table.getHeader();
    const rows = header ? [header, ...this.table] : this.table.slice();
    const hasSpan = rows.some(
      (row) => row.some(
        (cell) => cell instanceof Cell && (cell.getColSpan() > 1 || cell.getRowSpan() > 1)
      )
    );
    if (hasSpan) {
      return this.spanRows(rows);
    }
    return rows.map((row, rowIndex) => {
      const newRow = this.createRow(row);
      for (let colIndex = 0; colIndex < row.length; colIndex++) {
        newRow[colIndex] = this.createCell(
          row[colIndex],
          newRow,
          rowIndex,
          colIndex
        );
      }
      return newRow;
    });
  }
  /**
   * Fills rows and cols by specified row/col span with a reference of the
   * original cell.
   */
  spanRows(rows) {
    const rowSpan = [];
    let colSpan = 1;
    let rowIndex = -1;
    while (true) {
      rowIndex++;
      if (rowIndex === rows.length && rowSpan.every((span) => span === 1)) {
        break;
      }
      const row = rows[rowIndex] = this.createRow(rows[rowIndex] || []);
      let colIndex = -1;
      while (true) {
        colIndex++;
        if (colIndex === row.length && colIndex === rowSpan.length && colSpan === 1) {
          break;
        }
        if (colSpan > 1) {
          colSpan--;
          rowSpan[colIndex] = rowSpan[colIndex - 1];
          row.splice(
            colIndex,
            this.getDeleteCount(rows, rowIndex, colIndex),
            row[colIndex - 1]
          );
          continue;
        }
        if (rowSpan[colIndex] > 1) {
          rowSpan[colIndex]--;
          rows[rowIndex].splice(
            colIndex,
            this.getDeleteCount(rows, rowIndex, colIndex),
            rows[rowIndex - 1][colIndex]
          );
          continue;
        }
        const cell = row[colIndex] = this.createCell(
          row[colIndex] || null,
          row,
          rowIndex,
          colIndex
        );
        colSpan = cell.getColSpan();
        rowSpan[colIndex] = cell.getRowSpan();
      }
    }
    return rows;
  }
  getDeleteCount(rows, rowIndex, colIndex) {
    return colIndex <= rows[rowIndex].length - 1 && typeof rows[rowIndex][colIndex] === "undefined" ? 1 : 0;
  }
  /**
   * Create a new row from existing row or cell array.
   * @param row Original row.
   */
  createRow(row) {
    return Row.from(row).border(this.table.getBorder(), false).align(this.table.getAlign(), false);
  }
  /**
   * Create a new cell from existing cell or cell value.
   *
   * @param cell      Original cell.
   * @param row       Parent row.
   * @param rowIndex  The row index of the cell.
   * @param colIndex  The column index of the cell.
   */
  createCell(cell, row, rowIndex, colIndex) {
    const column = this.options.columns.at(colIndex);
    const isHeaderRow = this.isHeaderRow(rowIndex);
    return Cell.from(cell ?? "").border(
      (isHeaderRow ? null : column?.getBorder()) ?? row.getBorder(),
      false
    ).align(
      (isHeaderRow ? null : column?.getAlign()) ?? row.getAlign(),
      false
    );
  }
  isHeaderRow(rowIndex) {
    return rowIndex === 0 && this.table.getHeader() !== void 0;
  }
  /**
   * Render table layout.
   * @param opts Render options.
   */
  renderRows(opts) {
    let result2 = "";
    const rowSpan = new Array(opts.columns).fill(1);
    for (let rowIndex = 0; rowIndex < opts.rows.length; rowIndex++) {
      result2 += this.renderRow(rowSpan, rowIndex, opts);
    }
    return result2.slice(0, -1);
  }
  /**
   * Render row.
   * @param rowSpan     Current row span.
   * @param rowIndex    Current row index.
   * @param opts        Render options.
   * @param isMultiline Is multiline row.
   */
  renderRow(rowSpan, rowIndex, opts, isMultiline) {
    const row = opts.rows[rowIndex];
    const prevRow = opts.rows[rowIndex - 1];
    const nextRow = opts.rows[rowIndex + 1];
    let result2 = "";
    let colSpan = 1;
    if (!isMultiline && rowIndex === 0 && row.hasBorder()) {
      result2 += this.renderBorderRow(void 0, row, rowSpan, opts);
    }
    let isMultilineRow = false;
    result2 += " ".repeat(this.options.indent || 0);
    for (let colIndex = 0; colIndex < opts.columns; colIndex++) {
      if (colSpan > 1) {
        colSpan--;
        rowSpan[colIndex] = rowSpan[colIndex - 1];
        continue;
      }
      result2 += this.renderCell(colIndex, row, opts);
      if (rowSpan[colIndex] > 1) {
        if (!isMultiline) {
          rowSpan[colIndex]--;
        }
      } else if (!prevRow || prevRow[colIndex] !== row[colIndex]) {
        rowSpan[colIndex] = row[colIndex].getRowSpan();
      }
      colSpan = row[colIndex].getColSpan();
      if (rowSpan[colIndex] === 1 && row[colIndex].length) {
        isMultilineRow = true;
      }
    }
    if (opts.columns > 0) {
      if (row[opts.columns - 1].getBorder()) {
        result2 += this.options.chars.right;
      } else if (opts.hasBorder) {
        result2 += " ";
      }
    }
    result2 += "\n";
    if (isMultilineRow) {
      return result2 + this.renderRow(rowSpan, rowIndex, opts, isMultilineRow);
    }
    if (opts.rows.length > 1 && (rowIndex === 0 && opts.hasHeaderBorder || rowIndex < opts.rows.length - 1 && opts.hasBodyBorder)) {
      result2 += this.renderBorderRow(row, nextRow, rowSpan, opts);
    }
    if (rowIndex === opts.rows.length - 1 && row.hasBorder()) {
      result2 += this.renderBorderRow(row, void 0, rowSpan, opts);
    }
    return result2;
  }
  /**
   * Render cell.
   * @param colIndex  Current col index.
   * @param row       Current row.
   * @param opts      Render options.
   * @param noBorder  Disable border.
   */
  renderCell(colIndex, row, opts, noBorder) {
    let result2 = "";
    const prevCell = row[colIndex - 1];
    const cell = row[colIndex];
    if (!noBorder) {
      if (colIndex === 0) {
        if (cell.getBorder()) {
          result2 += this.options.chars.left;
        } else if (opts.hasBorder) {
          result2 += " ";
        }
      } else {
        if (cell.getBorder() || prevCell?.getBorder()) {
          result2 += this.options.chars.middle;
        } else if (opts.hasBorder) {
          result2 += " ";
        }
      }
    }
    let maxLength2 = opts.width[colIndex];
    const colSpan = cell.getColSpan();
    if (colSpan > 1) {
      for (let o = 1; o < colSpan; o++) {
        maxLength2 += opts.width[colIndex + o] + opts.padding[colIndex + o];
        if (opts.hasBorder) {
          maxLength2 += opts.padding[colIndex + o] + 1;
        }
      }
    }
    const { current: current2, next } = this.renderCellValue(cell, maxLength2);
    row[colIndex].setValue(next.getValue());
    if (opts.hasBorder) {
      result2 += " ".repeat(opts.padding[colIndex]);
    }
    result2 += current2;
    if (opts.hasBorder || colIndex < opts.columns - 1) {
      result2 += " ".repeat(opts.padding[colIndex]);
    }
    return result2;
  }
  /**
   * Render specified length of cell. Returns the rendered value and a new cell
   * with the rest value.
   * @param cell      Cell to render.
   * @param maxLength Max length of content to render.
   */
  renderCellValue(cell, maxLength2) {
    const length = Math.min(
      maxLength2,
      strLength(cell.toString())
    );
    let words = consumeWords(length, cell.toString());
    const breakWord = strLength(words) > length;
    if (breakWord) {
      words = words.slice(0, length);
    }
    const next = cell.toString().slice(words.length + (breakWord ? 0 : 1));
    const fillLength = maxLength2 - strLength(words);
    const align = cell.getAlign();
    let current2;
    if (fillLength === 0) {
      current2 = words;
    } else if (align === "left") {
      current2 = words + " ".repeat(fillLength);
    } else if (align === "center") {
      current2 = " ".repeat(Math.floor(fillLength / 2)) + words + " ".repeat(Math.ceil(fillLength / 2));
    } else if (align === "right") {
      current2 = " ".repeat(fillLength) + words;
    } else {
      throw new Error("Unknown direction: " + align);
    }
    return {
      current: current2,
      next: cell.clone(next)
    };
  }
  /**
   * Render border row.
   * @param prevRow Previous row.
   * @param nextRow Next row.
   * @param rowSpan Current row span.
   * @param opts    Render options.
   */
  renderBorderRow(prevRow, nextRow, rowSpan, opts) {
    let result2 = "";
    let colSpan = 1;
    for (let colIndex = 0; colIndex < opts.columns; colIndex++) {
      if (rowSpan[colIndex] > 1) {
        if (!nextRow) {
          throw new Error("invalid layout");
        }
        if (colSpan > 1) {
          colSpan--;
          continue;
        }
      }
      result2 += this.renderBorderCell(
        colIndex,
        prevRow,
        nextRow,
        rowSpan,
        opts
      );
      colSpan = nextRow?.[colIndex].getColSpan() ?? 1;
    }
    return result2.length ? " ".repeat(this.options.indent) + result2 + "\n" : "";
  }
  /**
   * Render border cell.
   * @param colIndex  Current index.
   * @param prevRow   Previous row.
   * @param nextRow   Next row.
   * @param rowSpan   Current row span.
   * @param opts      Render options.
   */
  renderBorderCell(colIndex, prevRow, nextRow, rowSpan, opts) {
    const a1 = prevRow?.[colIndex - 1];
    const a2 = nextRow?.[colIndex - 1];
    const b1 = prevRow?.[colIndex];
    const b2 = nextRow?.[colIndex];
    const a1Border = !!a1?.getBorder();
    const a2Border = !!a2?.getBorder();
    const b1Border = !!b1?.getBorder();
    const b2Border = !!b2?.getBorder();
    const hasColSpan = (cell) => (cell?.getColSpan() ?? 1) > 1;
    const hasRowSpan = (cell) => (cell?.getRowSpan() ?? 1) > 1;
    let result2 = "";
    if (colIndex === 0) {
      if (rowSpan[colIndex] > 1) {
        if (b1Border) {
          result2 += this.options.chars.left;
        } else {
          result2 += " ";
        }
      } else if (b1Border && b2Border) {
        result2 += this.options.chars.leftMid;
      } else if (b1Border) {
        result2 += this.options.chars.bottomLeft;
      } else if (b2Border) {
        result2 += this.options.chars.topLeft;
      } else {
        result2 += " ";
      }
    } else if (colIndex < opts.columns) {
      if (a1Border && b2Border || b1Border && a2Border) {
        const a1ColSpan = hasColSpan(a1);
        const a2ColSpan = hasColSpan(a2);
        const b1ColSpan = hasColSpan(b1);
        const b2ColSpan = hasColSpan(b2);
        const a1RowSpan = hasRowSpan(a1);
        const a2RowSpan = hasRowSpan(a2);
        const b1RowSpan = hasRowSpan(b1);
        const b2RowSpan = hasRowSpan(b2);
        const hasAllBorder = a1Border && b2Border && b1Border && a2Border;
        const hasAllRowSpan = a1RowSpan && b1RowSpan && a2RowSpan && b2RowSpan;
        const hasAllColSpan = a1ColSpan && b1ColSpan && a2ColSpan && b2ColSpan;
        if (hasAllRowSpan && hasAllBorder) {
          result2 += this.options.chars.middle;
        } else if (hasAllColSpan && hasAllBorder && a1 === b1 && a2 === b2) {
          result2 += this.options.chars.mid;
        } else if (a1ColSpan && b1ColSpan && a1 === b1) {
          result2 += this.options.chars.topMid;
        } else if (a2ColSpan && b2ColSpan && a2 === b2) {
          result2 += this.options.chars.bottomMid;
        } else if (a1RowSpan && a2RowSpan && a1 === a2) {
          result2 += this.options.chars.leftMid;
        } else if (b1RowSpan && b2RowSpan && b1 === b2) {
          result2 += this.options.chars.rightMid;
        } else {
          result2 += this.options.chars.midMid;
        }
      } else if (a1Border && b1Border) {
        if (hasColSpan(a1) && hasColSpan(b1) && a1 === b1) {
          result2 += this.options.chars.bottom;
        } else {
          result2 += this.options.chars.bottomMid;
        }
      } else if (b1Border && b2Border) {
        if (rowSpan[colIndex] > 1) {
          result2 += this.options.chars.left;
        } else {
          result2 += this.options.chars.leftMid;
        }
      } else if (b2Border && a2Border) {
        if (hasColSpan(a2) && hasColSpan(b2) && a2 === b2) {
          result2 += this.options.chars.top;
        } else {
          result2 += this.options.chars.topMid;
        }
      } else if (a1Border && a2Border) {
        if (hasRowSpan(a1) && a1 === a2) {
          result2 += this.options.chars.right;
        } else {
          result2 += this.options.chars.rightMid;
        }
      } else if (a1Border) {
        result2 += this.options.chars.bottomRight;
      } else if (b1Border) {
        result2 += this.options.chars.bottomLeft;
      } else if (a2Border) {
        result2 += this.options.chars.topRight;
      } else if (b2Border) {
        result2 += this.options.chars.topLeft;
      } else {
        result2 += " ";
      }
    }
    const length = opts.padding[colIndex] + opts.width[colIndex] + opts.padding[colIndex];
    if (rowSpan[colIndex] > 1 && nextRow) {
      result2 += this.renderCell(
        colIndex,
        nextRow,
        opts,
        true
      );
      if (nextRow[colIndex] === nextRow[nextRow.length - 1]) {
        if (b1Border) {
          result2 += this.options.chars.right;
        } else {
          result2 += " ";
        }
        return result2;
      }
    } else if (b1Border && b2Border) {
      result2 += this.options.chars.mid.repeat(length);
    } else if (b1Border) {
      result2 += this.options.chars.bottom.repeat(length);
    } else if (b2Border) {
      result2 += this.options.chars.top.repeat(length);
    } else {
      result2 += " ".repeat(length);
    }
    if (colIndex === opts.columns - 1) {
      if (b1Border && b2Border) {
        result2 += this.options.chars.rightMid;
      } else if (b1Border) {
        result2 += this.options.chars.bottomRight;
      } else if (b2Border) {
        result2 += this.options.chars.topRight;
      } else {
        result2 += " ";
      }
    }
    return result2;
  }
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/table/table.ts
var Table = class _Table extends Array {
  static _chars = { ...border };
  options = {
    indent: 0,
    border: false,
    maxColWidth: Infinity,
    minColWidth: 0,
    padding: 1,
    chars: { ..._Table._chars },
    columns: []
  };
  headerRow;
  /**
   * Create a new table. If rows is a table, all rows and options of the table
   * will be copied to the new table.
   *
   * @param rows An array of rows or a table instance.
   */
  static from(rows) {
    const table = new this(...rows);
    if (rows instanceof _Table) {
      table.options = { ...rows.options };
      table.headerRow = rows.headerRow ? Row.from(rows.headerRow) : void 0;
    }
    return table;
  }
  /**
   * Create a new table from an array of json objects. An object represents a
   * row and each property a column.
   *
   * @param rows Array of objects.
   */
  static fromJson(rows) {
    return new this().fromJson(rows);
  }
  /**
   * Set global default border characters.
   *
   * @param chars Border options.
   */
  static chars(chars) {
    Object.assign(this._chars, chars);
    return this;
  }
  /**
   * Write table or rows to stdout.
   *
   * @param rows Table or rows.
   */
  static render(rows) {
    _Table.from(rows).render();
  }
  /**
   * Read data from an array of json objects. An object represents a
   * row and each property a column.
   *
   * @param rows Array of objects.
   */
  fromJson(rows) {
    this.header(Object.keys(rows[0]));
    this.body(rows.map((row) => Object.values(row)));
    return this;
  }
  /**
   * Set column options.
   *
   * @param columns An array of columns or column options.
   */
  columns(columns) {
    this.options.columns = columns.map(
      (column) => column instanceof Column ? column : Column.from(column)
    );
    return this;
  }
  /**
   * Set column options by index.
   *
   @param index   The column index.
   @param column  Column or column options.
   */
  column(index, column) {
    if (column instanceof Column) {
      this.options.columns[index] = column;
    } else if (this.options.columns[index]) {
      this.options.columns[index].options(column);
    } else {
      this.options.columns[index] = Column.from(column);
    }
    return this;
  }
  /**
   * Set table header.
   *
   * @param header Header row or cells.
   */
  header(header) {
    this.headerRow = header instanceof Row ? header : Row.from(header);
    return this;
  }
  /**
   * Set table body.
   *
   * @param rows Array of rows.
   */
  body(rows) {
    this.length = 0;
    this.push(...rows);
    return this;
  }
  /** Clone table recursively with header and options. */
  clone() {
    const table = new _Table(
      ...this.map(
        (row) => row instanceof Row ? row.clone() : Row.from(row).clone()
      )
    );
    table.options = { ...this.options };
    table.headerRow = this.headerRow?.clone();
    return table;
  }
  /** Generate table string. */
  toString() {
    return new TableLayout(this, this.options).toString();
  }
  /** Write table to stdout. */
  render() {
    console.log(this.toString());
    return this;
  }
  /**
   * Set max column width.
   *
   * @param width     Max column width.
   * @param override  Override existing value.
   */
  maxColWidth(width, override = true) {
    if (override || typeof this.options.maxColWidth === "undefined") {
      this.options.maxColWidth = width;
    }
    return this;
  }
  /**
   * Set min column width.
   *
   * @param width     Min column width.
   * @param override  Override existing value.
   */
  minColWidth(width, override = true) {
    if (override || typeof this.options.minColWidth === "undefined") {
      this.options.minColWidth = width;
    }
    return this;
  }
  /**
   * Set table indentation.
   *
   * @param width     Indent width.
   * @param override  Override existing value.
   */
  indent(width, override = true) {
    if (override || typeof this.options.indent === "undefined") {
      this.options.indent = width;
    }
    return this;
  }
  /**
   * Set cell padding.
   *
   * @param padding   Cell padding.
   * @param override  Override existing value.
   */
  padding(padding, override = true) {
    if (override || typeof this.options.padding === "undefined") {
      this.options.padding = padding;
    }
    return this;
  }
  /**
   * Enable/disable cell border.
   *
   * @param enable    Enable/disable cell border.
   * @param override  Override existing value.
   */
  border(enable = true, override = true) {
    if (override || typeof this.options.border === "undefined") {
      this.options.border = enable;
    }
    return this;
  }
  /**
   * Align table content.
   *
   * @param direction Align direction.
   * @param override  Override existing value.
   */
  align(direction, override = true) {
    if (override || typeof this.options.align === "undefined") {
      this.options.align = direction;
    }
    return this;
  }
  /**
   * Set border characters.
   *
   * @param chars Border options.
   */
  chars(chars) {
    Object.assign(this.options.chars, chars);
    return this;
  }
  /** Get table header. */
  getHeader() {
    return this.headerRow;
  }
  /** Get table body. */
  getBody() {
    return [...this];
  }
  /** Get max column width. */
  getMaxColWidth() {
    return this.options.maxColWidth;
  }
  /** Get min column width. */
  getMinColWidth() {
    return this.options.minColWidth;
  }
  /** Get table indentation. */
  getIndent() {
    return this.options.indent;
  }
  /** Get cell padding. */
  getPadding() {
    return this.options.padding;
  }
  /** Check if table has border. */
  getBorder() {
    return this.options.border === true;
  }
  /** Check if header row has border. */
  hasHeaderBorder() {
    const hasBorder = this.headerRow?.hasBorder();
    return hasBorder === true || this.getBorder() && hasBorder !== false;
  }
  /** Check if table bordy has border. */
  hasBodyBorder() {
    return this.getBorder() || this.options.columns.some((column) => column.getBorder()) || this.some(
      (row) => row instanceof Row ? row.hasBorder() : row.some((cell) => cell instanceof Cell ? cell.getBorder() : false)
    );
  }
  /** Check if table header or body has border. */
  hasBorder() {
    return this.hasHeaderBorder() || this.hasBodyBorder();
  }
  /** Get table alignment. */
  getAlign() {
    return this.options.align ?? "left";
  }
  /** Get columns. */
  getColumns() {
    return this.options.columns;
  }
  /** Get column by column index. */
  getColumn(index) {
    return this.options.columns[index] ??= new Column();
  }
};

// https://deno.land/x/cliffy@v1.0.0-rc.3/command/help/_help_generator.ts
var HelpGenerator = class _HelpGenerator {
  constructor(cmd, options = {}) {
    this.cmd = cmd;
    this.options = {
      types: false,
      hints: true,
      colors: true,
      long: false,
      ...options
    };
  }
  indent = 2;
  options;
  /** Generate help text for given command. */
  static generate(cmd, options) {
    return new _HelpGenerator(cmd, options).generate();
  }
  generate() {
    const areColorsEnabled = getColorEnabled();
    setColorEnabled(this.options.colors);
    const result2 = this.generateHeader() + this.generateMeta() + this.generateDescription() + this.generateOptions() + this.generateCommands() + this.generateEnvironmentVariables() + this.generateExamples();
    setColorEnabled(areColorsEnabled);
    return result2;
  }
  generateHeader() {
    const usage = this.cmd.getUsage();
    const rows = [
      [
        bold("Usage:"),
        brightMagenta(
          this.cmd.getPath() + (usage ? " " + highlightArguments(usage, this.options.types) : "")
        )
      ]
    ];
    const version = this.cmd.getVersion();
    if (version) {
      rows.push([bold("Version:"), yellow(`${this.cmd.getVersion()}`)]);
    }
    return "\n" + Table.from(rows).padding(1).toString() + "\n";
  }
  generateMeta() {
    const meta = Object.entries(this.cmd.getMeta());
    if (!meta.length) {
      return "";
    }
    const rows = [];
    for (const [name, value] of meta) {
      rows.push([bold(`${name}: `) + value]);
    }
    return "\n" + Table.from(rows).padding(1).toString() + "\n";
  }
  generateDescription() {
    if (!this.cmd.getDescription()) {
      return "";
    }
    return this.label("Description") + Table.from([
      [dedent(this.cmd.getDescription())]
    ]).indent(this.indent).maxColWidth(140).padding(1).toString() + "\n";
  }
  generateOptions() {
    const options = this.cmd.getOptions(false);
    if (!options.length) {
      return "";
    }
    let groups = [];
    const hasGroups = options.some((option) => option.groupName);
    if (hasGroups) {
      for (const option of options) {
        let group = groups.find((group2) => group2.name === option.groupName);
        if (!group) {
          group = {
            name: option.groupName,
            options: []
          };
          groups.push(group);
        }
        group.options.push(option);
      }
    } else {
      groups = [{
        name: "Options",
        options
      }];
    }
    let result2 = "";
    for (const group of groups) {
      result2 += this.generateOptionGroup(group);
    }
    return result2;
  }
  generateOptionGroup(group) {
    if (!group.options.length) {
      return "";
    }
    const hasTypeDefinitions = !!group.options.find(
      (option) => !!option.typeDefinition
    );
    if (hasTypeDefinitions) {
      return this.label(group.name ?? "Options") + Table.from([
        ...group.options.map((option) => [
          option.flags.map((flag) => brightBlue(flag)).join(", "),
          highlightArguments(
            option.typeDefinition || "",
            this.options.types
          ),
          red(bold("-")),
          getDescription(option.description, !this.options.long),
          this.generateHints(option)
        ])
      ]).padding([2, 2, 1, 2]).indent(this.indent).maxColWidth([60, 60, 1, 80, 60]).toString() + "\n";
    }
    return this.label(group.name ?? "Options") + Table.from([
      ...group.options.map((option) => [
        option.flags.map((flag) => brightBlue(flag)).join(", "),
        red(bold("-")),
        getDescription(option.description, !this.options.long),
        this.generateHints(option)
      ])
    ]).indent(this.indent).maxColWidth([60, 1, 80, 60]).padding([2, 1, 2]).toString() + "\n";
  }
  generateCommands() {
    const commands = this.cmd.getCommands(false);
    if (!commands.length) {
      return "";
    }
    const hasTypeDefinitions = !!commands.find(
      (command2) => !!command2.getArgsDefinition()
    );
    if (hasTypeDefinitions) {
      return this.label("Commands") + Table.from([
        ...commands.map((command2) => [
          [command2.getName(), ...command2.getAliases()].map(
            (name) => brightBlue(name)
          ).join(", "),
          highlightArguments(
            command2.getArgsDefinition() || "",
            this.options.types
          ),
          red(bold("-")),
          command2.getShortDescription()
        ])
      ]).indent(this.indent).maxColWidth([60, 60, 1, 80]).padding([2, 2, 1, 2]).toString() + "\n";
    }
    return this.label("Commands") + Table.from([
      ...commands.map((command2) => [
        [command2.getName(), ...command2.getAliases()].map(
          (name) => brightBlue(name)
        ).join(", "),
        red(bold("-")),
        command2.getShortDescription()
      ])
    ]).maxColWidth([60, 1, 80]).padding([2, 1, 2]).indent(this.indent).toString() + "\n";
  }
  generateEnvironmentVariables() {
    const envVars = this.cmd.getEnvVars(false);
    if (!envVars.length) {
      return "";
    }
    return this.label("Environment variables") + Table.from([
      ...envVars.map((envVar) => [
        envVar.names.map((name) => brightBlue(name)).join(", "),
        highlightArgumentDetails(
          envVar.details,
          this.options.types
        ),
        red(bold("-")),
        this.options.long ? dedent(envVar.description) : envVar.description.trim().split("\n", 1)[0],
        envVar.required ? `(${yellow(`required`)})` : ""
      ])
    ]).padding([2, 2, 1, 2]).indent(this.indent).maxColWidth([60, 60, 1, 80, 10]).toString() + "\n";
  }
  generateExamples() {
    const examples = this.cmd.getExamples();
    if (!examples.length) {
      return "";
    }
    return this.label("Examples") + Table.from(examples.map((example) => [
      dim(bold(`${capitalize(example.name)}:`)),
      dedent(example.description)
    ])).padding(1).indent(this.indent).maxColWidth(150).toString() + "\n";
  }
  generateHints(option) {
    if (!this.options.hints) {
      return "";
    }
    const hints = [];
    option.required && hints.push(yellow(`required`));
    if (typeof option.default !== "undefined") {
      const defaultValue = getDefaultValue(option);
      if (typeof defaultValue !== "undefined") {
        hints.push(
          bold(`Default: `) + inspect(defaultValue, this.options.colors)
        );
      }
    }
    option.depends?.length && hints.push(
      yellow(bold(`Depends: `)) + italic(option.depends.map(getFlag).join(", "))
    );
    option.conflicts?.length && hints.push(
      red(bold(`Conflicts: `)) + italic(option.conflicts.map(getFlag).join(", "))
    );
    const type = this.cmd.getType(option.args[0]?.type)?.handler;
    if (type instanceof Type) {
      const possibleValues = type.values?.(this.cmd, this.cmd.getParent());
      if (possibleValues?.length) {
        hints.push(
          bold(`Values: `) + possibleValues.map(
            (value) => inspect(value, this.options.colors)
          ).join(", ")
        );
      }
    }
    if (hints.length) {
      return `(${hints.join(", ")})`;
    }
    return "";
  }
  label(label) {
    return "\n" + bold(`${label}:`) + "\n\n";
  }
};
function capitalize(string2) {
  return string2?.charAt(0).toUpperCase() + string2.slice(1);
}
function inspect(value, colors) {
  return Deno.inspect(
    value,
    // deno < 1.4.3 doesn't support the colors property.
    { depth: 1, colors, trailingComma: false }
  );
}
function highlightArguments(argsDefinition, types = true) {
  if (!argsDefinition) {
    return "";
  }
  return parseArgumentsDefinition(argsDefinition, false, true).map(
    (arg) => typeof arg === "string" ? arg : highlightArgumentDetails(arg, types)
  ).join(" ");
}
function highlightArgumentDetails(arg, types = true) {
  let str2 = "";
  str2 += yellow(arg.optional ? "[" : "<");
  let name = "";
  name += arg.name;
  if (arg.variadic) {
    name += "...";
  }
  name = brightMagenta(name);
  str2 += name;
  if (types) {
    str2 += yellow(":");
    str2 += red(arg.type);
    if (arg.list) {
      str2 += green("[]");
    }
  }
  str2 += yellow(arg.optional ? "]" : ">");
  return str2;
}

// https://deno.land/x/cliffy@v1.0.0-rc.3/command/upgrade/_check_version.ts
async function checkVersion(cmd) {
  const mainCommand = cmd.getMainCommand();
  const upgradeCommand = mainCommand.getCommand("upgrade");
  if (!isUpgradeCommand(upgradeCommand)) {
    return;
  }
  const latestVersion = await upgradeCommand.getLatestVersion();
  const currentVersion = mainCommand.getVersion();
  if (currentVersion === latestVersion) {
    return;
  }
  const versionHelpText = `(New version available: ${latestVersion}. Run '${mainCommand.getName()} upgrade' to upgrade to the latest version!)`;
  mainCommand.version(`${currentVersion}  ${bold(yellow(versionHelpText))}`);
}
function isUpgradeCommand(command2) {
  return command2 instanceof Command && "getLatestVersion" in command2;
}

// https://deno.land/x/cliffy@v1.0.0-rc.3/command/command.ts
var Command = class _Command {
  types = /* @__PURE__ */ new Map();
  rawArgs = [];
  literalArgs = [];
  _name = "COMMAND";
  _parent;
  _globalParent;
  ver;
  desc = "";
  _usage;
  actionHandler;
  globalActionHandler;
  options = [];
  commands = /* @__PURE__ */ new Map();
  examples = [];
  envVars = [];
  aliases = [];
  completions = /* @__PURE__ */ new Map();
  cmd = this;
  argsDefinition;
  isExecutable = false;
  throwOnError = false;
  _allowEmpty = false;
  _stopEarly = false;
  defaultCommand;
  _useRawArgs = false;
  args = [];
  isHidden = false;
  isGlobal = false;
  hasDefaults = false;
  _versionOptions;
  _helpOptions;
  _versionOption;
  _helpOption;
  _help;
  _shouldExit;
  _meta = {};
  _groupName = null;
  _noGlobals = false;
  errorHandler;
  versionOption(flags, desc, opts) {
    this._versionOptions = flags === false ? flags : {
      flags,
      desc,
      opts: typeof opts === "function" ? { action: opts } : opts
    };
    return this;
  }
  helpOption(flags, desc, opts) {
    this._helpOptions = flags === false ? flags : {
      flags,
      desc,
      opts: typeof opts === "function" ? { action: opts } : opts
    };
    return this;
  }
  /**
   * Add new sub-command.
   * @param nameAndArguments  Command definition. E.g: `my-command <input-file:string> <output-file:string>`
   * @param cmdOrDescription  The description of the new child command.
   * @param override          Override existing child command.
   */
  command(nameAndArguments, cmdOrDescription, override) {
    this.reset();
    const result2 = splitArguments(nameAndArguments);
    const name = result2.flags.shift();
    const aliases = result2.flags;
    if (!name) {
      throw new MissingCommandNameError();
    }
    if (this.getBaseCommand(name, true)) {
      if (!override) {
        throw new DuplicateCommandNameError(name);
      }
      this.removeCommand(name);
    }
    let description;
    let cmd;
    if (typeof cmdOrDescription === "string") {
      description = cmdOrDescription;
    }
    if (cmdOrDescription instanceof _Command) {
      cmd = cmdOrDescription.reset();
    } else {
      cmd = new _Command();
    }
    cmd._name = name;
    cmd._parent = this;
    if (description) {
      cmd.description(description);
    }
    if (result2.typeDefinition) {
      cmd.arguments(result2.typeDefinition);
    }
    aliases.forEach((alias) => cmd.alias(alias));
    this.commands.set(name, cmd);
    this.select(name);
    return this;
  }
  /**
   * Add new command alias.
   *
   * @param alias Tha name of the alias.
   */
  alias(alias) {
    if (this.cmd._name === alias || this.cmd.aliases.includes(alias)) {
      throw new DuplicateCommandAliasError(alias);
    }
    this.cmd.aliases.push(alias);
    return this;
  }
  /** Reset internal command reference to main command. */
  reset() {
    this._groupName = null;
    this.cmd = this;
    return this;
  }
  /**
   * Set internal command pointer to child command with given name.
   * @param name The name of the command to select.
   */
  select(name) {
    const cmd = this.getBaseCommand(name, true);
    if (!cmd) {
      throw new CommandNotFoundError(name, this.getBaseCommands(true));
    }
    this.cmd = cmd;
    return this;
  }
  /*****************************************************************************
   **** SUB HANDLER ************************************************************
   *****************************************************************************/
  /** Set command name. Used in auto generated help and shell completions */
  name(name) {
    this.cmd._name = name;
    return this;
  }
  /**
   * Set command version.
   *
   * @param version Semantic version string string or method that returns the version string.
   */
  version(version) {
    if (typeof version === "string") {
      this.cmd.ver = () => version;
    } else if (typeof version === "function") {
      this.cmd.ver = version;
    }
    return this;
  }
  /**
   * Add meta data. Will be displayed in the auto generated help and in the
   * output of the long version.
   *
   * @param name  The name/label of the metadata.
   * @param value The value of the metadata.
   */
  meta(name, value) {
    this.cmd._meta[name] = value;
    return this;
  }
  getMeta(name) {
    return typeof name === "undefined" ? this._meta : this._meta[name];
  }
  /**
   * Set command help.
   *
   * @param help Help string, method, or config for generator that returns the help string.
   */
  help(help) {
    if (typeof help === "string") {
      this.cmd._help = () => help;
    } else if (typeof help === "function") {
      this.cmd._help = help;
    } else {
      this.cmd._help = (cmd, options) => HelpGenerator.generate(cmd, { ...help, ...options });
    }
    return this;
  }
  /**
   * Set the long command description.
   *
   * @param description The command description.
   */
  description(description) {
    this.cmd.desc = description;
    return this;
  }
  /**
   * Set the command usage. Defaults to arguments.
   *
   * @param usage The command usage.
   */
  usage(usage) {
    this.cmd._usage = usage;
    return this;
  }
  /** Hide command from help, completions, etc. */
  hidden() {
    this.cmd.isHidden = true;
    return this;
  }
  /** Make command globally available. */
  global() {
    this.cmd.isGlobal = true;
    return this;
  }
  /** Make command executable. */
  executable() {
    this.cmd.isExecutable = true;
    return this;
  }
  /**
   * Set command arguments:
   *
   *   <requiredArg:string> [optionalArg: number] [...restArgs:string]
   */
  arguments(args) {
    this.cmd.argsDefinition = args;
    return this;
  }
  /**
   * Set command callback method.
   *
   * @param fn Command action handler.
   */
  action(fn) {
    this.cmd.actionHandler = fn;
    return this;
  }
  /**
   * Set command callback method.
   *
   * @param fn Command action handler.
   */
  globalAction(fn) {
    this.cmd.globalActionHandler = fn;
    return this;
  }
  /**
   * Don't throw an error if the command was called without arguments.
   *
   * @param allowEmpty Enable/disable allow empty.
   */
  allowEmpty(allowEmpty) {
    this.cmd._allowEmpty = allowEmpty !== false;
    return this;
  }
  /**
   * Enable stop early. If enabled, all arguments starting from the first non
   * option argument will be passed as arguments with type string to the command
   * action handler.
   *
   * For example:
   *     `command --debug-level warning server --port 80`
   *
   * Will result in:
   *     - options: `{ debugLevel: 'warning' }`
   *     - args: `['server', '--port', '80']`
   *
   * @param stopEarly Enable/disable stop early.
   */
  stopEarly(stopEarly = true) {
    this.cmd._stopEarly = stopEarly;
    return this;
  }
  /**
   * Disable parsing arguments. If enabled the raw arguments will be passed to
   * the action handler. This has no effect for parent or child commands. Only
   * for the command on which this method was called.
   *
   * @param useRawArgs Enable/disable raw arguments.
   */
  useRawArgs(useRawArgs = true) {
    this.cmd._useRawArgs = useRawArgs;
    return this;
  }
  /**
   * Set default command. The default command is executed when the program
   * was called without any argument and if no action handler is registered.
   *
   * @param name Name of the default command.
   */
  default(name) {
    this.cmd.defaultCommand = name;
    return this;
  }
  globalType(name, handler, options) {
    return this.type(name, handler, { ...options, global: true });
  }
  /**
   * Register custom type.
   *
   * @param name    The name of the type.
   * @param handler The callback method to parse the type.
   * @param options Type options.
   */
  type(name, handler, options) {
    if (this.cmd.types.get(name) && !options?.override) {
      throw new DuplicateTypeError(name);
    }
    this.cmd.types.set(name, {
      ...options,
      name,
      handler
    });
    if (handler instanceof Type && (typeof handler.complete !== "undefined" || typeof handler.values !== "undefined")) {
      const completeHandler = (cmd, parent) => handler.complete?.(cmd, parent) || [];
      this.complete(name, completeHandler, options);
    }
    return this;
  }
  /**
   * Register global complete handler.
   *
   * @param name      The name of the completion.
   * @param complete  The callback method to complete the type.
   * @param options   Complete options.
   */
  globalComplete(name, complete, options) {
    return this.complete(name, complete, { ...options, global: true });
  }
  complete(name, complete, options) {
    if (this.cmd.completions.has(name) && !options?.override) {
      throw new DuplicateCompletionError(name);
    }
    this.cmd.completions.set(name, {
      name,
      complete,
      ...options
    });
    return this;
  }
  /**
   * Throw validation errors instead of calling `Deno.exit()` to handle
   * validation errors manually.
   *
   * A validation error is thrown when the command is wrongly used by the user.
   * For example: If the user passes some invalid options or arguments to the
   * command.
   *
   * This has no effect for parent commands. Only for the command on which this
   * method was called and all child commands.
   *
   * **Example:**
   *
   * ```ts
   * import { Command, ValidationError } from "./mod.ts";
   *
   * const cmd = new Command();
   * // ...
   *
   * try {
   *   cmd.parse();
   * } catch(error) {
   *   if (error instanceof ValidationError) {
   *     cmd.showHelp();
   *     Deno.exit(1);
   *   }
   *   throw error;
   * }
   * ```
   *
   * @see ValidationError
   */
  throwErrors() {
    this.cmd.throwOnError = true;
    return this;
  }
  /**
   * Set custom error handler.
   *
   * @param handler Error handler callback function.
   */
  error(handler) {
    this.cmd.errorHandler = handler;
    return this;
  }
  /** Get error handler callback function. */
  getErrorHandler() {
    return this.errorHandler ?? this._parent?.errorHandler;
  }
  /**
   * Same as `.throwErrors()` but also prevents calling `Deno.exit` after
   * printing help or version with the --help and --version option.
   */
  noExit() {
    this.cmd._shouldExit = false;
    this.throwErrors();
    return this;
  }
  /**
   * Disable inheriting global commands, options and environment variables from
   * parent commands.
   */
  noGlobals() {
    this.cmd._noGlobals = true;
    return this;
  }
  /** Check whether the command should throw errors or exit. */
  shouldThrowErrors() {
    return this.throwOnError || !!this._parent?.shouldThrowErrors();
  }
  /** Check whether the command should exit after printing help or version. */
  shouldExit() {
    return this._shouldExit ?? this._parent?.shouldExit() ?? true;
  }
  /**
   * Enable grouping of options and set the name of the group.
   * All option which are added after calling the `.group()` method will be
   * grouped in the help output. If the `.group()` method can be use multiple
   * times to create more groups.
   *
   * @param name The name of the option group.
   */
  group(name) {
    this.cmd._groupName = name;
    return this;
  }
  /**
   * Register a global option.
   *
   * @param flags Flags string e.g: -h, --help, --manual <requiredArg:string> [optionalArg:number] [...restArgs:string]
   * @param desc Flag description.
   * @param opts Flag options or custom handler for processing flag value.
   */
  globalOption(flags, desc, opts) {
    if (typeof opts === "function") {
      return this.option(
        flags,
        desc,
        { value: opts, global: true }
      );
    }
    return this.option(
      flags,
      desc,
      { ...opts, global: true }
    );
  }
  option(flags, desc, opts) {
    if (typeof opts === "function") {
      opts = { value: opts };
    }
    const result2 = splitArguments(flags);
    const args = result2.typeDefinition ? parseArgumentsDefinition(result2.typeDefinition) : [];
    const option = {
      ...opts,
      name: "",
      description: desc,
      args,
      flags: result2.flags,
      equalsSign: result2.equalsSign,
      typeDefinition: result2.typeDefinition,
      groupName: this._groupName ?? void 0
    };
    if (option.separator) {
      for (const arg of args) {
        if (arg.list) {
          arg.separator = option.separator;
        }
      }
    }
    for (const part of option.flags) {
      const arg = part.trim();
      const isLong = /^--/.test(arg);
      const name = isLong ? arg.slice(2) : arg.slice(1);
      if (this.cmd.getBaseOption(name, true)) {
        if (opts?.override) {
          this.removeOption(name);
        } else {
          throw new DuplicateOptionNameError(name, this.getPath());
        }
      }
      if (!option.name && isLong) {
        option.name = name;
      } else if (!option.aliases) {
        option.aliases = [name];
      } else {
        option.aliases.push(name);
      }
    }
    if (option.prepend) {
      this.cmd.options.unshift(option);
    } else {
      this.cmd.options.push(option);
    }
    return this;
  }
  /**
   * Register command example.
   *
   * @param name          Name of the example.
   * @param description   The content of the example.
   */
  example(name, description) {
    if (this.cmd.hasExample(name)) {
      throw new DuplicateExampleError(name);
    }
    this.cmd.examples.push({ name, description });
    return this;
  }
  /**
   * @param flags Flags string e.g: -h, --help, --manual <requiredArg:string> [optionalArg:number] [...restArgs:string]
   * @param desc Flag description.
   * @param opts Flag options or custom handler for processing flag value.
   */
  /**
   * Register a global environment variable.
   *
   * @param name        Name of the environment variable.
   * @param description The description of the environment variable.
   * @param options     Environment variable options.
   */
  globalEnv(name, description, options) {
    return this.env(
      name,
      description,
      { ...options, global: true }
    );
  }
  env(name, description, options) {
    const result2 = splitArguments(name);
    if (!result2.typeDefinition) {
      result2.typeDefinition = "<value:boolean>";
    }
    if (result2.flags.some((envName) => this.cmd.getBaseEnvVar(envName, true))) {
      throw new DuplicateEnvVarError(name);
    }
    const details = parseArgumentsDefinition(
      result2.typeDefinition
    );
    if (details.length > 1) {
      throw new TooManyEnvVarValuesError(name);
    } else if (details.length && details[0].optional) {
      throw new UnexpectedOptionalEnvVarValueError(name);
    } else if (details.length && details[0].variadic) {
      throw new UnexpectedVariadicEnvVarValueError(name);
    }
    this.cmd.envVars.push({
      name: result2.flags[0],
      names: result2.flags,
      description,
      type: details[0].type,
      details: details.shift(),
      ...options
    });
    return this;
  }
  /*****************************************************************************
   **** MAIN HANDLER ***********************************************************
   *****************************************************************************/
  /**
   * Parse command line arguments and execute matched command.
   *
   * @param args Command line args to parse. Ex: `cmd.parse( Deno.args )`
   */
  parse(args = Deno.args) {
    const ctx = {
      unknown: args.slice(),
      flags: {},
      env: {},
      literal: [],
      stopEarly: false,
      stopOnUnknown: false,
      defaults: {},
      actions: []
    };
    return this.parseCommand(ctx);
  }
  async parseCommand(ctx) {
    try {
      this.reset();
      this.registerDefaults();
      this.rawArgs = ctx.unknown.slice();
      if (this.isExecutable) {
        await this.executeExecutable(ctx.unknown);
        return { options: {}, args: [], cmd: this, literal: [] };
      } else if (this._useRawArgs) {
        await this.parseEnvVars(ctx, this.envVars);
        return await this.execute(ctx.env, ctx.unknown);
      }
      let preParseGlobals = false;
      let subCommand;
      if (ctx.unknown.length > 0) {
        subCommand = this.getSubCommand(ctx);
        if (!subCommand) {
          const optionName = ctx.unknown[0].replace(/^-+/, "");
          const option = this.getOption(optionName, true);
          if (option?.global) {
            preParseGlobals = true;
            await this.parseGlobalOptionsAndEnvVars(ctx);
          }
        }
      }
      if (subCommand || ctx.unknown.length > 0) {
        subCommand ??= this.getSubCommand(ctx);
        if (subCommand) {
          subCommand._globalParent = this;
          return subCommand.parseCommand(ctx);
        }
      }
      await this.parseOptionsAndEnvVars(ctx, preParseGlobals);
      const options = { ...ctx.env, ...ctx.flags };
      const args = this.parseArguments(ctx, options);
      this.literalArgs = ctx.literal;
      if (ctx.actions.length) {
        await Promise.all(
          ctx.actions.map((action) => action.call(this, options, ...args))
        );
      }
      if (ctx.standalone) {
        return {
          options,
          args,
          cmd: this,
          literal: this.literalArgs
        };
      }
      return await this.execute(options, args);
    } catch (error) {
      this.handleError(error);
    }
  }
  getSubCommand(ctx) {
    const subCommand = this.getCommand(ctx.unknown[0], true);
    if (subCommand) {
      ctx.unknown.shift();
    }
    return subCommand;
  }
  async parseGlobalOptionsAndEnvVars(ctx) {
    const isHelpOption = this.getHelpOption()?.flags.includes(ctx.unknown[0]);
    const envVars = [
      ...this.envVars.filter((envVar) => envVar.global),
      ...this.getGlobalEnvVars(true)
    ];
    await this.parseEnvVars(ctx, envVars, !isHelpOption);
    const options = [
      ...this.options.filter((option) => option.global),
      ...this.getGlobalOptions(true)
    ];
    this.parseOptions(ctx, options, {
      stopEarly: true,
      stopOnUnknown: true,
      dotted: false
    });
  }
  async parseOptionsAndEnvVars(ctx, preParseGlobals) {
    const helpOption = this.getHelpOption();
    const isVersionOption = this._versionOption?.flags.includes(ctx.unknown[0]);
    const isHelpOption = helpOption && ctx.flags?.[helpOption.name] === true;
    const envVars = preParseGlobals ? this.envVars.filter((envVar) => !envVar.global) : this.getEnvVars(true);
    await this.parseEnvVars(
      ctx,
      envVars,
      !isHelpOption && !isVersionOption
    );
    const options = this.getOptions(true);
    this.parseOptions(ctx, options);
  }
  /** Register default options like `--version` and `--help`. */
  registerDefaults() {
    if (this.hasDefaults || this.getParent()) {
      return this;
    }
    this.hasDefaults = true;
    this.reset();
    !this.types.has("string") && this.type("string", new StringType(), { global: true });
    !this.types.has("number") && this.type("number", new NumberType(), { global: true });
    !this.types.has("integer") && this.type("integer", new IntegerType(), { global: true });
    !this.types.has("boolean") && this.type("boolean", new BooleanType(), { global: true });
    !this.types.has("file") && this.type("file", new FileType(), { global: true });
    if (!this._help) {
      this.help({});
    }
    if (this._versionOptions !== false && (this._versionOptions || this.ver)) {
      this.option(
        this._versionOptions?.flags || "-V, --version",
        this._versionOptions?.desc || "Show the version number for this program.",
        {
          standalone: true,
          prepend: true,
          action: async function() {
            const long = this.getRawArgs().includes(
              `--${this._versionOption?.name}`
            );
            if (long) {
              await checkVersion(this);
              this.showLongVersion();
            } else {
              this.showVersion();
            }
            this.exit();
          },
          ...this._versionOptions?.opts ?? {}
        }
      );
      this._versionOption = this.options[0];
    }
    if (this._helpOptions !== false) {
      this.option(
        this._helpOptions?.flags || "-h, --help",
        this._helpOptions?.desc || "Show this help.",
        {
          standalone: true,
          global: true,
          prepend: true,
          action: async function() {
            const long = this.getRawArgs().includes(
              `--${this.getHelpOption()?.name}`
            );
            await checkVersion(this);
            this.showHelp({ long });
            this.exit();
          },
          ...this._helpOptions?.opts ?? {}
        }
      );
      this._helpOption = this.options[0];
    }
    return this;
  }
  /**
   * Execute command.
   * @param options A map of options.
   * @param args Command arguments.
   */
  async execute(options, args) {
    if (this.defaultCommand) {
      const cmd = this.getCommand(this.defaultCommand, true);
      if (!cmd) {
        throw new DefaultCommandNotFoundError(
          this.defaultCommand,
          this.getCommands()
        );
      }
      cmd._globalParent = this;
      return cmd.execute(options, args);
    }
    await this.executeGlobalAction(options, args);
    if (this.actionHandler) {
      await this.actionHandler(options, ...args);
    }
    return {
      options,
      args,
      cmd: this,
      literal: this.literalArgs
    };
  }
  async executeGlobalAction(options, args) {
    if (!this._noGlobals) {
      await this._parent?.executeGlobalAction(options, args);
    }
    await this.globalActionHandler?.(options, ...args);
  }
  /**
   * Execute external sub-command.
   * @param args Raw command line arguments.
   */
  async executeExecutable(args) {
    const command2 = this.getPath().replace(/\s+/g, "-");
    await Deno.permissions.request({ name: "run", command: command2 });
    try {
      const cmd = new Deno.Command(command2, {
        args
      });
      const output2 = await cmd.output();
      if (!output2.success) {
        Deno.exit(output2.code);
      }
    } catch (error) {
      if (error instanceof Deno.errors.NotFound) {
        throw new CommandExecutableNotFoundError(command2);
      }
      throw error;
    }
  }
  /** Parse raw command line arguments. */
  parseOptions(ctx, options, {
    stopEarly = this._stopEarly,
    stopOnUnknown = false,
    dotted = true
  } = {}) {
    parseFlags(ctx, {
      stopEarly,
      stopOnUnknown,
      dotted,
      allowEmpty: this._allowEmpty,
      flags: options,
      ignoreDefaults: ctx.env,
      parse: (type) => this.parseType(type),
      option: (option) => {
        if (option.action) {
          ctx.actions.push(option.action);
        }
      }
    });
  }
  /** Parse argument type. */
  parseType(type) {
    const typeSettings = this.getType(type.type);
    if (!typeSettings) {
      throw new UnknownTypeError(
        type.type,
        this.getTypes().map((type2) => type2.name)
      );
    }
    return typeSettings.handler instanceof Type ? typeSettings.handler.parse(type) : typeSettings.handler(type);
  }
  /**
   * Read and validate environment variables.
   * @param ctx Parse context.
   * @param envVars env vars defined by the command.
   * @param validate when true, throws an error if a required env var is missing.
   */
  async parseEnvVars(ctx, envVars, validate = true) {
    for (const envVar of envVars) {
      const env3 = await this.findEnvVar(envVar.names);
      if (env3) {
        const parseType = (value) => {
          return this.parseType({
            label: "Environment variable",
            type: envVar.type,
            name: env3.name,
            value
          });
        };
        const propertyName = underscoreToCamelCase(
          envVar.prefix ? envVar.names[0].replace(new RegExp(`^${envVar.prefix}`), "") : envVar.names[0]
        );
        if (envVar.details.list) {
          ctx.env[propertyName] = env3.value.split(envVar.details.separator ?? ",").map(parseType);
        } else {
          ctx.env[propertyName] = parseType(env3.value);
        }
        if (envVar.value && typeof ctx.env[propertyName] !== "undefined") {
          ctx.env[propertyName] = envVar.value(ctx.env[propertyName]);
        }
      } else if (envVar.required && validate) {
        throw new MissingRequiredEnvVarError(envVar);
      }
    }
  }
  async findEnvVar(names) {
    for (const name of names) {
      const status = await Deno.permissions.query({
        name: "env",
        variable: name
      });
      if (status.state === "granted") {
        const value = Deno.env.get(name);
        if (value) {
          return { name, value };
        }
      }
    }
    return void 0;
  }
  /**
   * Parse command-line arguments.
   * @param ctx     Parse context.
   * @param options Parsed command line options.
   */
  parseArguments(ctx, options) {
    const params = [];
    const args = ctx.unknown.slice();
    if (!this.hasArguments()) {
      if (args.length) {
        if (this.hasCommands(true)) {
          if (this.hasCommand(args[0], true)) {
            throw new TooManyArgumentsError(args);
          } else {
            throw new UnknownCommandError(args[0], this.getCommands());
          }
        } else {
          throw new NoArgumentsAllowedError(this.getPath());
        }
      }
    } else {
      if (!args.length) {
        const required = this.getArguments().filter((expectedArg) => !expectedArg.optional).map((expectedArg) => expectedArg.name);
        if (required.length) {
          const optionNames = Object.keys(options);
          const hasStandaloneOption = !!optionNames.find(
            (name) => this.getOption(name, true)?.standalone
          );
          if (!hasStandaloneOption) {
            throw new MissingArgumentsError(required);
          }
        }
      } else {
        for (const expectedArg of this.getArguments()) {
          if (!args.length) {
            if (expectedArg.optional) {
              break;
            }
            throw new MissingArgumentError(expectedArg.name);
          }
          let arg;
          const parseArgValue = (value) => {
            return expectedArg.list ? value.split(",").map((value2) => parseArgType(value2)) : parseArgType(value);
          };
          const parseArgType = (value) => {
            return this.parseType({
              label: "Argument",
              type: expectedArg.type,
              name: expectedArg.name,
              value
            });
          };
          if (expectedArg.variadic) {
            arg = args.splice(0, args.length).map(
              (value) => parseArgValue(value)
            );
          } else {
            arg = parseArgValue(args.shift());
          }
          if (expectedArg.variadic && Array.isArray(arg)) {
            params.push(...arg);
          } else if (typeof arg !== "undefined") {
            params.push(arg);
          }
        }
        if (args.length) {
          throw new TooManyArgumentsError(args);
        }
      }
    }
    return params;
  }
  handleError(error) {
    this.throw(
      error instanceof ValidationError ? new ValidationError2(error.message) : error instanceof Error ? error : new Error(`[non-error-thrown] ${error}`)
    );
  }
  /**
   * Handle error. If `throwErrors` is enabled the error will be thrown,
   * otherwise a formatted error message will be printed and `Deno.exit(1)`
   * will be called. This will also trigger registered error handlers.
   *
   * @param error The error to handle.
   */
  throw(error) {
    if (error instanceof ValidationError2) {
      error.cmd = this;
    }
    this.getErrorHandler()?.(error, this);
    if (this.shouldThrowErrors() || !(error instanceof ValidationError2)) {
      throw error;
    }
    this.showHelp();
    console.error(red(`  ${bold("error")}: ${error.message}
`));
    Deno.exit(error instanceof ValidationError2 ? error.exitCode : 1);
  }
  /*****************************************************************************
   **** GETTER *****************************************************************
   *****************************************************************************/
  /** Get command name. */
  getName() {
    return this._name;
  }
  /** Get parent command. */
  getParent() {
    return this._parent;
  }
  /**
   * Get parent command from global executed command.
   * Be sure, to call this method only inside an action handler. Unless this or any child command was executed,
   * this method returns always undefined.
   */
  getGlobalParent() {
    return this._globalParent;
  }
  /** Get main command. */
  getMainCommand() {
    return this._parent?.getMainCommand() ?? this;
  }
  /** Get command name aliases. */
  getAliases() {
    return this.aliases;
  }
  /**
   * Get full command path.
   *
   * @param name Override the main command name.
   */
  getPath(name) {
    return this._parent ? this._parent.getPath(name) + " " + this._name : name || this._name;
  }
  /** Get arguments definition. E.g: <input-file:string> <output-file:string> */
  getArgsDefinition() {
    return this.argsDefinition;
  }
  /**
   * Get argument by name.
   *
   * @param name Name of the argument.
   */
  getArgument(name) {
    return this.getArguments().find((arg) => arg.name === name);
  }
  /** Get arguments. */
  getArguments() {
    if (!this.args.length && this.argsDefinition) {
      this.args = parseArgumentsDefinition(this.argsDefinition);
    }
    return this.args;
  }
  /** Check if command has arguments. */
  hasArguments() {
    return !!this.argsDefinition;
  }
  /** Get command version. */
  getVersion() {
    return this.getVersionHandler()?.call(this, this);
  }
  /** Get help handler method. */
  getVersionHandler() {
    return this.ver ?? this._parent?.getVersionHandler();
  }
  /** Get command description. */
  getDescription() {
    return typeof this.desc === "function" ? this.desc = this.desc() : this.desc;
  }
  /** Get auto generated command usage. */
  getUsage() {
    return this._usage ?? [this.getArgsDefinition(), this.getRequiredOptionsDefinition()].join(" ").trim();
  }
  getRequiredOptionsDefinition() {
    return this.getOptions().filter((option) => option.required).map(
      (option) => [findFlag(option.flags), option.typeDefinition].filter((v) => v).join(" ").trim()
    ).join(" ");
  }
  /** Get short command description. This is the first line of the description. */
  getShortDescription() {
    return getDescription(this.getDescription(), true);
  }
  /** Get original command-line arguments. */
  getRawArgs() {
    return this.rawArgs;
  }
  /** Get all arguments defined after the double dash. */
  getLiteralArgs() {
    return this.literalArgs;
  }
  /** Output generated help without exiting. */
  showVersion() {
    console.log(this.getVersion());
  }
  /** Returns command name, version and meta data. */
  getLongVersion() {
    return `${bold(this.getMainCommand().getName())} ${brightBlue(this.getVersion() ?? "")}` + Object.entries(this.getMeta()).map(
      ([k, v]) => `
${bold(k)} ${brightBlue(v)}`
    ).join("");
  }
  /** Outputs command name, version and meta data. */
  showLongVersion() {
    console.log(this.getLongVersion());
  }
  /** Output generated help without exiting. */
  showHelp(options) {
    console.log(this.getHelp(options));
  }
  /** Get generated help. */
  getHelp(options) {
    this.registerDefaults();
    return this.getHelpHandler().call(this, this, options ?? {});
  }
  /** Get help handler method. */
  getHelpHandler() {
    return this._help ?? this._parent?.getHelpHandler();
  }
  exit(code2 = 0) {
    if (this.shouldExit()) {
      Deno.exit(code2);
    }
  }
  /*****************************************************************************
   **** Options GETTER *********************************************************
   *****************************************************************************/
  /**
   * Checks whether the command has options or not.
   *
   * @param hidden Include hidden options.
   */
  hasOptions(hidden) {
    return this.getOptions(hidden).length > 0;
  }
  /**
   * Get options.
   *
   * @param hidden Include hidden options.
   */
  getOptions(hidden) {
    return this.getGlobalOptions(hidden).concat(this.getBaseOptions(hidden));
  }
  /**
   * Get base options.
   *
   * @param hidden Include hidden options.
   */
  getBaseOptions(hidden) {
    if (!this.options.length) {
      return [];
    }
    return hidden ? this.options.slice(0) : this.options.filter((opt) => !opt.hidden);
  }
  /**
   * Get global options.
   *
   * @param hidden Include hidden options.
   */
  getGlobalOptions(hidden) {
    const helpOption = this.getHelpOption();
    const getGlobals = (cmd, noGlobals, options = [], names = []) => {
      if (cmd.options.length) {
        for (const option of cmd.options) {
          if (option.global && !this.options.find((opt) => opt.name === option.name) && names.indexOf(option.name) === -1 && (hidden || !option.hidden)) {
            if (noGlobals && option !== helpOption) {
              continue;
            }
            names.push(option.name);
            options.push(option);
          }
        }
      }
      return cmd._parent ? getGlobals(
        cmd._parent,
        noGlobals || cmd._noGlobals,
        options,
        names
      ) : options;
    };
    return this._parent ? getGlobals(this._parent, this._noGlobals) : [];
  }
  /**
   * Checks whether the command has an option with given name or not.
   *
   * @param name Name of the option. Must be in param-case.
   * @param hidden Include hidden options.
   */
  hasOption(name, hidden) {
    return !!this.getOption(name, hidden);
  }
  /**
   * Get option by name.
   *
   * @param name Name of the option. Must be in param-case.
   * @param hidden Include hidden options.
   */
  getOption(name, hidden) {
    return this.getBaseOption(name, hidden) ?? this.getGlobalOption(name, hidden);
  }
  /**
   * Get base option by name.
   *
   * @param name Name of the option. Must be in param-case.
   * @param hidden Include hidden options.
   */
  getBaseOption(name, hidden) {
    const option = this.options.find(
      (option2) => option2.name === name || option2.aliases?.includes(name)
    );
    return option && (hidden || !option.hidden) ? option : void 0;
  }
  /**
   * Get global option from parent commands by name.
   *
   * @param name Name of the option. Must be in param-case.
   * @param hidden Include hidden options.
   */
  getGlobalOption(name, hidden) {
    const helpOption = this.getHelpOption();
    const getGlobalOption = (parent, noGlobals) => {
      const option = parent.getBaseOption(
        name,
        hidden
      );
      if (!option?.global) {
        return parent._parent && getGlobalOption(
          parent._parent,
          noGlobals || parent._noGlobals
        );
      }
      if (noGlobals && option !== helpOption) {
        return;
      }
      return option;
    };
    return this._parent && getGlobalOption(
      this._parent,
      this._noGlobals
    );
  }
  /**
   * Remove option by name.
   *
   * @param name Name of the option. Must be in param-case.
   */
  removeOption(name) {
    const index = this.options.findIndex((option) => option.name === name);
    if (index === -1) {
      return;
    }
    return this.options.splice(index, 1)[0];
  }
  /**
   * Checks whether the command has sub-commands or not.
   *
   * @param hidden Include hidden commands.
   */
  hasCommands(hidden) {
    return this.getCommands(hidden).length > 0;
  }
  /**
   * Get commands.
   *
   * @param hidden Include hidden commands.
   */
  getCommands(hidden) {
    return this.getGlobalCommands(hidden).concat(this.getBaseCommands(hidden));
  }
  /**
   * Get base commands.
   *
   * @param hidden Include hidden commands.
   */
  getBaseCommands(hidden) {
    const commands = Array.from(this.commands.values());
    return hidden ? commands : commands.filter((cmd) => !cmd.isHidden);
  }
  /**
   * Get global commands.
   *
   * @param hidden Include hidden commands.
   */
  getGlobalCommands(hidden) {
    const getCommands = (command2, noGlobals, commands = [], names = []) => {
      if (command2.commands.size) {
        for (const [_, cmd] of command2.commands) {
          if (cmd.isGlobal && this !== cmd && !this.commands.has(cmd._name) && names.indexOf(cmd._name) === -1 && (hidden || !cmd.isHidden)) {
            if (noGlobals && cmd?.getName() !== "help") {
              continue;
            }
            names.push(cmd._name);
            commands.push(cmd);
          }
        }
      }
      return command2._parent ? getCommands(
        command2._parent,
        noGlobals || command2._noGlobals,
        commands,
        names
      ) : commands;
    };
    return this._parent ? getCommands(this._parent, this._noGlobals) : [];
  }
  /**
   * Checks whether a child command exists by given name or alias.
   *
   * @param name Name or alias of the command.
   * @param hidden Include hidden commands.
   */
  hasCommand(name, hidden) {
    return !!this.getCommand(name, hidden);
  }
  /**
   * Get command by name or alias.
   *
   * @param name Name or alias of the command.
   * @param hidden Include hidden commands.
   */
  getCommand(name, hidden) {
    return this.getBaseCommand(name, hidden) ?? this.getGlobalCommand(name, hidden);
  }
  /**
   * Get base command by name or alias.
   *
   * @param name Name or alias of the command.
   * @param hidden Include hidden commands.
   */
  getBaseCommand(name, hidden) {
    for (const cmd of this.commands.values()) {
      if (cmd._name === name || cmd.aliases.includes(name)) {
        return cmd && (hidden || !cmd.isHidden) ? cmd : void 0;
      }
    }
  }
  /**
   * Get global command by name or alias.
   *
   * @param name Name or alias of the command.
   * @param hidden Include hidden commands.
   */
  getGlobalCommand(name, hidden) {
    const getGlobalCommand = (parent, noGlobals) => {
      const cmd = parent.getBaseCommand(name, hidden);
      if (!cmd?.isGlobal) {
        return parent._parent && getGlobalCommand(parent._parent, noGlobals || parent._noGlobals);
      }
      if (noGlobals && cmd.getName() !== "help") {
        return;
      }
      return cmd;
    };
    return this._parent && getGlobalCommand(this._parent, this._noGlobals);
  }
  /**
   * Remove sub-command by name or alias.
   *
   * @param name Name or alias of the command.
   */
  removeCommand(name) {
    const command2 = this.getBaseCommand(name, true);
    if (command2) {
      this.commands.delete(command2._name);
    }
    return command2;
  }
  /** Get types. */
  getTypes() {
    return this.getGlobalTypes().concat(this.getBaseTypes());
  }
  /** Get base types. */
  getBaseTypes() {
    return Array.from(this.types.values());
  }
  /** Get global types. */
  getGlobalTypes() {
    const getTypes = (cmd, types = [], names = []) => {
      if (cmd) {
        if (cmd.types.size) {
          cmd.types.forEach((type) => {
            if (type.global && !this.types.has(type.name) && names.indexOf(type.name) === -1) {
              names.push(type.name);
              types.push(type);
            }
          });
        }
        return getTypes(cmd._parent, types, names);
      }
      return types;
    };
    return getTypes(this._parent);
  }
  /**
   * Get type by name.
   *
   * @param name Name of the type.
   */
  getType(name) {
    return this.getBaseType(name) ?? this.getGlobalType(name);
  }
  /**
   * Get base type by name.
   *
   * @param name Name of the type.
   */
  getBaseType(name) {
    return this.types.get(name);
  }
  /**
   * Get global type by name.
   *
   * @param name Name of the type.
   */
  getGlobalType(name) {
    if (!this._parent) {
      return;
    }
    const cmd = this._parent.getBaseType(name);
    if (!cmd?.global) {
      return this._parent.getGlobalType(name);
    }
    return cmd;
  }
  /** Get completions. */
  getCompletions() {
    return this.getGlobalCompletions().concat(this.getBaseCompletions());
  }
  /** Get base completions. */
  getBaseCompletions() {
    return Array.from(this.completions.values());
  }
  /** Get global completions. */
  getGlobalCompletions() {
    const getCompletions = (cmd, completions = [], names = []) => {
      if (cmd) {
        if (cmd.completions.size) {
          cmd.completions.forEach((completion) => {
            if (completion.global && !this.completions.has(completion.name) && names.indexOf(completion.name) === -1) {
              names.push(completion.name);
              completions.push(completion);
            }
          });
        }
        return getCompletions(cmd._parent, completions, names);
      }
      return completions;
    };
    return getCompletions(this._parent);
  }
  /**
   * Get completion by name.
   *
   * @param name Name of the completion.
   */
  getCompletion(name) {
    return this.getBaseCompletion(name) ?? this.getGlobalCompletion(name);
  }
  /**
   * Get base completion by name.
   *
   * @param name Name of the completion.
   */
  getBaseCompletion(name) {
    return this.completions.get(name);
  }
  /**
   * Get global completions by name.
   *
   * @param name Name of the completion.
   */
  getGlobalCompletion(name) {
    if (!this._parent) {
      return;
    }
    const completion = this._parent.getBaseCompletion(
      name
    );
    if (!completion?.global) {
      return this._parent.getGlobalCompletion(name);
    }
    return completion;
  }
  /**
   * Checks whether the command has environment variables or not.
   *
   * @param hidden Include hidden environment variable.
   */
  hasEnvVars(hidden) {
    return this.getEnvVars(hidden).length > 0;
  }
  /**
   * Get environment variables.
   *
   * @param hidden Include hidden environment variable.
   */
  getEnvVars(hidden) {
    return this.getGlobalEnvVars(hidden).concat(this.getBaseEnvVars(hidden));
  }
  /**
   * Get base environment variables.
   *
   * @param hidden Include hidden environment variable.
   */
  getBaseEnvVars(hidden) {
    if (!this.envVars.length) {
      return [];
    }
    return hidden ? this.envVars.slice(0) : this.envVars.filter((env3) => !env3.hidden);
  }
  /**
   * Get global environment variables.
   *
   * @param hidden Include hidden environment variable.
   */
  getGlobalEnvVars(hidden) {
    if (this._noGlobals) {
      return [];
    }
    const getEnvVars = (cmd, envVars = [], names = []) => {
      if (cmd) {
        if (cmd.envVars.length) {
          cmd.envVars.forEach((envVar) => {
            if (envVar.global && !this.envVars.find((env3) => env3.names[0] === envVar.names[0]) && names.indexOf(envVar.names[0]) === -1 && (hidden || !envVar.hidden)) {
              names.push(envVar.names[0]);
              envVars.push(envVar);
            }
          });
        }
        return getEnvVars(cmd._parent, envVars, names);
      }
      return envVars;
    };
    return getEnvVars(this._parent);
  }
  /**
   * Checks whether the command has an environment variable with given name or not.
   *
   * @param name Name of the environment variable.
   * @param hidden Include hidden environment variable.
   */
  hasEnvVar(name, hidden) {
    return !!this.getEnvVar(name, hidden);
  }
  /**
   * Get environment variable by name.
   *
   * @param name Name of the environment variable.
   * @param hidden Include hidden environment variable.
   */
  getEnvVar(name, hidden) {
    return this.getBaseEnvVar(name, hidden) ?? this.getGlobalEnvVar(name, hidden);
  }
  /**
   * Get base environment variable by name.
   *
   * @param name Name of the environment variable.
   * @param hidden Include hidden environment variable.
   */
  getBaseEnvVar(name, hidden) {
    const envVar = this.envVars.find(
      (env3) => env3.names.indexOf(name) !== -1
    );
    return envVar && (hidden || !envVar.hidden) ? envVar : void 0;
  }
  /**
   * Get global environment variable by name.
   *
   * @param name Name of the environment variable.
   * @param hidden Include hidden environment variable.
   */
  getGlobalEnvVar(name, hidden) {
    if (!this._parent || this._noGlobals) {
      return;
    }
    const envVar = this._parent.getBaseEnvVar(
      name,
      hidden
    );
    if (!envVar?.global) {
      return this._parent.getGlobalEnvVar(name, hidden);
    }
    return envVar;
  }
  /** Checks whether the command has examples or not. */
  hasExamples() {
    return this.examples.length > 0;
  }
  /** Get all examples. */
  getExamples() {
    return this.examples;
  }
  /** Checks whether the command has an example with given name or not. */
  hasExample(name) {
    return !!this.getExample(name);
  }
  /** Get example with given name. */
  getExample(name) {
    return this.examples.find((example) => example.name === name);
  }
  getHelpOption() {
    return this._helpOption ?? this._parent?.getHelpOption();
  }
};
function findFlag(flags) {
  for (const flag of flags) {
    if (flag.startsWith("--")) {
      return flag;
    }
  }
  return flags[0];
}

// https://deno.land/x/good@1.5.1.0/value.js
var typedArrayClasses = [
  Uint16Array,
  Uint32Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Int32Array,
  Int8Array,
  Float32Array,
  Float64Array,
  globalThis.BigInt64Array,
  globalThis.BigUint64Array
].filter((each2) => each2);
var copyableClasses = /* @__PURE__ */ new Set([RegExp, Date, URL, ...typedArrayClasses, globalThis.ArrayBuffer, globalThis.DataView]);
var IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
var ArrayIterator = Object.getPrototypeOf([][Symbol.iterator]);
var MapIterator = Object.getPrototypeOf((/* @__PURE__ */ new Map())[Symbol.iterator]);
var SetIterator = Object.getPrototypeOf((/* @__PURE__ */ new Set())[Symbol.iterator]);
var AsyncFunction = class {
};
var GeneratorFunction = class {
};
var AsyncGeneratorFunction = class {
};
var SyncGenerator = class {
};
var AsyncGenerator = class {
};
try {
  AsyncFunction = eval("(async function(){}).constructor");
  GeneratorFunction = eval("(function*(){}).constructor");
  AsyncGeneratorFunction = eval("(async function*(){}).constructor");
  SyncGenerator = eval("((function*(){})()).constructor");
  AsyncGenerator = eval("((async function*(){})()).constructor");
} catch (error) {
}
var isPrimitive = (value) => !(value instanceof Object);
var isPureObject = (value) => value instanceof Object && Object.getPrototypeOf(value).constructor == Object;
var isPracticallyPrimitive = (value) => isPrimitive(value) || value instanceof Date || value instanceof RegExp || value instanceof URL;
var isBuiltInIterator = (value) => IteratorPrototype.isPrototypeOf(value);
var isGeneratorType = (value) => {
  if (value instanceof Object) {
    if (isBuiltInIterator(value)) {
      return true;
    }
    const constructor = value.constructor;
    return constructor == SyncGenerator || constructor == AsyncGenerator;
  }
  return false;
};
var isAsyncIterable = function(value) {
  return value && typeof value[Symbol.asyncIterator] === "function";
};
var isSyncIterable = function(value) {
  return value && typeof value[Symbol.iterator] === "function";
};
var isIterableObjectOrContainer = function(value) {
  return value instanceof Object && (typeof value[Symbol.iterator] == "function" || typeof value[Symbol.asyncIterator] === "function");
};
var isTechnicallyIterable = function(value) {
  return value instanceof Object || typeof value == "string";
};
var isSyncIterableObjectOrContainer = function(value) {
  return value instanceof Object && typeof value[Symbol.iterator] == "function";
};
var deepCopySymbol = Symbol.for("deepCopy");
var clonedFromSymbol = Symbol();
var getThis = Symbol();
Object.getPrototypeOf(function() {
})[getThis] = function() {
  return this;
};
function deepCopyInner(value, valueChain = [], originalToCopyMap = /* @__PURE__ */ new Map()) {
  valueChain.push(value);
  if (value == null) {
    return value;
  }
  if (!(value instanceof Object)) {
    return value;
  }
  if (originalToCopyMap.has(value)) {
    return originalToCopyMap.get(value);
  }
  if (value[deepCopySymbol] instanceof Function) {
    const clonedValue = value[deepCopySymbol](originalToCopyMap);
    originalToCopyMap.set(value, clonedValue);
    return clonedValue;
  }
  if (isGeneratorType(value)) {
    throw Error(`Sadly built-in generators cannot be deep copied.
And I found a generator along this path:
${valueChain.reverse().map((each2) => `${each2},
`)}`);
  }
  let object, theThis, thisCopy;
  if (value instanceof Date) {
    object = new Date(value.getTime());
  } else if (value instanceof RegExp) {
    object = new RegExp(value);
  } else if (value instanceof URL) {
    object = new URL(value);
  } else if (value instanceof Function) {
    theThis = value[getThis]();
    object = value.bind(theThis);
  } else if (copyableClasses.has(value.constructor)) {
    object = new value.constructor(value);
  } else if (value instanceof Array) {
    object = [];
  } else if (value instanceof Set) {
    object = /* @__PURE__ */ new Set();
  } else if (value instanceof Map) {
    object = /* @__PURE__ */ new Map();
  }
  originalToCopyMap.set(value, object);
  if (object instanceof Function) {
    thisCopy = deepCopyInner(theThis, valueChain, originalToCopyMap);
    object = object.bind(thisCopy);
  }
  const output2 = object;
  try {
    output2.constructor = value.constructor;
  } catch (error) {
  }
  Object.setPrototypeOf(output2, Object.getPrototypeOf(value));
  const propertyDefinitions = {};
  for (const [key, description] of Object.entries(Object.getOwnPropertyDescriptors(value))) {
    const { value: value2, get, set: set2, ...options } = description;
    const getIsFunc = get instanceof Function;
    const setIsFunc = set2 instanceof Function;
    if (getIsFunc || setIsFunc) {
      propertyDefinitions[key] = {
        ...options,
        get: get ? function(...args) {
          return get.apply(output2, args);
        } : void 0,
        set: set2 ? function(...args) {
          return set2.apply(output2, args);
        } : void 0
      };
    } else {
      if (key == "length" && output2 instanceof Array) {
        continue;
      }
      propertyDefinitions[key] = {
        ...options,
        value: deepCopyInner(value2, valueChain, originalToCopyMap)
      };
    }
  }
  Object.defineProperties(output2, propertyDefinitions);
  return output2;
}
var deepCopy = (value) => deepCopyInner(value);
var shallowSortObject = (obj) => {
  return Object.keys(obj).sort().reduce(
    (newObj, key) => {
      newObj[key] = obj[key];
      return newObj;
    },
    {}
  );
};
var deepSortObject = (obj, seen = /* @__PURE__ */ new Map()) => {
  if (!(obj instanceof Object)) {
    return obj;
  } else if (seen.has(obj)) {
    return seen.get(obj);
  } else {
    if (obj instanceof Array) {
      const sortedChildren = [];
      seen.set(obj, sortedChildren);
      for (const each2 of obj) {
        sortedChildren.push(deepSortObject(each2, seen));
      }
      return sortedChildren;
    } else {
      const sorted = {};
      seen.set(obj, sorted);
      for (const eachKey of Object.keys(obj).sort()) {
        sorted[eachKey] = deepSortObject(obj[eachKey], seen);
      }
      return sorted;
    }
  }
};
var stableStringify = (value, ...args) => {
  return JSON.stringify(deepSortObject(value), ...args);
};
var allKeys = function(obj) {
  let keys = [];
  if (obj == null) {
    return [];
  }
  if (!(obj instanceof Object)) {
    obj = Object.getPrototypeOf(obj);
  }
  while (obj) {
    keys = keys.concat(Reflect.ownKeys(obj));
    obj = Object.getPrototypeOf(obj);
  }
  return keys;
};
var ownKeyDescriptions = Object.getOwnPropertyDescriptors;
var allKeyDescriptions = function(value, options = { includingBuiltin: false }) {
  var { includingBuiltin } = { ...options };
  let descriptions = [];
  if (value == null) {
    return {};
  }
  if (!(value instanceof Object)) {
    value = Object.getPrototypeOf(value);
  }
  const rootPrototype = Object.getPrototypeOf({});
  let prevObj;
  while (value && value != prevObj) {
    if (!includingBuiltin && value == rootPrototype) {
      break;
    }
    descriptions = descriptions.concat(Object.entries(Object.getOwnPropertyDescriptors(value)));
    prevObj = value;
    value = Object.getPrototypeOf(value);
  }
  descriptions.reverse();
  return Object.fromEntries(descriptions);
};

// https://deno.land/x/good@1.5.1.0/async.js
function deferredPromise() {
  let methods;
  let state = "pending";
  const promise = new Promise((resolve15, reject) => {
    methods = {
      async resolve(value) {
        await value;
        state = "fulfilled";
        resolve15(value);
      },
      reject(reason) {
        state = "rejected";
        reject(reason);
      }
    };
  });
  Object.defineProperty(promise, "state", {
    get: () => state
  });
  return Object.assign(promise, methods);
}
var objectPrototype = Object.getPrototypeOf({});

// https://deno.land/x/good@1.5.1.0/iterable.js
var emptyIterator = /* @__PURE__ */ function* () {
}();
var makeIterable = (object) => {
  if (object == null) {
    return emptyIterator;
  }
  if (object[Symbol.iterator] instanceof Function || object[Symbol.asyncIterator] instanceof Function) {
    return object;
  }
  if (Object.getPrototypeOf(object).constructor == Object) {
    return Object.entries(object);
  }
  return emptyIterator;
};
var Stop = Symbol("iterationStop");
var iter = (object) => {
  const iterable = makeIterable(object);
  if (iterable[Symbol.asyncIterator]) {
    return iterable[Symbol.asyncIterator]();
  } else {
    return iterable[Symbol.iterator]();
  }
};
async function asyncIteratorToList(asyncIterator) {
  const results = [];
  for await (const each2 of asyncIterator) {
    results.push(each2);
  }
  return results;
}
var zip = function* (...iterables) {
  iterables = iterables.map((each2) => iter(each2));
  while (true) {
    const nexts = iterables.map((each2) => each2.next());
    if (nexts.every((each2) => each2.done)) {
      break;
    }
    yield nexts.map((each2) => each2.value);
  }
};
var ERROR_WHILE_MAPPING_MESSAGE = "Threw while mapping.";
function concurrentlyTransform({ iterator, transformFunction, poolLimit = null, awaitAll = false }) {
  poolLimit = poolLimit || concurrentlyTransform.defaultPoolLimit;
  const res = new TransformStream({
    async transform(p, controller) {
      try {
        const s = await p;
        controller.enqueue(s);
      } catch (e) {
        if (e instanceof AggregateError && e.message == ERROR_WHILE_MAPPING_MESSAGE) {
          controller.error(e);
        }
      }
    }
  });
  const mainPromise = (async () => {
    const writer = res.writable.getWriter();
    const executing = [];
    try {
      let index = 0;
      for await (const item of iterator) {
        const p = Promise.resolve().then(() => transformFunction(item, index));
        index++;
        writer.write(p);
        const e = p.then(() => executing.splice(executing.indexOf(e), 1));
        executing.push(e);
        if (executing.length >= poolLimit) {
          await Promise.race(executing);
        }
      }
      await Promise.all(executing);
      writer.close();
    } catch {
      const errors = [];
      for (const result2 of await Promise.allSettled(executing)) {
        if (result2.status == "rejected") {
          errors.push(result2.reason);
        }
      }
      writer.write(Promise.reject(
        new AggregateError(errors, ERROR_WHILE_MAPPING_MESSAGE)
      )).catch(() => {
      });
    }
  })();
  const asyncIterator = res.readable[Symbol.asyncIterator]();
  if (!awaitAll) {
    return asyncIterator;
  } else {
    return mainPromise.then(() => asyncIteratorToList(asyncIterator));
  }
}
concurrentlyTransform.defaultPoolLimit = 40;

// https://deno.land/x/good@1.5.1.0/array.js
var zip2 = function(...iterables) {
  return [...zip(...iterables)];
};
var NamedArray = class extends Array {
  toJSON() {
    return { ...this };
  }
  toString() {
    return { ...this };
  }
  [Symbol.for("customInspect")]() {
    return { ...this };
  }
  [Symbol.for("Deno.customInspect")]() {
    return { ...this };
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return { ...this };
  }
};

// https://deno.land/x/quickr@0.6.56/main/operating_system.js
var cache2 = {};
var stdoutRun = async (args) => {
  const process = Deno.run({ cmd: args, stdout: "piped", stderr: "piped" });
  const output2 = await process.output();
  return new TextDecoder().decode(output2).replace(/\n$/, "");
};
var OperatingSystem = {
  commonChecks: {
    isMac: Deno.build.os == "darwin",
    isWindows: Deno.build.os == "windows",
    isLinux: Deno.build.os == "linux",
    get isWsl() {
      if (cache2.isWsl != null) {
        return cache2.isWsl;
      }
      if (!(OperatingSystem.commonChecks.isMac || OperatingSystem.commonChecks.isWindows)) {
        if (Deno.env.get("WSLENV")) {
          return cache2.isWsl = true;
        }
        try {
          const { isFile } = Deno.lstatSync("/mnt/c");
          return cache2.isWsl = true;
        } catch (error) {
        }
      }
      return cache2.isWsl = false;
    }
  },
  commonName: {
    "darwin": "MacOS",
    "windows": "Windows",
    "linux": "Linux"
  }[Deno.build.os],
  kernel: {
    commonName: Deno.build.os
  },
  architecture: Deno.build.architecture,
  get versionArray() {
    return new Promise(async (resolve15, reject) => {
      let versionArray = [];
      if (OperatingSystem.commonChecks.isWindows) {
        try {
          const windowsVersionString = await stdoutRun(["pwsh", "-Command", `[System.Environment]::OSVersion.Version`]);
          versionArray = windowsVersionString.replace(/^[\w\W]*?(\d+\.\d+\.\d+)[\w\W]*/, "$1").split(".").map((each2) => each2 - 0);
        } catch (error) {
          console.warn(`unable to get version string for Windows: ${error.message}`);
        }
      } else if (OperatingSystem.commonChecks.isMac) {
        try {
          const macVersionString = await stdoutRun(["/usr/bin/sw_vers", "-productVersion"]);
          versionArray = macVersionString.replace(/^[\w\W]*?(\d+\.\d+(\.\d+)?)[\w\W]*/, "$1").split(".").map((each2) => each2 - 0);
        } catch (error) {
          console.warn(`unable to get version string for MacOS: ${error.message}`);
        }
      } else {
        try {
          const outputString = await stdoutRun(["uname", "-r"]);
          versionArray = outputString.replace(/^[\w\W]*?((\d+\.)+\d+)[\w\W]*/, "$1").split(".").map((each2) => each2 - 0);
        } catch (error) {
          console.warn(`unable to get version string for Linux: ${error.message}`);
        }
      }
    });
  },
  get username() {
    if (!cache2.username) {
      if (Deno.build.os != "windows") {
        cache2.username = Deno.env.get("USER");
      } else {
        cache2.username = Deno.env.get("USERNAME");
      }
    }
    return cache2.username;
  },
  get home() {
    if (!cache2.home) {
      if (Deno.build.os != "windows") {
        cache2.home = Deno.env.get("HOME");
      } else {
        cache2.home = Deno.env.get("HOMEPATH");
      }
    }
    return cache2.home;
  },
  async idForUsername(username) {
    if (OperatingSystem.commonChecks.isMac) {
      if (!cache2.macOsUserToUid) {
        const userListString = await stdoutRun(["dscl", ".", "-list", "/Users", "UniqueID"]);
        const userList = userListString.split(/\n/);
        const userNamesAndIds = userList.map((each2) => {
          const match = each2.match(/(.+?)(-?\d+)$/, "$1");
          if (match) {
            const username2 = match[1].trim();
            const uid = match[2];
            return [username2, uid];
          }
        }).filter((each2) => each2);
        const idsAndUsernames = userNamesAndIds.map(([username2, id]) => [id, username2]);
        cache2.macOsUserToUid = Object.fromEntries(userNamesAndIds);
        cache2.macOsUidToUser = Object.fromEntries(idsAndUsernames);
      }
      return cache2.macOsUserToUid[username];
    } else if (OperatingSystem.commonChecks.isWindows) {
      return await stdoutRun(["pwsh", "-Command", `Get-ADUser -Identity '${username.replace(/'/, "''")}' | select SID`]);
    } else if (OperatingSystem.commonChecks.isLinux) {
      return await stdoutRun(["id", "-u", OperatingSystem.username]);
    }
  }
};

// https://deno.land/x/good@1.3.0.4/value.js
var typedArrayClasses2 = [
  Uint16Array,
  Uint32Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Int32Array,
  Int8Array,
  Float32Array,
  Float64Array,
  globalThis.BigInt64Array,
  globalThis.BigUint64Array
].filter((each2) => each2);
var copyableClasses2 = /* @__PURE__ */ new Set([RegExp, Date, URL, ...typedArrayClasses2, globalThis.ArrayBuffer, globalThis.DataView]);
var IteratorPrototype2 = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
var ArrayIterator2 = Object.getPrototypeOf([][Symbol.iterator]);
var MapIterator2 = Object.getPrototypeOf((/* @__PURE__ */ new Map())[Symbol.iterator]);
var SetIterator2 = Object.getPrototypeOf((/* @__PURE__ */ new Set())[Symbol.iterator]);
var AsyncFunction2 = class {
};
var GeneratorFunction2 = class {
};
var AsyncGeneratorFunction2 = class {
};
var SyncGenerator2 = class {
};
var AsyncGenerator2 = class {
};
try {
  AsyncFunction2 = eval("(async function(){}).constructor");
  GeneratorFunction2 = eval("(function*(){}).constructor");
  AsyncGeneratorFunction2 = eval("(async function*(){}).constructor");
  SyncGenerator2 = eval("((function*(){})()).constructor");
  AsyncGenerator2 = eval("((async function*(){})()).constructor");
} catch (error) {
}
var isPrimitive2 = (value) => !(value instanceof Object);
var isPureObject2 = (value) => value instanceof Object && Object.getPrototypeOf(value).constructor == Object;
var isPracticallyPrimitive2 = (value) => isPrimitive2(value) || value instanceof Date || value instanceof RegExp || value instanceof URL;
var isBuiltInIterator2 = (value) => IteratorPrototype2.isPrototypeOf(value);
var isGeneratorType2 = (value) => {
  if (value instanceof Object) {
    if (isBuiltInIterator2(value)) {
      return true;
    }
    const constructor = value.constructor;
    return constructor == SyncGenerator2 || constructor == AsyncGenerator2;
  }
  return false;
};
var isAsyncIterable2 = function(value) {
  return value && typeof value[Symbol.asyncIterator] === "function";
};
var isSyncIterable2 = function(value) {
  return value && typeof value[Symbol.iterator] === "function";
};
var isTechnicallyIterable2 = function(value) {
  return value instanceof Object || typeof value == "string";
};
var isSyncIterableObjectOrContainer2 = function(value) {
  return value instanceof Object && typeof value[Symbol.iterator] == "function";
};
var deepCopySymbol2 = Symbol.for("deepCopy");
var clonedFromSymbol2 = Symbol();
var getThis2 = Symbol();
Object.getPrototypeOf(function() {
})[getThis2] = function() {
  return this;
};
function deepCopyInner2(value, valueChain = [], originalToCopyMap = /* @__PURE__ */ new Map()) {
  valueChain.push(value);
  if (value == null) {
    return value;
  }
  if (!(value instanceof Object)) {
    return value;
  }
  if (originalToCopyMap.has(value)) {
    return originalToCopyMap.get(value);
  }
  if (value[deepCopySymbol2] instanceof Function) {
    const clonedValue = value[deepCopySymbol2](originalToCopyMap);
    originalToCopyMap.set(value, clonedValue);
    return clonedValue;
  }
  if (isGeneratorType2(value)) {
    throw Error(`Sadly built-in generators cannot be deep copied.
And I found a generator along this path:
${valueChain.reverse().map((each2) => `${each2},
`)}`);
  }
  let object, theThis, thisCopy;
  if (value instanceof Date) {
    object = new Date(value.getTime());
  } else if (value instanceof RegExp) {
    object = new RegExp(value);
  } else if (value instanceof URL) {
    object = new URL(value);
  } else if (value instanceof Function) {
    theThis = value[getThis2]();
    object = value.bind(theThis);
  } else if (copyableClasses2.has(value.constructor)) {
    object = new value.constructor(value);
  } else if (value instanceof Array) {
    object = [];
  } else if (value instanceof Set) {
    object = /* @__PURE__ */ new Set();
  } else if (value instanceof Map) {
    object = /* @__PURE__ */ new Map();
  }
  originalToCopyMap.set(value, object);
  if (object instanceof Function) {
    thisCopy = deepCopyInner2(theThis, valueChain, originalToCopyMap);
    object = object.bind(thisCopy);
  }
  const output2 = object;
  try {
    output2.constructor = value.constructor;
  } catch (error) {
  }
  Object.setPrototypeOf(output2, Object.getPrototypeOf(value));
  const propertyDefinitions = {};
  for (const [key, description] of Object.entries(Object.getOwnPropertyDescriptors(value))) {
    const { value: value2, get, set: set2, ...options } = description;
    const getIsFunc = get instanceof Function;
    const setIsFunc = set2 instanceof Function;
    if (getIsFunc || setIsFunc) {
      propertyDefinitions[key] = {
        ...options,
        get: get ? function(...args) {
          return get.apply(output2, args);
        } : void 0,
        set: set2 ? function(...args) {
          return set2.apply(output2, args);
        } : void 0
      };
    } else {
      if (key == "length" && output2 instanceof Array) {
        continue;
      }
      propertyDefinitions[key] = {
        ...options,
        value: deepCopyInner2(value2, valueChain, originalToCopyMap)
      };
    }
  }
  Object.defineProperties(output2, propertyDefinitions);
  return output2;
}
var deepCopy2 = (value) => deepCopyInner2(value);
var shallowSortObject2 = (obj) => {
  return Object.keys(obj).sort().reduce(
    (newObj, key) => {
      newObj[key] = obj[key];
      return newObj;
    },
    {}
  );
};
var deepSortObject2 = (obj, seen = /* @__PURE__ */ new Map()) => {
  if (!(obj instanceof Object)) {
    return obj;
  } else if (seen.has(obj)) {
    return seen.get(obj);
  } else {
    if (obj instanceof Array) {
      const sortedChildren = [];
      seen.set(obj, sortedChildren);
      for (const each2 of obj) {
        sortedChildren.push(deepSortObject2(each2, seen));
      }
      return sortedChildren;
    } else {
      const sorted = {};
      seen.set(obj, sorted);
      for (const eachKey of Object.keys(obj).sort()) {
        sorted[eachKey] = deepSortObject2(obj[eachKey], seen);
      }
      return sorted;
    }
  }
};
var stableStringify2 = (value, ...args) => {
  return JSON.stringify(deepSortObject2(value), ...args);
};
var allKeys2 = function(obj) {
  let keys = [];
  if (obj == null) {
    return [];
  }
  if (!(obj instanceof Object)) {
    obj = Object.getPrototypeOf(obj);
  }
  while (obj) {
    keys = keys.concat(Reflect.ownKeys(obj));
    obj = Object.getPrototypeOf(obj);
  }
  return keys;
};
var ownKeyDescriptions2 = Object.getOwnPropertyDescriptors;
var allKeyDescriptions2 = function(value, options = { includingBuiltin: false }) {
  var { includingBuiltin } = { ...options };
  let descriptions = [];
  if (value == null) {
    return {};
  }
  if (!(value instanceof Object)) {
    value = Object.getPrototypeOf(value);
  }
  const rootPrototype = Object.getPrototypeOf({});
  let prevObj;
  while (value && value != prevObj) {
    if (!includingBuiltin && value == rootPrototype) {
      break;
    }
    descriptions = descriptions.concat(Object.entries(Object.getOwnPropertyDescriptors(value)));
    prevObj = value;
    value = Object.getPrototypeOf(value);
  }
  descriptions.reverse();
  return Object.fromEntries(descriptions);
};

// https://deno.land/x/good@1.3.0.4/iterable.js
var emptyIterator2 = /* @__PURE__ */ function* () {
}();
var makeIterable2 = (object) => {
  if (object == null) {
    return emptyIterator2;
  }
  if (object[Symbol.iterator] instanceof Function || object[Symbol.asyncIterator] instanceof Function) {
    return object;
  }
  if (Object.getPrototypeOf(object).constructor == Object) {
    return Object.entries(object);
  }
  return emptyIterator2;
};
var iter2 = (object) => {
  const iterable = makeIterable2(object);
  if (iterable[Symbol.asyncIterator]) {
    return iterable[Symbol.asyncIterator]();
  } else {
    return iterable[Symbol.iterator]();
  }
};
var Stop2 = Symbol("iterationStop");
var zip3 = function* (...iterables) {
  iterables = iterables.map((each2) => iter2(each2));
  while (true) {
    const nexts = iterables.map((each2) => each2.next());
    if (nexts.every((each2) => each2.done)) {
      break;
    }
    yield nexts.map((each2) => each2.value);
  }
};
async function asyncIteratorToList2(asyncIterator) {
  const results = [];
  for await (const each2 of asyncIterator) {
    results.push(each2);
  }
  return results;
}
var ERROR_WHILE_MAPPING_MESSAGE2 = "Threw while mapping.";
function concurrentlyTransform2({ iterator, transformFunction, poolLimit = null, awaitAll = false }) {
  poolLimit = poolLimit || concurrentlyTransform2.defaultPoolLimit;
  const res = new TransformStream({
    async transform(p, controller) {
      try {
        const s = await p;
        controller.enqueue(s);
      } catch (e) {
        if (e instanceof AggregateError && e.message == ERROR_WHILE_MAPPING_MESSAGE2) {
          controller.error(e);
        }
      }
    }
  });
  const mainPromise = (async () => {
    const writer = res.writable.getWriter();
    const executing = [];
    try {
      let index = 0;
      for await (const item of iterator) {
        const p = Promise.resolve().then(() => transformFunction(item, index));
        index++;
        writer.write(p);
        const e = p.then(() => executing.splice(executing.indexOf(e), 1));
        executing.push(e);
        if (executing.length >= poolLimit) {
          await Promise.race(executing);
        }
      }
      await Promise.all(executing);
      writer.close();
    } catch {
      const errors = [];
      for (const result2 of await Promise.allSettled(executing)) {
        if (result2.status == "rejected") {
          errors.push(result2.reason);
        }
      }
      writer.write(Promise.reject(
        new AggregateError(errors, ERROR_WHILE_MAPPING_MESSAGE2)
      )).catch(() => {
      });
    }
  })();
  const asyncIterator = res.readable[Symbol.asyncIterator]();
  if (!awaitAll) {
    return asyncIterator;
  } else {
    return mainPromise.then(() => asyncIteratorToList2(asyncIterator));
  }
}
concurrentlyTransform2.defaultPoolLimit = 40;

// https://deno.land/x/good@1.3.0.4/string.js
var indent2 = ({ string: string2, by = "    ", noLead = false }) => (noLead ? "" : by) + string2.replace(/\n/g, "\n" + by);
var toString = (value) => {
  if (typeof value == "symbol") {
    return toRepresentation(value);
  } else if (!(value instanceof Object)) {
    return value != null ? value.toString() : `${value}`;
  } else {
    return toRepresentation(value);
  }
};
var reprSymbol = Symbol.for("representation");
var denoInspectSymbol = Symbol.for("Deno.customInspect");
var toRepresentation = (item) => {
  const alreadySeen = /* @__PURE__ */ new Set();
  const recursionWrapper = (item2) => {
    if (item2 instanceof Object) {
      if (alreadySeen.has(item2)) {
        return `[Self Reference]`;
      } else {
        alreadySeen.add(item2);
      }
    }
    let output2;
    if (item2 === void 0) {
      output2 = "undefined";
    } else if (item2 === null) {
      output2 = "null";
    } else if (typeof item2 == "string") {
      output2 = JSON.stringify(item2);
    } else if (typeof item2 == "symbol") {
      if (!item2.description) {
        output2 = "Symbol()";
      } else {
        const globalVersion = Symbol.for(item2.description);
        if (globalVersion == item2) {
          output2 = `Symbol.for(${JSON.stringify(item2.description)})`;
        } else {
          output2 = `Symbol(${JSON.stringify(item2.description)})`;
        }
      }
    } else if (item2 instanceof Date) {
      output2 = `new Date(${item2.getTime()})`;
    } else if (item2 instanceof Array) {
      output2 = `[${item2.map((each2) => recursionWrapper(each2)).join(",")}]`;
    } else if (item2 instanceof Set) {
      output2 = `new Set(${[...item2].map((each2) => recursionWrapper(each2)).join(",")})`;
    } else if (item2 instanceof Object && item2.constructor == Object) {
      output2 = pureObjectRepr(item2);
    } else if (item2 instanceof Map) {
      let string2 = "new Map(";
      for (const [key, value] of item2.entries()) {
        const stringKey = recursionWrapper(key);
        const stringValue = recursionWrapper(value);
        if (!stringKey.match(/\n/g)) {
          string2 += `
  [${stringKey}, ${indent2({ string: stringValue, by: "  ", noLead: true })}],`;
        } else {
          string2 += `
  [${indent2({ string: stringKey, by: "  ", noLead: true })},
  ${indent2({ string: stringValue, by: "    ", noLead: true })}],`;
        }
      }
      string2 += "\n)";
      output2 = string2;
    } else {
      if (item2[reprSymbol] instanceof Function) {
        try {
          output2 = item2[reprSymbol]();
          return output2;
        } catch (error) {
        }
      }
      if (item2[denoInspectSymbol] instanceof Function) {
        try {
          output2 = item2[denoInspectSymbol]();
          return output2;
        } catch (error) {
        }
      }
      try {
        output2 = item2.toString();
        if (output2 !== "[object Object]") {
          return output2;
        }
      } catch (error) {
      }
      try {
        if (item2.constructor instanceof Function && item2.prototype && typeof item2.name == "string") {
          output2 = `class ${item2.name} { /*...*/ }`;
          return output2;
        }
      } catch (error) {
      }
      try {
        if (item2.constructor instanceof Function && typeof item2.constructor.name == "string") {
          output2 = `new ${item2.constructor.name}(${pureObjectRepr(item2)})`;
          return output2;
        }
      } catch (error) {
      }
      return pureObjectRepr(item2);
    }
    return output2;
  };
  const pureObjectRepr = (item2) => {
    let string2 = "{";
    for (const [key, value] of Object.entries(item2)) {
      const stringKey = recursionWrapper(key);
      const stringValue = recursionWrapper(value);
      string2 += `
  ${stringKey}: ${indent2({ string: stringValue, by: "  ", noLead: true })},`;
    }
    string2 += "\n}";
    return string2;
  };
  return recursionWrapper(item);
};
function escapeRegexMatch(string2) {
  return string2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var regexpProxy = Symbol("regexpProxy");
var realExec = RegExp.prototype.exec;
RegExp.prototype.exec = function(...args) {
  if (this[regexpProxy]) {
    return realExec.apply(this[regexpProxy], args);
  }
  return realExec.apply(this, args);
};
var proxyRegExp;
var regexProxyOptions = Object.freeze({
  get(original, key) {
    if (typeof key == "string" && key.match(/^[igymu]+$/)) {
      return proxyRegExp(original, key);
    }
    if (key == regexpProxy) {
      return original;
    }
    return original[key];
  },
  set(original, key, value) {
    original[key] = value;
    return true;
  }
});
proxyRegExp = (parent, flags) => {
  const regex3 = new RegExp(parent, flags);
  const output2 = new Proxy(regex3, regexProxyOptions);
  Object.setPrototypeOf(output2, Object.getPrototypeOf(regex3));
  return output2;
};
function regexWithStripWarning(shouldStrip) {
  return (strings, ...values) => {
    let newRegexString = "";
    for (const [string2, value] of zip3(strings, values)) {
      newRegexString += string2;
      if (value instanceof RegExp) {
        if (!shouldStrip && (value.ignoreCase || value.sticky || value.multiline || value.unicode)) {
          console.warn(`Warning: flags inside of regex:
    The RegExp trigging this warning is: ${value}
    When calling the regex interpolater (e.g. regex\`something\${stuff}\`)
    one of the \${} values (the one above) was a RegExp with a flag enabled
    e.g. /stuff/i  <- i = ignoreCase flag enabled
    When the /stuff/i gets interpolated, its going to loose its flags
    (thats what I'm warning you about)
    
    To disable/ignore this warning do:
        regex.stripFlags\`something\${/stuff/i}\`
    If you want to add flags to the output of regex\`something\${stuff}\` do:
        regex\`something\${stuff}\`.i   // ignoreCase
        regex\`something\${stuff}\`.ig  // ignoreCase and global
        regex\`something\${stuff}\`.gi  // functionally equivlent
`);
        }
        const regexContent = `${value}`.slice(1).replace(/\/.*$/, "");
        newRegexString += `(?:${regexContent})`;
      } else if (value != null) {
        newRegexString += escapeRegexMatch(toString(value));
      }
    }
    return proxyRegExp(newRegexString, "");
  };
}
var regex = regexWithStripWarning(false);
regex.stripFlags = regexWithStripWarning(true);
var textDecoder = new TextDecoder("utf-8");
var textEncoder = new TextEncoder("utf-8");
var utf8BytesToString = textDecoder.decode.bind(textDecoder);
var stringToUtf8Bytes = textEncoder.encode.bind(textEncoder);

// https://deno.land/x/quickr@0.6.56/main/console.js
var realConsole = globalThis.console;
var isBrowserContext = typeof document != "undefined" && typeof window != "undefined";
var env = null;
var originalThing = realConsole;
var symbolForConsoleLog = Symbol.for("console.log");
var proxySymbol = Symbol.for("Proxy");
var thisProxySymbol = Symbol("thisProxy");
globalThis.console = new Proxy(originalThing, {
  defineProperty: Reflect.defineProperty,
  getPrototypeOf: Reflect.getPrototypeOf,
  // Object.keys
  ownKeys(...args) {
    return Reflect.ownKeys(...args);
  },
  // function call (original value needs to be a function)
  apply(original, context, ...args) {
    console.log(args);
  },
  // new operator (original value needs to be a class)
  construct(...args) {
  },
  get(original, key, ...args) {
    if (key == proxySymbol || key == thisProxySymbol) {
      return true;
    }
    if (key == "log") {
      return (...args2) => {
        realConsole.log(
          ...args2.map((each2) => {
            if (each2 instanceof Object && each2[symbolForConsoleLog] instanceof Function) {
              return each2[symbolForConsoleLog]();
            }
            return each2;
          })
        );
      };
    }
    return Reflect.get(original, key, ...args);
  },
  set(original, key, ...args) {
    if (key == proxySymbol || key == thisProxySymbol) {
      return;
    }
    return Reflect.set(original, key, ...args);
  }
});
var codeToEscapeString = (code2) => `\x1B[${code2}m`;
var ansiRegexPattern = /[\u001B\u009B][[\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\d\/#&.:=?%@~_]+)*|[a-zA-Z\d]+(?:;[-a-zA-Z\d\/#&.:=?%@~_]*)*)?\u0007)|(?:(?:\d{1,4}(?:;\d{0,4})*)?[\dA-PR-TZcf-nq-uy=><~]))/g;
function clearAnsiStylesFrom(string2) {
  return `${string2}`.replace(ansiRegexPattern, "");
}
var styleStrings = {
  reset: codeToEscapeString(0),
  bold: codeToEscapeString(1),
  dim: codeToEscapeString(2),
  italic: codeToEscapeString(3),
  underline: codeToEscapeString(4),
  slowBlink: codeToEscapeString(5),
  // not widely supported
  fastBlink: codeToEscapeString(6),
  // not widely supported
  inverse: codeToEscapeString(7),
  strikethrough: codeToEscapeString(9),
  primary: codeToEscapeString(11),
  // forground colors
  black: codeToEscapeString(30),
  red: codeToEscapeString(31),
  green: codeToEscapeString(32),
  yellow: codeToEscapeString(33),
  blue: codeToEscapeString(34),
  magenta: codeToEscapeString(35),
  cyan: codeToEscapeString(36),
  white: codeToEscapeString(37),
  lightBlack: codeToEscapeString(90),
  lightRed: codeToEscapeString(91),
  lightGreen: codeToEscapeString(92),
  lightYellow: codeToEscapeString(93),
  lightBlue: codeToEscapeString(94),
  lightMagenta: codeToEscapeString(95),
  lightCyan: codeToEscapeString(96),
  lightWhite: codeToEscapeString(97),
  // background
  blackBackground: codeToEscapeString(40),
  redBackground: codeToEscapeString(41),
  greenBackground: codeToEscapeString(42),
  yellowBackground: codeToEscapeString(43),
  blueBackground: codeToEscapeString(44),
  magentaBackground: codeToEscapeString(45),
  cyanBackground: codeToEscapeString(46),
  whiteBackground: codeToEscapeString(47),
  lightBlackBackground: codeToEscapeString(100),
  lightRedBackground: codeToEscapeString(101),
  lightGreenBackground: codeToEscapeString(102),
  lightYellowBackground: codeToEscapeString(103),
  lightBlueBackground: codeToEscapeString(104),
  lightMagentaBackground: codeToEscapeString(105),
  lightCyanBackground: codeToEscapeString(106),
  lightWhiteBackground: codeToEscapeString(107)
};
Object.assign(styleStrings, {
  gray: styleStrings.lightBlack,
  grey: styleStrings.lightBlack,
  lightGray: styleStrings.white,
  // lightWhite is "true" white
  lightGrey: styleStrings.white,
  // lightWhite is "true" white
  grayBackground: styleStrings.lightBlackBackground,
  greyBackground: styleStrings.lightBlackBackground,
  lightGrayBackground: styleStrings.whiteBackground,
  lightGreyBackground: styleStrings.whiteBackground
});
var styleObjectSymbol = Symbol("consoleStyle");
var styleObject = (rootStyleString) => {
  const createStyleAccumulator = (styleString) => {
    const styleAccumulator = (strings, ...values) => {
      const objectToStyledString = (interpolatedValue, styles) => {
        let singleCombinedString2 = "";
        if (interpolatedValue instanceof Object && interpolatedValue[styleObjectSymbol] instanceof Function) {
          singleCombinedString2 += interpolatedValue[styleObjectSymbol]();
        } else {
          singleCombinedString2 += toString(interpolatedValue);
        }
        singleCombinedString2 += styleStrings.reset + styleAccumulator.styles.join("");
        return singleCombinedString2;
      };
      let singleCombinedString = "";
      if (!(strings instanceof Array) || strings.length < 1 || !strings.every((each2) => typeof each2 == "string")) {
        for (const each2 of [strings, ...values]) {
          singleCombinedString += objectToStyledString(each2);
        }
      } else {
        for (const index in values) {
          singleCombinedString += strings[index];
          singleCombinedString += objectToStyledString(values[index]);
        }
        const lastString = strings.slice(-1)[0];
        singleCombinedString += lastString;
      }
      styleAccumulator.sequence.push(singleCombinedString);
      return styleAccumulator;
    };
    styleAccumulator[styleObjectSymbol] = true;
    styleAccumulator.styles = [styleString];
    styleAccumulator.sequence = [styleString];
    styleAccumulator.toString = () => styleAccumulator.sequence.join("") + styleStrings.reset;
    styleAccumulator[Deno.customInspect] = () => styleAccumulator.sequence.join("") + styleStrings.reset;
    styleAccumulator[symbolForConsoleLog] = () => {
      const asString3 = styleAccumulator.toString();
      if (Console.reliableColorSupport.includesAnsi) {
        return asString3;
      } else {
        return clearAnsiStylesFrom(asString3);
      }
    };
    return Object.defineProperties(styleAccumulator, Object.fromEntries(Object.entries(styleStrings).map(
      ([key, value]) => [
        key,
        {
          get() {
            styleAccumulator.styles.push(value);
            styleAccumulator.sequence.push(value);
            return styleAccumulator;
          }
        }
      ]
    )));
  };
  const topLevelStyleAccumulator = (strings, ...values) => createStyleAccumulator(rootStyleString)(strings, ...values);
  topLevelStyleAccumulator[styleObjectSymbol] = true;
  topLevelStyleAccumulator.toString = () => rootStyleString;
  topLevelStyleAccumulator[symbolForConsoleLog] = () => {
    const asString3 = topLevelStyleAccumulator.toString();
    if (Console.reliableColorSupport.includesAnsi) {
      return asString3;
    } else {
      return clearAnsiStylesFrom(asString3);
    }
  };
  return Object.defineProperties(topLevelStyleAccumulator, Object.fromEntries(Object.entries(styleStrings).map(
    ([eachStyleName, eachStyleString]) => [
      eachStyleName,
      {
        get() {
          const styleAccumulator = createStyleAccumulator(rootStyleString);
          styleAccumulator.styles.push(eachStyleString);
          styleAccumulator.sequence.push(eachStyleString);
          return styleAccumulator;
        }
      }
    ]
  )));
};
var bold2 = styleObject(styleStrings.bold);
var reset2 = styleObject(styleStrings.reset);
var dim2 = styleObject(styleStrings.dim);
var italic2 = styleObject(styleStrings.italic);
var underline2 = styleObject(styleStrings.underline);
var inverse = styleObject(styleStrings.inverse);
var strikethrough = styleObject(styleStrings.strikethrough);
var black = styleObject(styleStrings.black);
var white = styleObject(styleStrings.white);
var red2 = styleObject(styleStrings.red);
var green2 = styleObject(styleStrings.green);
var blue = styleObject(styleStrings.blue);
var yellow2 = styleObject(styleStrings.yellow);
var cyan2 = styleObject(styleStrings.cyan);
var magenta = styleObject(styleStrings.magenta);
var lightBlack = styleObject(styleStrings.lightBlack);
var lightWhite = styleObject(styleStrings.lightWhite);
var lightRed = styleObject(styleStrings.lightRed);
var lightGreen = styleObject(styleStrings.lightGreen);
var lightBlue = styleObject(styleStrings.lightBlue);
var lightYellow = styleObject(styleStrings.lightYellow);
var lightMagenta = styleObject(styleStrings.lightMagenta);
var lightCyan = styleObject(styleStrings.lightCyan);
var blackBackground = styleObject(styleStrings.blackBackground);
var whiteBackground = styleObject(styleStrings.whiteBackground);
var redBackground = styleObject(styleStrings.redBackground);
var greenBackground = styleObject(styleStrings.greenBackground);
var blueBackground = styleObject(styleStrings.blueBackground);
var yellowBackground = styleObject(styleStrings.yellowBackground);
var magentaBackground = styleObject(styleStrings.magentaBackground);
var cyanBackground = styleObject(styleStrings.cyanBackground);
var lightBlackBackground = styleObject(styleStrings.lightBlackBackground);
var lightRedBackground = styleObject(styleStrings.lightRedBackground);
var lightGreenBackground = styleObject(styleStrings.lightGreenBackground);
var lightYellowBackground = styleObject(styleStrings.lightYellowBackground);
var lightBlueBackground = styleObject(styleStrings.lightBlueBackground);
var lightMagentaBackground = styleObject(styleStrings.lightMagentaBackground);
var lightCyanBackground = styleObject(styleStrings.lightCyanBackground);
var lightWhiteBackground = styleObject(styleStrings.lightWhiteBackground);
var gray = styleObject(styleStrings.gray);
var grey = styleObject(styleStrings.grey);
var lightGray = styleObject(styleStrings.lightGray);
var lightGrey = styleObject(styleStrings.lightGrey);
var grayBackground = styleObject(styleStrings.grayBackground);
var greyBackground = styleObject(styleStrings.greyBackground);
var lightGrayBackground = styleObject(styleStrings.lightGrayBackground);
var lightGreyBackground = styleObject(styleStrings.lightGreyBackground);
var colorSupportCache = {
  includesAnsi: null,
  includes256: null,
  includes16m: null
};
var Console = {
  // TODO: add signal handler
  // Deno.addSignalListener("SIGINT", (...args)=>{
  //     console.debug(`args is:`,args)
  // })
  log(...args) {
    if (args.length == 0) {
      console.log();
    }
    let [arg1, ...others] = args.map((each2) => {
      if (each2 instanceof Object && each2[symbolForConsoleLog] instanceof Function) {
        return each2[symbolForConsoleLog]();
      }
      return each2;
    });
    if (typeof arg1 == "string") {
      arg1 = arg1.replace("%", "%%");
    }
    if (!isBrowserContext) {
      if (!Console.reliableColorSupport.includesAnsi) {
        arg1 = clearAnsiStylesFrom(arg1);
        others = others.map((each2) => {
          if (typeof each2 == "string") {
            return clearAnsiStylesFrom(each2);
          } else {
            return each2;
          }
        });
      }
      realConsole.log(arg1, ...others);
    } else {
      if (args[0][symbolForConsoleLog] && typeof args[0].styleString == "string") {
        realConsole.log(`%c${arg1}${others.map((each2) => `${each2}`).join("")}`, args[0].styleString);
      } else {
        realConsole.log(arg1, ...others);
      }
    }
    return Console;
  },
  get env() {
    return env = env || new Proxy(
      Deno.env.toObject(),
      {
        // Object.keys
        ownKeys(target) {
          return Object.keys(Deno.env.toObject());
        },
        has(original, key) {
          if (typeof key === "symbol") {
            return false;
          } else {
            return Deno.env.get(key) !== void 0;
          }
        },
        get(original, key) {
          if (typeof key === "symbol") {
            return original[key];
          } else {
            return Deno.env.get(key);
          }
        },
        set(original, key, value) {
          original[key] = value;
          if (typeof key !== "symbol") {
            Deno.env.set(key, value);
          }
          return true;
        },
        deleteProperty(original, key) {
          if (typeof key === "symbol") {
            return void 0;
          } else {
            return Deno.env.delete(key);
          }
        }
      }
    );
  },
  disableColorIfNonIteractive: true,
  askFor: {
    // in the future once Deno.setRaw is stable, add a askFor.password using: https://github.com/caspervonb/deno-prompts
    line(question) {
      return prompt(question);
    },
    confirmation(question) {
      console.log(question);
      prompt("[use CTRL+C to quit, or press enter to continue]");
    },
    positiveIntegerOrZero(question) {
      while (1) {
        console.log(question);
        const answer = prompt(question);
        const asNumber = answer - 0;
        const isRealNumber = asNumber !== asNumber && asNumber * 2 !== asNumber;
        const isInteger2 = Math.round(asNumber) === asNumber;
        const isNonNegative = asNumber >= 0;
        if (isRealNumber && isInteger2 && isNonNegative) {
          return asNumber;
        } else {
          if (!isRealNumber) {
            console.log(`I don't think ${answer} is a real number, please try again`);
          }
          if (!isInteger2) {
            console.log(`I don't think ${answer} is an integer, please try again`);
          }
          if (!isNonNegative) {
            console.log(`I don't think ${answer} is \u2265 0, please try again`);
          }
        }
      }
    },
    yesNo(question) {
      while (true) {
        let answer = prompt(question);
        const match = `${answer}`.match(/^ *(y|yes|n|no) *\n?$/i);
        if (match) {
          if (match[1][0] == "y" || match[1][0] == "Y") {
            return true;
          } else {
            return false;
          }
        } else {
          console.log("[ please respond with y/n, yes/no, or use CTRL+C to cancel ]");
        }
      }
    },
    oneOf(keyValues, question = "Please type one of the names from the list above") {
      if (keyValues instanceof Array) {
        keyValues = Object.fromEntries(keyValues.map((each2, index) => [index, each2]));
      }
      const keys = Object.keys(keyValues);
      if (keys.length == 0) {
        console.warn(`Tried to perform Console.askFor.oneOf(object) but the object was empty`);
        return void 0;
      }
      const longest2 = Math.max(keys.map((each2) => each2.length));
      while (true) {
        for (const [key, value] of Object.entries(keyValues)) {
          const valueAsString = indent2({ string: `${value}
`, by: " ".repeat(longest2 + 2), noLead: true });
          console.log(``, `${key}: ${valueAsString}`);
        }
        let answer = prompt(question);
        if (keys.includes(answer)) {
          return keyValues[answer];
        } else {
          console.log("\n\n[ please pick one of the listed names, or use CTRL+C to cancel ]");
        }
      }
    }
  },
  get paths() {
    const spliter = OperatingSystem.commonChecks.isWindows ? ";" : ":";
    return Deno.env.get("PATH").split(spliter);
  },
  get reliableColorSupport() {
    if (colorSupportCache.includesAnsi != null) {
      return colorSupportCache;
    }
    let terminalSupport;
    if (!Deno.isatty(0)) {
      terminalSupport = {
        includesAnsi: false,
        includes256: false,
        includes16m: false
      };
    } else if ("NO_COLOR" in Console.env) {
      terminalSupport = {
        includesAnsi: false,
        includes256: false,
        includes16m: false
      };
    } else {
      if (OperatingSystem.commonChecks.isWindows || OperatingSystem.commonChecks.isWsl) {
        if (Deno.env.get("WT_SESSION")) {
          terminalSupport = {
            includesAnsi: true,
            includes256: true,
            includes16m: true
          };
        } else {
          terminalSupport = {
            includesAnsi: false,
            includes256: false,
            includes16m: false
          };
        }
      } else {
        if ("TERM_PROGRAM" in Console.env) {
          const version = Number.parseInt((Console.env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          if (Console.env.TERM_PROGRAM == "iTerm.app") {
            if (version >= 3) {
              terminalSupport = {
                includesAnsi: true,
                includes256: true,
                includes16m: true
              };
            } else {
              terminalSupport = {
                includesAnsi: true,
                includes256: true,
                includes16m: false
              };
            }
          } else if (Console.env.TERM_PROGRAM == "Apple_Terminal") {
            terminalSupport = {
              includesAnsi: true,
              includes256: true,
              includes16m: false
            };
          }
        }
        if (Console.env.TERM === "dumb") {
          terminalSupport = {
            includesAnsi: false,
            includes256: false,
            includes16m: false
          };
        } else if ("CI" in Console.env) {
          terminalSupport = {
            includesAnsi: ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => sign in Console.env) || Console.env.CI_NAME === "codeship",
            includes256: false,
            includes16m: false
          };
        } else if (Console.env.COLORTERM === "truecolor") {
          terminalSupport = {
            includesAnsi: true,
            includes256: true,
            includes16m: true
          };
        } else if (/-256(color)?$/i.test(Console.env.TERM)) {
          terminalSupport = {
            includesAnsi: true,
            includes256: true,
            includes16m: false
          };
        } else if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Console.env.TERM)) {
          terminalSupport = {
            includesAnsi: true,
            includes256: false,
            includes16m: false
          };
        } else if ("COLORTERM" in Console.env) {
          terminalSupport = {
            includesAnsi: true,
            includes256: false,
            includes16m: false
          };
        } else {
          terminalSupport = {
            includesAnsi: false,
            includes256: false,
            includes16m: false
          };
        }
      }
    }
    colorSupportCache.includesAnsi = terminalSupport.includesAnsi;
    colorSupportCache.includes256 = terminalSupport.includes256;
    colorSupportCache.includes16m = terminalSupport.includes16m;
    return colorSupportCache;
  }
};

// https://deno.land/x/ensure@v1.1.0/src/compare.ts
function isOutdated(minimumVersion, actualVersion) {
  const minimumVersionArr = minimumVersion.split(".");
  const actualVersionArr = actualVersion.split(".");
  versionCategoryEnumeration:
    for (let i2 = 0; i2 < minimumVersionArr.length; ++i2) {
      const minimumVersionCategoryNum = parseInt(minimumVersionArr[i2]);
      const actualVersionCategoryNum = parseInt(actualVersionArr[i2]);
      if (minimumVersionCategoryNum > actualVersionCategoryNum) {
        return true;
      } else if (minimumVersionCategoryNum === actualVersionCategoryNum) {
        continue versionCategoryEnumeration;
      } else {
        break versionCategoryEnumeration;
      }
    }
  return false;
}

// https://deno.land/x/ensure@v1.1.0/src/main.ts
var warn = (type, current2, expected) => `Your ${type} version is ${current2}, but at least version ${expected} is required. Please update to a later version of Deno. Thankies!`;
function ensure(ensureOptions) {
  const { deno: currentDeno, v8: currentV8, typescript: currentTypescript } = Deno.version;
  const {
    denoVersion: expectedDeno,
    v8Version: expectedV8,
    typescriptVersion: expectedTypescript
  } = ensureOptions;
  let atLeastOneOutdated = false;
  const ensureCategories = [
    ["Deno", currentDeno, expectedDeno],
    ["V8", currentV8, expectedV8],
    ["Typescript", currentTypescript, expectedTypescript]
  ];
  for (const [categoryName, currentVersion, expectedVersion] of ensureCategories) {
    if (!expectedVersion)
      continue;
    const isCategoryOutdated = isOutdated(expectedVersion, currentVersion);
    if (isCategoryOutdated) {
      console.info(warn(categoryName, currentVersion, expectedVersion));
      atLeastOneOutdated = true;
    }
  }
  if (atLeastOneOutdated) {
    Deno.exit(1);
  }
}

// https://deno.land/std@0.128.0/_util/os.ts
var osType = (() => {
  const { Deno: Deno4 } = globalThis;
  if (typeof Deno4?.build?.os === "string") {
    return Deno4.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win") ?? false) {
    return "windows";
  }
  return "linux";
})();
var isWindows = osType === "windows";

// https://deno.land/std@0.128.0/path/win32.ts
var win32_exports = {};
__export(win32_exports, {
  basename: () => basename,
  delimiter: () => delimiter,
  dirname: () => dirname,
  extname: () => extname,
  format: () => format,
  fromFileUrl: () => fromFileUrl,
  isAbsolute: () => isAbsolute,
  join: () => join,
  normalize: () => normalize,
  parse: () => parse,
  relative: () => relative,
  resolve: () => resolve,
  sep: () => sep,
  toFileUrl: () => toFileUrl,
  toNamespacedPath: () => toNamespacedPath
});

// https://deno.land/std@0.128.0/path/_constants.ts
var CHAR_UPPERCASE_A = 65;
var CHAR_LOWERCASE_A = 97;
var CHAR_UPPERCASE_Z = 90;
var CHAR_LOWERCASE_Z = 122;
var CHAR_DOT = 46;
var CHAR_FORWARD_SLASH = 47;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_COLON = 58;
var CHAR_QUESTION_MARK = 63;

// https://deno.land/std@0.128.0/path/_util.ts
function assertPath(path10) {
  if (typeof path10 !== "string") {
    throw new TypeError(
      `Path must be a string. Received ${JSON.stringify(path10)}`
    );
  }
}
function isPosixPathSeparator(code2) {
  return code2 === CHAR_FORWARD_SLASH;
}
function isPathSeparator(code2) {
  return isPosixPathSeparator(code2) || code2 === CHAR_BACKWARD_SLASH;
}
function isWindowsDeviceRoot(code2) {
  return code2 >= CHAR_LOWERCASE_A && code2 <= CHAR_LOWERCASE_Z || code2 >= CHAR_UPPERCASE_A && code2 <= CHAR_UPPERCASE_Z;
}
function normalizeString(path10, allowAboveRoot, separator, isPathSeparator6) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i2 = 0, len = path10.length; i2 <= len; ++i2) {
    if (i2 < len)
      code2 = path10.charCodeAt(i2);
    else if (isPathSeparator6(code2))
      break;
    else
      code2 = CHAR_FORWARD_SLASH;
    if (isPathSeparator6(code2)) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i2;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path10.slice(lastSlash + 1, i2);
        else
          res = path10.slice(lastSlash + 1, i2);
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code2 === CHAR_DOT && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format(sep15, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base;
  if (dir === pathObject.root)
    return dir + base;
  return dir + sep15 + base;
}
var WHITESPACE_ENCODINGS = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace(string2) {
  return string2.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS[c] ?? c;
  });
}

// https://deno.land/std@0.128.0/_util/assert.ts
var DenoStdInternalError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert2(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError(msg);
  }
}

// https://deno.land/std@0.128.0/path/win32.ts
var sep = "\\";
var delimiter = ";";
function resolve(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1; i2--) {
    let path10;
    const { Deno: Deno4 } = globalThis;
    if (i2 >= 0) {
      path10 = pathSegments[i2];
    } else if (!resolvedDevice) {
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path10 = Deno4.cwd();
    } else {
      if (typeof Deno4?.env?.get !== "function" || typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path10 = Deno4.cwd();
      if (path10 === void 0 || path10.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path10 = `${resolvedDevice}\\`;
      }
    }
    assertPath(path10);
    const len = path10.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute15 = false;
    const code2 = path10.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator(code2)) {
        isAbsolute15 = true;
        if (isPathSeparator(path10.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            const firstPart = path10.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator(path10.charCodeAt(j)))
                break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator(path10.charCodeAt(j)))
                  break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path10.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path10.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot(code2)) {
        if (path10.charCodeAt(1) === CHAR_COLON) {
          device = path10.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator(path10.charCodeAt(2))) {
              isAbsolute15 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator(code2)) {
      rootEnd = 1;
      isAbsolute15 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path10.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute15;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString(
    resolvedTail,
    !resolvedAbsolute,
    "\\",
    isPathSeparator
  );
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path10) {
  assertPath(path10);
  const len = path10.length;
  if (len === 0)
    return ".";
  let rootEnd = 0;
  let device;
  let isAbsolute15 = false;
  const code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      isAbsolute15 = true;
      if (isPathSeparator(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          const firstPart = path10.slice(last, j);
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path10.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path10.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON) {
        device = path10.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path10.charCodeAt(2))) {
            isAbsolute15 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString(
      path10.slice(rootEnd),
      !isAbsolute15,
      "\\",
      isPathSeparator
    );
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute15)
    tail = ".";
  if (tail.length > 0 && isPathSeparator(path10.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute15) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute15) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function isAbsolute(path10) {
  assertPath(path10);
  const len = path10.length;
  if (len === 0)
    return false;
  const code2 = path10.charCodeAt(0);
  if (isPathSeparator(code2)) {
    return true;
  } else if (isWindowsDeviceRoot(code2)) {
    if (len > 2 && path10.charCodeAt(1) === CHAR_COLON) {
      if (isPathSeparator(path10.charCodeAt(2)))
        return true;
    }
  }
  return false;
}
function join(...paths) {
  const pathsCount = paths.length;
  if (pathsCount === 0)
    return ".";
  let joined;
  let firstPart = null;
  for (let i2 = 0; i2 < pathsCount; ++i2) {
    const path10 = paths[i2];
    assertPath(path10);
    if (path10.length > 0) {
      if (joined === void 0)
        joined = firstPart = path10;
      else
        joined += `\\${path10}`;
    }
  }
  if (joined === void 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert2(firstPart != null);
  if (isPathSeparator(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize(joined);
}
function relative(from, to) {
  assertPath(from);
  assertPath(to);
  if (from === to)
    return "";
  const fromOrig = resolve(from);
  const toOrig = resolve(to);
  if (fromOrig === toOrig)
    return "";
  from = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from === to)
    return "";
  let fromStart = 0;
  let fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH)
      break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH)
      break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length; ++i2) {
    if (i2 === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i2) === CHAR_BACKWARD_SLASH) {
          return toOrig.slice(toStart + i2 + 1);
        } else if (i2 === 2) {
          return toOrig.slice(toStart + i2);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i2) === CHAR_BACKWARD_SLASH) {
          lastCommonSep = i2;
        } else if (i2 === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_BACKWARD_SLASH)
      lastCommonSep = i2;
  }
  if (i2 !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || from.charCodeAt(i2) === CHAR_BACKWARD_SLASH) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function toNamespacedPath(path10) {
  if (typeof path10 !== "string")
    return path10;
  if (path10.length === 0)
    return "";
  const resolvedPath = resolve(path10);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== CHAR_QUESTION_MARK && code2 !== CHAR_DOT) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path10;
}
function dirname(path10) {
  assertPath(path10);
  const len = path10.length;
  if (len === 0)
    return ".";
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return path10;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator(path10.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    return path10;
  }
  for (let i2 = len - 1; i2 >= offset; --i2) {
    if (isPathSeparator(path10.charCodeAt(i2))) {
      if (!matchedSlash) {
        end = i2;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return path10.slice(0, end);
}
function basename(path10, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path10);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i2;
  if (path10.length >= 2) {
    const drive = path10.charCodeAt(0);
    if (isWindowsDeviceRoot(drive)) {
      if (path10.charCodeAt(1) === CHAR_COLON)
        start = 2;
    }
  }
  if (ext !== void 0 && ext.length > 0 && ext.length <= path10.length) {
    if (ext.length === path10.length && ext === path10)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i2 = path10.length - 1; i2 >= start; --i2) {
      const code2 = path10.charCodeAt(i2);
      if (isPathSeparator(code2)) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i2 + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i2;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path10.length;
    return path10.slice(start, end);
  } else {
    for (i2 = path10.length - 1; i2 >= start; --i2) {
      if (isPathSeparator(path10.charCodeAt(i2))) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
    }
    if (end === -1)
      return "";
    return path10.slice(start, end);
  }
}
function extname(path10) {
  assertPath(path10);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path10.length >= 2 && path10.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path10.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i2 = path10.length - 1; i2 >= start; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (isPathSeparator(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path10.slice(startDot, end);
}
function format(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(
      `The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`
    );
  }
  return _format("\\", pathObject);
}
function parse(path10) {
  assertPath(path10);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  const len = path10.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator(code2)) {
      rootEnd = 1;
      if (isPathSeparator(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator(path10.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path10;
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path10;
          return ret;
        }
      }
    }
  } else if (isPathSeparator(code2)) {
    ret.root = ret.dir = path10;
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path10.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i2 = path10.length - 1;
  let preDotState = 0;
  for (; i2 >= rootEnd; --i2) {
    code2 = path10.charCodeAt(i2);
    if (isPathSeparator(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path10.slice(startPart, end);
    }
  } else {
    ret.name = path10.slice(startPart, startDot);
    ret.base = path10.slice(startPart, end);
    ret.ext = path10.slice(startDot, end);
  }
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path10.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}
function fromFileUrl(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  let path10 = decodeURIComponent(
    url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  ).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname != "") {
    path10 = `\\\\${url.hostname}${path10}`;
  }
  return path10;
}
function toFileUrl(path10) {
  if (!isAbsolute(path10)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path10.match(
    /^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/
  );
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
  if (hostname != null && hostname != "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}

// https://deno.land/std@0.128.0/path/posix.ts
var posix_exports = {};
__export(posix_exports, {
  basename: () => basename2,
  delimiter: () => delimiter2,
  dirname: () => dirname2,
  extname: () => extname2,
  format: () => format2,
  fromFileUrl: () => fromFileUrl2,
  isAbsolute: () => isAbsolute2,
  join: () => join2,
  normalize: () => normalize2,
  parse: () => parse2,
  relative: () => relative2,
  resolve: () => resolve2,
  sep: () => sep2,
  toFileUrl: () => toFileUrl2,
  toNamespacedPath: () => toNamespacedPath2
});
var sep2 = "/";
var delimiter2 = ":";
function resolve2(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    let path10;
    if (i2 >= 0)
      path10 = pathSegments[i2];
    else {
      const { Deno: Deno4 } = globalThis;
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path10 = Deno4.cwd();
    }
    assertPath(path10);
    if (path10.length === 0) {
      continue;
    }
    resolvedPath = `${path10}/${resolvedPath}`;
    resolvedAbsolute = path10.charCodeAt(0) === CHAR_FORWARD_SLASH;
  }
  resolvedPath = normalizeString(
    resolvedPath,
    !resolvedAbsolute,
    "/",
    isPosixPathSeparator
  );
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize2(path10) {
  assertPath(path10);
  if (path10.length === 0)
    return ".";
  const isAbsolute15 = path10.charCodeAt(0) === CHAR_FORWARD_SLASH;
  const trailingSeparator = path10.charCodeAt(path10.length - 1) === CHAR_FORWARD_SLASH;
  path10 = normalizeString(path10, !isAbsolute15, "/", isPosixPathSeparator);
  if (path10.length === 0 && !isAbsolute15)
    path10 = ".";
  if (path10.length > 0 && trailingSeparator)
    path10 += "/";
  if (isAbsolute15)
    return `/${path10}`;
  return path10;
}
function isAbsolute2(path10) {
  assertPath(path10);
  return path10.length > 0 && path10.charCodeAt(0) === CHAR_FORWARD_SLASH;
}
function join2(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i2 = 0, len = paths.length; i2 < len; ++i2) {
    const path10 = paths[i2];
    assertPath(path10);
    if (path10.length > 0) {
      if (!joined)
        joined = path10;
      else
        joined += `/${path10}`;
    }
  }
  if (!joined)
    return ".";
  return normalize2(joined);
}
function relative2(from, to) {
  assertPath(from);
  assertPath(to);
  if (from === to)
    return "";
  from = resolve2(from);
  to = resolve2(to);
  if (from === to)
    return "";
  let fromStart = 1;
  const fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length; ++i2) {
    if (i2 === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i2) === CHAR_FORWARD_SLASH) {
          return to.slice(toStart + i2 + 1);
        } else if (i2 === 0) {
          return to.slice(toStart + i2);
        }
      } else if (fromLen > length) {
        if (from.charCodeAt(fromStart + i2) === CHAR_FORWARD_SLASH) {
          lastCommonSep = i2;
        } else if (i2 === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_FORWARD_SLASH)
      lastCommonSep = i2;
  }
  let out = "";
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || from.charCodeAt(i2) === CHAR_FORWARD_SLASH) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH)
      ++toStart;
    return to.slice(toStart);
  }
}
function toNamespacedPath2(path10) {
  return path10;
}
function dirname2(path10) {
  assertPath(path10);
  if (path10.length === 0)
    return ".";
  const hasRoot = path10.charCodeAt(0) === CHAR_FORWARD_SLASH;
  let end = -1;
  let matchedSlash = true;
  for (let i2 = path10.length - 1; i2 >= 1; --i2) {
    if (path10.charCodeAt(i2) === CHAR_FORWARD_SLASH) {
      if (!matchedSlash) {
        end = i2;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path10.slice(0, end);
}
function basename2(path10, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath(path10);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i2;
  if (ext !== void 0 && ext.length > 0 && ext.length <= path10.length) {
    if (ext.length === path10.length && ext === path10)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i2 = path10.length - 1; i2 >= 0; --i2) {
      const code2 = path10.charCodeAt(i2);
      if (code2 === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i2 + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i2;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path10.length;
    return path10.slice(start, end);
  } else {
    for (i2 = path10.length - 1; i2 >= 0; --i2) {
      if (path10.charCodeAt(i2) === CHAR_FORWARD_SLASH) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
    }
    if (end === -1)
      return "";
    return path10.slice(start, end);
  }
}
function extname2(path10) {
  assertPath(path10);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i2 = path10.length - 1; i2 >= 0; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (code2 === CHAR_FORWARD_SLASH) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path10.slice(startDot, end);
}
function format2(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(
      `The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`
    );
  }
  return _format("/", pathObject);
}
function parse2(path10) {
  assertPath(path10);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path10.length === 0)
    return ret;
  const isAbsolute15 = path10.charCodeAt(0) === CHAR_FORWARD_SLASH;
  let start;
  if (isAbsolute15) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i2 = path10.length - 1;
  let preDotState = 0;
  for (; i2 >= start; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (code2 === CHAR_FORWARD_SLASH) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute15) {
        ret.base = ret.name = path10.slice(1, end);
      } else {
        ret.base = ret.name = path10.slice(startPart, end);
      }
    }
  } else {
    if (startPart === 0 && isAbsolute15) {
      ret.name = path10.slice(1, startDot);
      ret.base = path10.slice(1, end);
    } else {
      ret.name = path10.slice(startPart, startDot);
      ret.base = path10.slice(startPart, end);
    }
    ret.ext = path10.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path10.slice(0, startPart - 1);
  else if (isAbsolute15)
    ret.dir = "/";
  return ret;
}
function fromFileUrl2(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return decodeURIComponent(
    url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  );
}
function toFileUrl2(path10) {
  if (!isAbsolute2(path10)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace(
    path10.replace(/%/g, "%25").replace(/\\/g, "%5C")
  );
  return url;
}

// https://deno.land/std@0.128.0/path/glob.ts
var path = isWindows ? win32_exports : posix_exports;
var { join: join3, normalize: normalize3 } = path;

// https://deno.land/std@0.128.0/path/mod.ts
var path2 = isWindows ? win32_exports : posix_exports;
var {
  basename: basename3,
  delimiter: delimiter3,
  dirname: dirname3,
  extname: extname3,
  format: format3,
  fromFileUrl: fromFileUrl3,
  isAbsolute: isAbsolute3,
  join: join4,
  normalize: normalize4,
  parse: parse3,
  relative: relative3,
  resolve: resolve3,
  sep: sep3,
  toFileUrl: toFileUrl3,
  toNamespacedPath: toNamespacedPath3
} = path2;

// https://deno.land/std@0.133.0/_util/os.ts
var osType2 = (() => {
  const { Deno: Deno4 } = globalThis;
  if (typeof Deno4?.build?.os === "string") {
    return Deno4.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win") ?? false) {
    return "windows";
  }
  return "linux";
})();
var isWindows2 = osType2 === "windows";

// https://deno.land/std@0.133.0/path/win32.ts
var win32_exports2 = {};
__export(win32_exports2, {
  basename: () => basename4,
  delimiter: () => delimiter4,
  dirname: () => dirname4,
  extname: () => extname4,
  format: () => format4,
  fromFileUrl: () => fromFileUrl4,
  isAbsolute: () => isAbsolute4,
  join: () => join5,
  normalize: () => normalize5,
  parse: () => parse4,
  relative: () => relative4,
  resolve: () => resolve4,
  sep: () => sep4,
  toFileUrl: () => toFileUrl4,
  toNamespacedPath: () => toNamespacedPath4
});

// https://deno.land/std@0.133.0/path/_constants.ts
var CHAR_UPPERCASE_A2 = 65;
var CHAR_LOWERCASE_A2 = 97;
var CHAR_UPPERCASE_Z2 = 90;
var CHAR_LOWERCASE_Z2 = 122;
var CHAR_DOT2 = 46;
var CHAR_FORWARD_SLASH2 = 47;
var CHAR_BACKWARD_SLASH2 = 92;
var CHAR_COLON2 = 58;
var CHAR_QUESTION_MARK2 = 63;

// https://deno.land/std@0.133.0/path/_util.ts
function assertPath2(path10) {
  if (typeof path10 !== "string") {
    throw new TypeError(
      `Path must be a string. Received ${JSON.stringify(path10)}`
    );
  }
}
function isPosixPathSeparator2(code2) {
  return code2 === CHAR_FORWARD_SLASH2;
}
function isPathSeparator2(code2) {
  return isPosixPathSeparator2(code2) || code2 === CHAR_BACKWARD_SLASH2;
}
function isWindowsDeviceRoot2(code2) {
  return code2 >= CHAR_LOWERCASE_A2 && code2 <= CHAR_LOWERCASE_Z2 || code2 >= CHAR_UPPERCASE_A2 && code2 <= CHAR_UPPERCASE_Z2;
}
function normalizeString2(path10, allowAboveRoot, separator, isPathSeparator6) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i2 = 0, len = path10.length; i2 <= len; ++i2) {
    if (i2 < len)
      code2 = path10.charCodeAt(i2);
    else if (isPathSeparator6(code2))
      break;
    else
      code2 = CHAR_FORWARD_SLASH2;
    if (isPathSeparator6(code2)) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT2 || res.charCodeAt(res.length - 2) !== CHAR_DOT2) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i2;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path10.slice(lastSlash + 1, i2);
        else
          res = path10.slice(lastSlash + 1, i2);
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code2 === CHAR_DOT2 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format2(sep15, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base;
  if (dir === pathObject.root)
    return dir + base;
  return dir + sep15 + base;
}
var WHITESPACE_ENCODINGS2 = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace2(string2) {
  return string2.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS2[c] ?? c;
  });
}

// https://deno.land/std@0.133.0/_util/assert.ts
var DenoStdInternalError2 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert3(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError2(msg);
  }
}

// https://deno.land/std@0.133.0/path/win32.ts
var sep4 = "\\";
var delimiter4 = ";";
function resolve4(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1; i2--) {
    let path10;
    const { Deno: Deno4 } = globalThis;
    if (i2 >= 0) {
      path10 = pathSegments[i2];
    } else if (!resolvedDevice) {
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path10 = Deno4.cwd();
    } else {
      if (typeof Deno4?.env?.get !== "function" || typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path10 = Deno4.cwd();
      if (path10 === void 0 || path10.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path10 = `${resolvedDevice}\\`;
      }
    }
    assertPath2(path10);
    const len = path10.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute15 = false;
    const code2 = path10.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator2(code2)) {
        isAbsolute15 = true;
        if (isPathSeparator2(path10.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator2(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            const firstPart = path10.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator2(path10.charCodeAt(j)))
                break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator2(path10.charCodeAt(j)))
                  break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path10.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path10.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot2(code2)) {
        if (path10.charCodeAt(1) === CHAR_COLON2) {
          device = path10.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator2(path10.charCodeAt(2))) {
              isAbsolute15 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator2(code2)) {
      rootEnd = 1;
      isAbsolute15 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path10.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute15;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString2(
    resolvedTail,
    !resolvedAbsolute,
    "\\",
    isPathSeparator2
  );
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize5(path10) {
  assertPath2(path10);
  const len = path10.length;
  if (len === 0)
    return ".";
  let rootEnd = 0;
  let device;
  let isAbsolute15 = false;
  const code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      isAbsolute15 = true;
      if (isPathSeparator2(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator2(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          const firstPart = path10.slice(last, j);
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator2(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator2(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path10.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path10.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON2) {
        device = path10.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator2(path10.charCodeAt(2))) {
            isAbsolute15 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString2(
      path10.slice(rootEnd),
      !isAbsolute15,
      "\\",
      isPathSeparator2
    );
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute15)
    tail = ".";
  if (tail.length > 0 && isPathSeparator2(path10.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute15) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute15) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function isAbsolute4(path10) {
  assertPath2(path10);
  const len = path10.length;
  if (len === 0)
    return false;
  const code2 = path10.charCodeAt(0);
  if (isPathSeparator2(code2)) {
    return true;
  } else if (isWindowsDeviceRoot2(code2)) {
    if (len > 2 && path10.charCodeAt(1) === CHAR_COLON2) {
      if (isPathSeparator2(path10.charCodeAt(2)))
        return true;
    }
  }
  return false;
}
function join5(...paths) {
  const pathsCount = paths.length;
  if (pathsCount === 0)
    return ".";
  let joined;
  let firstPart = null;
  for (let i2 = 0; i2 < pathsCount; ++i2) {
    const path10 = paths[i2];
    assertPath2(path10);
    if (path10.length > 0) {
      if (joined === void 0)
        joined = firstPart = path10;
      else
        joined += `\\${path10}`;
    }
  }
  if (joined === void 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert3(firstPart != null);
  if (isPathSeparator2(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator2(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator2(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator2(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize5(joined);
}
function relative4(from, to) {
  assertPath2(from);
  assertPath2(to);
  if (from === to)
    return "";
  const fromOrig = resolve4(from);
  const toOrig = resolve4(to);
  if (fromOrig === toOrig)
    return "";
  from = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from === to)
    return "";
  let fromStart = 0;
  let fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH2)
      break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH2)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH2)
      break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH2)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length; ++i2) {
    if (i2 === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i2) === CHAR_BACKWARD_SLASH2) {
          return toOrig.slice(toStart + i2 + 1);
        } else if (i2 === 2) {
          return toOrig.slice(toStart + i2);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i2) === CHAR_BACKWARD_SLASH2) {
          lastCommonSep = i2;
        } else if (i2 === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_BACKWARD_SLASH2)
      lastCommonSep = i2;
  }
  if (i2 !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || from.charCodeAt(i2) === CHAR_BACKWARD_SLASH2) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH2)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function toNamespacedPath4(path10) {
  if (typeof path10 !== "string")
    return path10;
  if (path10.length === 0)
    return "";
  const resolvedPath = resolve4(path10);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH2) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH2) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== CHAR_QUESTION_MARK2 && code2 !== CHAR_DOT2) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot2(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === CHAR_COLON2 && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH2) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path10;
}
function dirname4(path10) {
  assertPath2(path10);
  const len = path10.length;
  if (len === 0)
    return ".";
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator2(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator2(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator2(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator2(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return path10;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON2) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator2(path10.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    return path10;
  }
  for (let i2 = len - 1; i2 >= offset; --i2) {
    if (isPathSeparator2(path10.charCodeAt(i2))) {
      if (!matchedSlash) {
        end = i2;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return path10.slice(0, end);
}
function basename4(path10, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath2(path10);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i2;
  if (path10.length >= 2) {
    const drive = path10.charCodeAt(0);
    if (isWindowsDeviceRoot2(drive)) {
      if (path10.charCodeAt(1) === CHAR_COLON2)
        start = 2;
    }
  }
  if (ext !== void 0 && ext.length > 0 && ext.length <= path10.length) {
    if (ext.length === path10.length && ext === path10)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i2 = path10.length - 1; i2 >= start; --i2) {
      const code2 = path10.charCodeAt(i2);
      if (isPathSeparator2(code2)) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i2 + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i2;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path10.length;
    return path10.slice(start, end);
  } else {
    for (i2 = path10.length - 1; i2 >= start; --i2) {
      if (isPathSeparator2(path10.charCodeAt(i2))) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
    }
    if (end === -1)
      return "";
    return path10.slice(start, end);
  }
}
function extname4(path10) {
  assertPath2(path10);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path10.length >= 2 && path10.charCodeAt(1) === CHAR_COLON2 && isWindowsDeviceRoot2(path10.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i2 = path10.length - 1; i2 >= start; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (isPathSeparator2(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT2) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path10.slice(startDot, end);
}
function format4(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(
      `The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`
    );
  }
  return _format2("\\", pathObject);
}
function parse4(path10) {
  assertPath2(path10);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  const len = path10.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator2(code2)) {
      rootEnd = 1;
      if (isPathSeparator2(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator2(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator2(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator2(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot2(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON2) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator2(path10.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path10;
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path10;
          return ret;
        }
      }
    }
  } else if (isPathSeparator2(code2)) {
    ret.root = ret.dir = path10;
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path10.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i2 = path10.length - 1;
  let preDotState = 0;
  for (; i2 >= rootEnd; --i2) {
    code2 = path10.charCodeAt(i2);
    if (isPathSeparator2(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT2) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path10.slice(startPart, end);
    }
  } else {
    ret.name = path10.slice(startPart, startDot);
    ret.base = path10.slice(startPart, end);
    ret.ext = path10.slice(startDot, end);
  }
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path10.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}
function fromFileUrl4(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  let path10 = decodeURIComponent(
    url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  ).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname != "") {
    path10 = `\\\\${url.hostname}${path10}`;
  }
  return path10;
}
function toFileUrl4(path10) {
  if (!isAbsolute4(path10)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path10.match(
    /^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/
  );
  const url = new URL("file:///");
  url.pathname = encodeWhitespace2(pathname.replace(/%/g, "%25"));
  if (hostname != null && hostname != "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}

// https://deno.land/std@0.133.0/path/posix.ts
var posix_exports2 = {};
__export(posix_exports2, {
  basename: () => basename5,
  delimiter: () => delimiter5,
  dirname: () => dirname5,
  extname: () => extname5,
  format: () => format5,
  fromFileUrl: () => fromFileUrl5,
  isAbsolute: () => isAbsolute5,
  join: () => join6,
  normalize: () => normalize6,
  parse: () => parse5,
  relative: () => relative5,
  resolve: () => resolve5,
  sep: () => sep5,
  toFileUrl: () => toFileUrl5,
  toNamespacedPath: () => toNamespacedPath5
});
var sep5 = "/";
var delimiter5 = ":";
function resolve5(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    let path10;
    if (i2 >= 0)
      path10 = pathSegments[i2];
    else {
      const { Deno: Deno4 } = globalThis;
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path10 = Deno4.cwd();
    }
    assertPath2(path10);
    if (path10.length === 0) {
      continue;
    }
    resolvedPath = `${path10}/${resolvedPath}`;
    resolvedAbsolute = path10.charCodeAt(0) === CHAR_FORWARD_SLASH2;
  }
  resolvedPath = normalizeString2(
    resolvedPath,
    !resolvedAbsolute,
    "/",
    isPosixPathSeparator2
  );
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize6(path10) {
  assertPath2(path10);
  if (path10.length === 0)
    return ".";
  const isAbsolute15 = path10.charCodeAt(0) === CHAR_FORWARD_SLASH2;
  const trailingSeparator = path10.charCodeAt(path10.length - 1) === CHAR_FORWARD_SLASH2;
  path10 = normalizeString2(path10, !isAbsolute15, "/", isPosixPathSeparator2);
  if (path10.length === 0 && !isAbsolute15)
    path10 = ".";
  if (path10.length > 0 && trailingSeparator)
    path10 += "/";
  if (isAbsolute15)
    return `/${path10}`;
  return path10;
}
function isAbsolute5(path10) {
  assertPath2(path10);
  return path10.length > 0 && path10.charCodeAt(0) === CHAR_FORWARD_SLASH2;
}
function join6(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i2 = 0, len = paths.length; i2 < len; ++i2) {
    const path10 = paths[i2];
    assertPath2(path10);
    if (path10.length > 0) {
      if (!joined)
        joined = path10;
      else
        joined += `/${path10}`;
    }
  }
  if (!joined)
    return ".";
  return normalize6(joined);
}
function relative5(from, to) {
  assertPath2(from);
  assertPath2(to);
  if (from === to)
    return "";
  from = resolve5(from);
  to = resolve5(to);
  if (from === to)
    return "";
  let fromStart = 1;
  const fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH2)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH2)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length; ++i2) {
    if (i2 === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i2) === CHAR_FORWARD_SLASH2) {
          return to.slice(toStart + i2 + 1);
        } else if (i2 === 0) {
          return to.slice(toStart + i2);
        }
      } else if (fromLen > length) {
        if (from.charCodeAt(fromStart + i2) === CHAR_FORWARD_SLASH2) {
          lastCommonSep = i2;
        } else if (i2 === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_FORWARD_SLASH2)
      lastCommonSep = i2;
  }
  let out = "";
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || from.charCodeAt(i2) === CHAR_FORWARD_SLASH2) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH2)
      ++toStart;
    return to.slice(toStart);
  }
}
function toNamespacedPath5(path10) {
  return path10;
}
function dirname5(path10) {
  assertPath2(path10);
  if (path10.length === 0)
    return ".";
  const hasRoot = path10.charCodeAt(0) === CHAR_FORWARD_SLASH2;
  let end = -1;
  let matchedSlash = true;
  for (let i2 = path10.length - 1; i2 >= 1; --i2) {
    if (path10.charCodeAt(i2) === CHAR_FORWARD_SLASH2) {
      if (!matchedSlash) {
        end = i2;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path10.slice(0, end);
}
function basename5(path10, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath2(path10);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i2;
  if (ext !== void 0 && ext.length > 0 && ext.length <= path10.length) {
    if (ext.length === path10.length && ext === path10)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i2 = path10.length - 1; i2 >= 0; --i2) {
      const code2 = path10.charCodeAt(i2);
      if (code2 === CHAR_FORWARD_SLASH2) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i2 + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i2;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path10.length;
    return path10.slice(start, end);
  } else {
    for (i2 = path10.length - 1; i2 >= 0; --i2) {
      if (path10.charCodeAt(i2) === CHAR_FORWARD_SLASH2) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
    }
    if (end === -1)
      return "";
    return path10.slice(start, end);
  }
}
function extname5(path10) {
  assertPath2(path10);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i2 = path10.length - 1; i2 >= 0; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (code2 === CHAR_FORWARD_SLASH2) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT2) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path10.slice(startDot, end);
}
function format5(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(
      `The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`
    );
  }
  return _format2("/", pathObject);
}
function parse5(path10) {
  assertPath2(path10);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path10.length === 0)
    return ret;
  const isAbsolute15 = path10.charCodeAt(0) === CHAR_FORWARD_SLASH2;
  let start;
  if (isAbsolute15) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i2 = path10.length - 1;
  let preDotState = 0;
  for (; i2 >= start; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (code2 === CHAR_FORWARD_SLASH2) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT2) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute15) {
        ret.base = ret.name = path10.slice(1, end);
      } else {
        ret.base = ret.name = path10.slice(startPart, end);
      }
    }
  } else {
    if (startPart === 0 && isAbsolute15) {
      ret.name = path10.slice(1, startDot);
      ret.base = path10.slice(1, end);
    } else {
      ret.name = path10.slice(startPart, startDot);
      ret.base = path10.slice(startPart, end);
    }
    ret.ext = path10.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path10.slice(0, startPart - 1);
  else if (isAbsolute15)
    ret.dir = "/";
  return ret;
}
function fromFileUrl5(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return decodeURIComponent(
    url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  );
}
function toFileUrl5(path10) {
  if (!isAbsolute5(path10)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace2(
    path10.replace(/%/g, "%25").replace(/\\/g, "%5C")
  );
  return url;
}

// https://deno.land/std@0.133.0/path/glob.ts
var path3 = isWindows2 ? win32_exports2 : posix_exports2;
var { join: join7, normalize: normalize7 } = path3;

// https://deno.land/std@0.133.0/path/mod.ts
var path4 = isWindows2 ? win32_exports2 : posix_exports2;
var {
  basename: basename6,
  delimiter: delimiter6,
  dirname: dirname6,
  extname: extname6,
  format: format6,
  fromFileUrl: fromFileUrl6,
  isAbsolute: isAbsolute6,
  join: join8,
  normalize: normalize8,
  parse: parse6,
  relative: relative6,
  resolve: resolve6,
  sep: sep6,
  toFileUrl: toFileUrl6,
  toNamespacedPath: toNamespacedPath6
} = path4;

// https://deno.land/std@0.133.0/fs/_util.ts
function isSubdir(src, dest, sep15 = sep6) {
  if (src === dest) {
    return false;
  }
  const srcArray = src.split(sep15);
  const destArray = dest.split(sep15);
  return srcArray.every((current2, i2) => destArray[i2] === current2);
}
function getFileInfoType(fileInfo) {
  return fileInfo.isFile ? "file" : fileInfo.isDirectory ? "dir" : fileInfo.isSymlink ? "symlink" : void 0;
}

// https://deno.land/std@0.133.0/fs/ensure_dir.ts
async function ensureDir(dir) {
  try {
    const fileInfo = await Deno.lstat(dir);
    if (!fileInfo.isDirectory) {
      throw new Error(
        `Ensure path exists, expected 'dir', got '${getFileInfoType(fileInfo)}'`
      );
    }
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      await Deno.mkdir(dir, { recursive: true });
      return;
    }
    throw err;
  }
}

// https://deno.land/std@0.133.0/fs/exists.ts
async function exists(filePath) {
  try {
    await Deno.lstat(filePath);
    return true;
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return false;
    }
    throw err;
  }
}
function existsSync(filePath) {
  try {
    Deno.lstatSync(filePath);
    return true;
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return false;
    }
    throw err;
  }
}

// https://deno.land/std@0.133.0/fs/move.ts
async function move(src, dest, { overwrite = false } = {}) {
  const srcStat = await Deno.stat(src);
  if (srcStat.isDirectory && isSubdir(src, dest)) {
    throw new Error(
      `Cannot move '${src}' to a subdirectory of itself, '${dest}'.`
    );
  }
  if (overwrite) {
    if (await exists(dest)) {
      await Deno.remove(dest, { recursive: true });
    }
  } else {
    if (await exists(dest)) {
      throw new Error("dest already exists.");
    }
  }
  await Deno.rename(src, dest);
  return;
}
function moveSync(src, dest, { overwrite = false } = {}) {
  const srcStat = Deno.statSync(src);
  if (srcStat.isDirectory && isSubdir(src, dest)) {
    throw new Error(
      `Cannot move '${src}' to a subdirectory of itself, '${dest}'.`
    );
  }
  if (overwrite) {
    if (existsSync(dest)) {
      Deno.removeSync(dest, { recursive: true });
    }
  } else {
    if (existsSync(dest)) {
      throw new Error("dest already exists.");
    }
  }
  Deno.renameSync(src, dest);
}

// https://deno.land/std@0.133.0/_deno_unstable.ts
function utime(...args) {
  if (typeof Deno.utime == "function") {
    return Deno.utime(...args);
  } else {
    return Promise.reject(new TypeError("Requires --unstable"));
  }
}

// https://deno.land/std@0.133.0/fs/copy.ts
async function ensureValidCopy(src, dest, options) {
  let destStat;
  try {
    destStat = await Deno.lstat(dest);
  } catch (err) {
    if (err instanceof Deno.errors.NotFound) {
      return;
    }
    throw err;
  }
  if (options.isFolder && !destStat.isDirectory) {
    throw new Error(
      `Cannot overwrite non-directory '${dest}' with directory '${src}'.`
    );
  }
  if (!options.overwrite) {
    throw new Error(`'${dest}' already exists.`);
  }
  return destStat;
}
async function copyFile(src, dest, options) {
  await ensureValidCopy(src, dest, options);
  await Deno.copyFile(src, dest);
  if (options.preserveTimestamps) {
    const statInfo = await Deno.stat(src);
    assert3(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
    assert3(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
    await utime(dest, statInfo.atime, statInfo.mtime);
  }
}
async function copySymLink(src, dest, options) {
  await ensureValidCopy(src, dest, options);
  const originSrcFilePath = await Deno.readLink(src);
  const type = getFileInfoType(await Deno.lstat(src));
  if (isWindows2) {
    await Deno.symlink(originSrcFilePath, dest, {
      type: type === "dir" ? "dir" : "file"
    });
  } else {
    await Deno.symlink(originSrcFilePath, dest);
  }
  if (options.preserveTimestamps) {
    const statInfo = await Deno.lstat(src);
    assert3(statInfo.atime instanceof Date, `statInfo.atime is unavailable`);
    assert3(statInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
    await utime(dest, statInfo.atime, statInfo.mtime);
  }
}
async function copyDir(src, dest, options) {
  const destStat = await ensureValidCopy(src, dest, {
    ...options,
    isFolder: true
  });
  if (!destStat) {
    await ensureDir(dest);
  }
  if (options.preserveTimestamps) {
    const srcStatInfo = await Deno.stat(src);
    assert3(srcStatInfo.atime instanceof Date, `statInfo.atime is unavailable`);
    assert3(srcStatInfo.mtime instanceof Date, `statInfo.mtime is unavailable`);
    await utime(dest, srcStatInfo.atime, srcStatInfo.mtime);
  }
  for await (const entry of Deno.readDir(src)) {
    const srcPath = join8(src, entry.name);
    const destPath = join8(dest, basename6(srcPath));
    if (entry.isSymlink) {
      await copySymLink(srcPath, destPath, options);
    } else if (entry.isDirectory) {
      await copyDir(srcPath, destPath, options);
    } else if (entry.isFile) {
      await copyFile(srcPath, destPath, options);
    }
  }
}
async function copy(src, dest, options = {}) {
  src = resolve6(src);
  dest = resolve6(dest);
  if (src === dest) {
    throw new Error("Source and destination cannot be the same.");
  }
  const srcStat = await Deno.lstat(src);
  if (srcStat.isDirectory && isSubdir(src, dest)) {
    throw new Error(
      `Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`
    );
  }
  if (srcStat.isSymlink) {
    await copySymLink(src, dest, options);
  } else if (srcStat.isDirectory) {
    await copyDir(src, dest, options);
  } else if (srcStat.isFile) {
    await copyFile(src, dest, options);
  }
}

// https://deno.land/x/good@1.1.1.2/string.js
var findAll = (regexPattern, sourceString) => {
  var output2 = [];
  var match;
  var regexPatternWithGlobal = regexPattern.global ? regexPattern : RegExp(regexPattern, regexPattern.flags + "g");
  while (match = regexPatternWithGlobal.exec(sourceString)) {
    output2.push(match);
    if (match[0].length == 0) {
      regexPatternWithGlobal.lastIndex += 1;
    }
  }
  return output2;
};

// https://deno.land/x/good@1.1.1.2/value.js
var typedArrayClasses3 = [
  Uint16Array,
  Uint32Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Int32Array,
  Int8Array,
  Float32Array,
  Float64Array,
  globalThis.BigInt64Array,
  globalThis.BigUint64Array
].filter((each2) => each2);
var copyableClasses3 = /* @__PURE__ */ new Set([RegExp, Date, URL, ...typedArrayClasses3, globalThis.ArrayBuffer, globalThis.DataView]);
var IteratorPrototype3 = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
var ArrayIterator3 = Object.getPrototypeOf([][Symbol.iterator]);
var MapIterator3 = Object.getPrototypeOf((/* @__PURE__ */ new Map())[Symbol.iterator]);
var SetIterator3 = Object.getPrototypeOf((/* @__PURE__ */ new Set())[Symbol.iterator]);
var AsyncFunction3 = class {
};
var GeneratorFunction3 = class {
};
var AsyncGeneratorFunction3 = class {
};
var SyncGenerator3 = class {
};
var AsyncGenerator3 = class {
};
try {
  AsyncFunction3 = eval("(async function(){}).constructor");
  GeneratorFunction3 = eval("(function*(){}).constructor");
  AsyncGeneratorFunction3 = eval("(async function*(){}).constructor");
  SyncGenerator3 = eval("((function*(){})()).constructor");
  AsyncGenerator3 = eval("((async function*(){})()).constructor");
} catch (error) {
}
var isPrimitive3 = (value) => !(value instanceof Object);
var isPureObject3 = (value) => value instanceof Object && Object.getPrototypeOf(value).constructor == Object;
var isPracticallyPrimitive3 = (value) => isPrimitive3(value) || value instanceof Date || value instanceof RegExp || value instanceof URL;
var isBuiltInIterator3 = (value) => IteratorPrototype3.isPrototypeOf(value);
var isGeneratorType3 = (value) => {
  if (value instanceof Object) {
    if (isBuiltInIterator3(value)) {
      return true;
    }
    const constructor = value.constructor;
    return constructor == SyncGenerator3 || constructor == AsyncGenerator3;
  }
  return false;
};
var isAsyncIterable3 = function(value) {
  return value && typeof value[Symbol.asyncIterator] === "function";
};
var isSyncIterable3 = function(value) {
  return value && typeof value[Symbol.iterator] === "function";
};
var isTechnicallyIterable3 = function(value) {
  return value instanceof Object || typeof value == "string";
};
var isSyncIterableObjectOrContainer3 = function(value) {
  return value instanceof Object && typeof value[Symbol.iterator] == "function";
};
var deepCopySymbol3 = Symbol.for("deepCopy");
var clonedFromSymbol3 = Symbol();
var getThis3 = Symbol();
Object.getPrototypeOf(function() {
})[getThis3] = function() {
  return this;
};
function deepCopyInner3(value, valueChain = [], originalToCopyMap = /* @__PURE__ */ new Map()) {
  valueChain.push(value);
  if (value == null) {
    return value;
  }
  if (!(value instanceof Object)) {
    return value;
  }
  if (originalToCopyMap.has(value)) {
    return originalToCopyMap.get(value);
  }
  if (value[deepCopySymbol3] instanceof Function) {
    const clonedValue = value[deepCopySymbol3](originalToCopyMap);
    originalToCopyMap.set(value, clonedValue);
    return clonedValue;
  }
  if (isGeneratorType3(value)) {
    throw Error(`Sadly built-in generators cannot be deep copied.
And I found a generator along this path:
${valueChain.reverse().map((each2) => `${each2},
`)}`);
  }
  let object, theThis, thisCopy;
  if (value instanceof Date) {
    object = new Date(value.getTime());
  } else if (value instanceof RegExp) {
    object = new RegExp(value);
  } else if (value instanceof URL) {
    object = new URL(value);
  } else if (value instanceof Function) {
    theThis = value[getThis3]();
    object = value.bind(theThis);
  } else if (copyableClasses3.has(value.constructor)) {
    object = new value.constructor(value);
  } else if (value instanceof Array) {
    object = [];
  } else if (value instanceof Set) {
    object = /* @__PURE__ */ new Set();
  } else if (value instanceof Map) {
    object = /* @__PURE__ */ new Map();
  }
  originalToCopyMap.set(value, object);
  if (object instanceof Function) {
    thisCopy = deepCopyInner3(theThis, valueChain, originalToCopyMap);
    object = object.bind(thisCopy);
  }
  const output2 = object;
  try {
    output2.constructor = value.constructor;
  } catch (error) {
  }
  Object.setPrototypeOf(output2, Object.getPrototypeOf(value));
  const propertyDefinitions = {};
  for (const [key, description] of Object.entries(Object.getOwnPropertyDescriptors(value))) {
    const { value: value2, get, set: set2, ...options } = description;
    const getIsFunc = get instanceof Function;
    const setIsFunc = set2 instanceof Function;
    if (getIsFunc || setIsFunc) {
      propertyDefinitions[key] = {
        ...options,
        get: get ? function(...args) {
          return get.apply(output2, args);
        } : void 0,
        set: set2 ? function(...args) {
          return set2.apply(output2, args);
        } : void 0
      };
    } else {
      if (key == "length" && output2 instanceof Array) {
        continue;
      }
      propertyDefinitions[key] = {
        ...options,
        value: deepCopyInner3(value2, valueChain, originalToCopyMap)
      };
    }
  }
  Object.defineProperties(output2, propertyDefinitions);
  return output2;
}
var deepCopy3 = (value) => deepCopyInner3(value);
var shallowSortObject3 = (obj) => {
  return Object.keys(obj).sort().reduce(
    (newObj, key) => {
      newObj[key] = obj[key];
      return newObj;
    },
    {}
  );
};
var deepSortObject3 = (obj, seen = /* @__PURE__ */ new Map()) => {
  if (!(obj instanceof Object)) {
    return obj;
  } else if (seen.has(obj)) {
    return seen.get(obj);
  } else {
    if (obj instanceof Array) {
      const sortedChildren = [];
      seen.set(obj, sortedChildren);
      for (const each2 of obj) {
        sortedChildren.push(deepSortObject3(each2, seen));
      }
      return sortedChildren;
    } else {
      const sorted = {};
      seen.set(obj, sorted);
      for (const eachKey of Object.keys(obj).sort()) {
        sorted[eachKey] = deepSortObject3(obj[eachKey], seen);
      }
      return sorted;
    }
  }
};
var stableStringify3 = (value, ...args) => {
  return JSON.stringify(deepSortObject3(value), ...args);
};
var allKeys3 = function(obj) {
  let keys = [];
  if (obj == null) {
    return [];
  }
  if (!(obj instanceof Object)) {
    obj = Object.getPrototypeOf(obj);
  }
  while (obj) {
    keys = keys.concat(Reflect.ownKeys(obj));
    obj = Object.getPrototypeOf(obj);
  }
  return keys;
};
var ownKeyDescriptions3 = Object.getOwnPropertyDescriptors;
var allKeyDescriptions3 = function(value, options = { includingBuiltin: false }) {
  var { includingBuiltin } = { ...options };
  let descriptions = [];
  if (value == null) {
    return {};
  }
  if (!(value instanceof Object)) {
    value = Object.getPrototypeOf(value);
  }
  const rootPrototype = Object.getPrototypeOf({});
  let prevObj;
  while (value && value != prevObj) {
    if (!includingBuiltin && value == rootPrototype) {
      break;
    }
    descriptions = descriptions.concat(Object.entries(Object.getOwnPropertyDescriptors(value)));
    prevObj = value;
    value = Object.getPrototypeOf(value);
  }
  descriptions.reverse();
  return Object.fromEntries(descriptions);
};

// https://deno.land/x/good@1.1.1.2/iterable.js
var Stop3 = Symbol("iterationStop");
async function asyncIteratorToList3(asyncIterator) {
  const results = [];
  for await (const each2 of asyncIterator) {
    results.push(each2);
  }
  return results;
}
var ERROR_WHILE_MAPPING_MESSAGE3 = "Threw while mapping.";
function concurrentlyTransform3({ iterator, transformFunction, poolLimit = null, awaitAll = false }) {
  poolLimit = poolLimit || concurrentlyTransform3.defaultPoolLimit;
  const res = new TransformStream({
    async transform(p, controller) {
      try {
        const s = await p;
        controller.enqueue(s);
      } catch (e) {
        if (e instanceof AggregateError && e.message == ERROR_WHILE_MAPPING_MESSAGE3) {
          controller.error(e);
        }
      }
    }
  });
  const mainPromise = (async () => {
    const writer = res.writable.getWriter();
    const executing = [];
    try {
      let index = 0;
      for await (const item of iterator) {
        const p = Promise.resolve().then(() => transformFunction(item, index));
        index++;
        writer.write(p);
        const e = p.then(() => executing.splice(executing.indexOf(e), 1));
        executing.push(e);
        if (executing.length >= poolLimit) {
          await Promise.race(executing);
        }
      }
      await Promise.all(executing);
      writer.close();
    } catch {
      const errors = [];
      for (const result2 of await Promise.allSettled(executing)) {
        if (result2.status == "rejected") {
          errors.push(result2.reason);
        }
      }
      writer.write(Promise.reject(
        new AggregateError(errors, ERROR_WHILE_MAPPING_MESSAGE3)
      )).catch(() => {
      });
    }
  })();
  const asyncIterator = res.readable[Symbol.asyncIterator]();
  if (!awaitAll) {
    return asyncIterator;
  } else {
    return mainPromise.then(() => asyncIteratorToList3(asyncIterator));
  }
}
concurrentlyTransform3.defaultPoolLimit = 40;

// https://deno.land/std@0.191.0/_util/os.ts
var osType3 = (() => {
  const { Deno: Deno4 } = globalThis;
  if (typeof Deno4?.build?.os === "string") {
    return Deno4.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows3 = osType3 === "windows";

// https://deno.land/std@0.191.0/path/win32.ts
var win32_exports3 = {};
__export(win32_exports3, {
  basename: () => basename7,
  delimiter: () => delimiter7,
  dirname: () => dirname7,
  extname: () => extname7,
  format: () => format7,
  fromFileUrl: () => fromFileUrl7,
  isAbsolute: () => isAbsolute7,
  join: () => join9,
  normalize: () => normalize9,
  parse: () => parse7,
  relative: () => relative7,
  resolve: () => resolve7,
  sep: () => sep7,
  toFileUrl: () => toFileUrl7,
  toNamespacedPath: () => toNamespacedPath7
});

// https://deno.land/std@0.191.0/path/_constants.ts
var CHAR_UPPERCASE_A3 = 65;
var CHAR_LOWERCASE_A3 = 97;
var CHAR_UPPERCASE_Z3 = 90;
var CHAR_LOWERCASE_Z3 = 122;
var CHAR_DOT3 = 46;
var CHAR_FORWARD_SLASH3 = 47;
var CHAR_BACKWARD_SLASH3 = 92;
var CHAR_COLON3 = 58;
var CHAR_QUESTION_MARK3 = 63;

// https://deno.land/std@0.191.0/path/_util.ts
function assertPath3(path10) {
  if (typeof path10 !== "string") {
    throw new TypeError(
      `Path must be a string. Received ${JSON.stringify(path10)}`
    );
  }
}
function isPosixPathSeparator3(code2) {
  return code2 === CHAR_FORWARD_SLASH3;
}
function isPathSeparator3(code2) {
  return isPosixPathSeparator3(code2) || code2 === CHAR_BACKWARD_SLASH3;
}
function isWindowsDeviceRoot3(code2) {
  return code2 >= CHAR_LOWERCASE_A3 && code2 <= CHAR_LOWERCASE_Z3 || code2 >= CHAR_UPPERCASE_A3 && code2 <= CHAR_UPPERCASE_Z3;
}
function normalizeString3(path10, allowAboveRoot, separator, isPathSeparator6) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i2 = 0, len = path10.length; i2 <= len; ++i2) {
    if (i2 < len)
      code2 = path10.charCodeAt(i2);
    else if (isPathSeparator6(code2))
      break;
    else
      code2 = CHAR_FORWARD_SLASH3;
    if (isPathSeparator6(code2)) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT3 || res.charCodeAt(res.length - 2) !== CHAR_DOT3) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i2;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path10.slice(lastSlash + 1, i2);
        else
          res = path10.slice(lastSlash + 1, i2);
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code2 === CHAR_DOT3 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format3(sep15, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base;
  if (base === sep15)
    return dir;
  if (dir === pathObject.root)
    return dir + base;
  return dir + sep15 + base;
}
var WHITESPACE_ENCODINGS3 = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace3(string2) {
  return string2.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS3[c] ?? c;
  });
}
function lastPathSegment(path10, isSep, start = 0) {
  let matchedNonSeparator = false;
  let end = path10.length;
  for (let i2 = path10.length - 1; i2 >= start; --i2) {
    if (isSep(path10.charCodeAt(i2))) {
      if (matchedNonSeparator) {
        start = i2 + 1;
        break;
      }
    } else if (!matchedNonSeparator) {
      matchedNonSeparator = true;
      end = i2 + 1;
    }
  }
  return path10.slice(start, end);
}
function stripTrailingSeparators(segment, isSep) {
  if (segment.length <= 1) {
    return segment;
  }
  let end = segment.length;
  for (let i2 = segment.length - 1; i2 > 0; i2--) {
    if (isSep(segment.charCodeAt(i2))) {
      end = i2;
    } else {
      break;
    }
  }
  return segment.slice(0, end);
}
function stripSuffix(name, suffix) {
  if (suffix.length >= name.length) {
    return name;
  }
  const lenDiff = name.length - suffix.length;
  for (let i2 = suffix.length - 1; i2 >= 0; --i2) {
    if (name.charCodeAt(lenDiff + i2) !== suffix.charCodeAt(i2)) {
      return name;
    }
  }
  return name.slice(0, -suffix.length);
}

// https://deno.land/std@0.191.0/_util/asserts.ts
var DenoStdInternalError3 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert4(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError3(msg);
  }
}

// https://deno.land/std@0.191.0/path/win32.ts
var sep7 = "\\";
var delimiter7 = ";";
function resolve7(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1; i2--) {
    let path10;
    const { Deno: Deno4 } = globalThis;
    if (i2 >= 0) {
      path10 = pathSegments[i2];
    } else if (!resolvedDevice) {
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path10 = Deno4.cwd();
    } else {
      if (typeof Deno4?.env?.get !== "function" || typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path10 = Deno4.cwd();
      if (path10 === void 0 || path10.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path10 = `${resolvedDevice}\\`;
      }
    }
    assertPath3(path10);
    const len = path10.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute15 = false;
    const code2 = path10.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator3(code2)) {
        isAbsolute15 = true;
        if (isPathSeparator3(path10.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator3(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            const firstPart = path10.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator3(path10.charCodeAt(j)))
                break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator3(path10.charCodeAt(j)))
                  break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path10.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path10.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot3(code2)) {
        if (path10.charCodeAt(1) === CHAR_COLON3) {
          device = path10.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator3(path10.charCodeAt(2))) {
              isAbsolute15 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator3(code2)) {
      rootEnd = 1;
      isAbsolute15 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path10.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute15;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString3(
    resolvedTail,
    !resolvedAbsolute,
    "\\",
    isPathSeparator3
  );
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize9(path10) {
  assertPath3(path10);
  const len = path10.length;
  if (len === 0)
    return ".";
  let rootEnd = 0;
  let device;
  let isAbsolute15 = false;
  const code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator3(code2)) {
      isAbsolute15 = true;
      if (isPathSeparator3(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator3(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          const firstPart = path10.slice(last, j);
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator3(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator3(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path10.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path10.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot3(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON3) {
        device = path10.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator3(path10.charCodeAt(2))) {
            isAbsolute15 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator3(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString3(
      path10.slice(rootEnd),
      !isAbsolute15,
      "\\",
      isPathSeparator3
    );
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute15)
    tail = ".";
  if (tail.length > 0 && isPathSeparator3(path10.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute15) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute15) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function isAbsolute7(path10) {
  assertPath3(path10);
  const len = path10.length;
  if (len === 0)
    return false;
  const code2 = path10.charCodeAt(0);
  if (isPathSeparator3(code2)) {
    return true;
  } else if (isWindowsDeviceRoot3(code2)) {
    if (len > 2 && path10.charCodeAt(1) === CHAR_COLON3) {
      if (isPathSeparator3(path10.charCodeAt(2)))
        return true;
    }
  }
  return false;
}
function join9(...paths) {
  const pathsCount = paths.length;
  if (pathsCount === 0)
    return ".";
  let joined;
  let firstPart = null;
  for (let i2 = 0; i2 < pathsCount; ++i2) {
    const path10 = paths[i2];
    assertPath3(path10);
    if (path10.length > 0) {
      if (joined === void 0)
        joined = firstPart = path10;
      else
        joined += `\\${path10}`;
    }
  }
  if (joined === void 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert4(firstPart != null);
  if (isPathSeparator3(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator3(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator3(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator3(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize9(joined);
}
function relative7(from, to) {
  assertPath3(from);
  assertPath3(to);
  if (from === to)
    return "";
  const fromOrig = resolve7(from);
  const toOrig = resolve7(to);
  if (fromOrig === toOrig)
    return "";
  from = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from === to)
    return "";
  let fromStart = 0;
  let fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH3)
      break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH3)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH3)
      break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH3)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length; ++i2) {
    if (i2 === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i2) === CHAR_BACKWARD_SLASH3) {
          return toOrig.slice(toStart + i2 + 1);
        } else if (i2 === 2) {
          return toOrig.slice(toStart + i2);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i2) === CHAR_BACKWARD_SLASH3) {
          lastCommonSep = i2;
        } else if (i2 === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_BACKWARD_SLASH3)
      lastCommonSep = i2;
  }
  if (i2 !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || from.charCodeAt(i2) === CHAR_BACKWARD_SLASH3) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH3)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function toNamespacedPath7(path10) {
  if (typeof path10 !== "string")
    return path10;
  if (path10.length === 0)
    return "";
  const resolvedPath = resolve7(path10);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH3) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH3) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== CHAR_QUESTION_MARK3 && code2 !== CHAR_DOT3) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot3(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === CHAR_COLON3 && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH3) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path10;
}
function dirname7(path10) {
  assertPath3(path10);
  const len = path10.length;
  if (len === 0)
    return ".";
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator3(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator3(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator3(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator3(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator3(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return path10;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot3(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON3) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator3(path10.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator3(code2)) {
    return path10;
  }
  for (let i2 = len - 1; i2 >= offset; --i2) {
    if (isPathSeparator3(path10.charCodeAt(i2))) {
      if (!matchedSlash) {
        end = i2;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return stripTrailingSeparators(path10.slice(0, end), isPosixPathSeparator3);
}
function basename7(path10, suffix = "") {
  assertPath3(path10);
  if (path10.length === 0)
    return path10;
  if (typeof suffix !== "string") {
    throw new TypeError(
      `Suffix must be a string. Received ${JSON.stringify(suffix)}`
    );
  }
  let start = 0;
  if (path10.length >= 2) {
    const drive = path10.charCodeAt(0);
    if (isWindowsDeviceRoot3(drive)) {
      if (path10.charCodeAt(1) === CHAR_COLON3)
        start = 2;
    }
  }
  const lastSegment = lastPathSegment(path10, isPathSeparator3, start);
  const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator3);
  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function extname7(path10) {
  assertPath3(path10);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path10.length >= 2 && path10.charCodeAt(1) === CHAR_COLON3 && isWindowsDeviceRoot3(path10.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i2 = path10.length - 1; i2 >= start; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (isPathSeparator3(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT3) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path10.slice(startDot, end);
}
function format7(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(
      `The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`
    );
  }
  return _format3("\\", pathObject);
}
function parse7(path10) {
  assertPath3(path10);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  const len = path10.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator3(code2)) {
      rootEnd = 1;
      if (isPathSeparator3(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator3(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator3(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator3(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot3(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON3) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator3(path10.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path10;
              ret.base = "\\";
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path10;
          return ret;
        }
      }
    }
  } else if (isPathSeparator3(code2)) {
    ret.root = ret.dir = path10;
    ret.base = "\\";
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path10.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i2 = path10.length - 1;
  let preDotState = 0;
  for (; i2 >= rootEnd; --i2) {
    code2 = path10.charCodeAt(i2);
    if (isPathSeparator3(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT3) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path10.slice(startPart, end);
    }
  } else {
    ret.name = path10.slice(startPart, startDot);
    ret.base = path10.slice(startPart, end);
    ret.ext = path10.slice(startDot, end);
  }
  ret.base = ret.base || "\\";
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path10.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}
function fromFileUrl7(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  let path10 = decodeURIComponent(
    url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  ).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname != "") {
    path10 = `\\\\${url.hostname}${path10}`;
  }
  return path10;
}
function toFileUrl7(path10) {
  if (!isAbsolute7(path10)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path10.match(
    /^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/
  );
  const url = new URL("file:///");
  url.pathname = encodeWhitespace3(pathname.replace(/%/g, "%25"));
  if (hostname != null && hostname != "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}

// https://deno.land/std@0.191.0/path/posix.ts
var posix_exports3 = {};
__export(posix_exports3, {
  basename: () => basename8,
  delimiter: () => delimiter8,
  dirname: () => dirname8,
  extname: () => extname8,
  format: () => format8,
  fromFileUrl: () => fromFileUrl8,
  isAbsolute: () => isAbsolute8,
  join: () => join10,
  normalize: () => normalize10,
  parse: () => parse8,
  relative: () => relative8,
  resolve: () => resolve8,
  sep: () => sep8,
  toFileUrl: () => toFileUrl8,
  toNamespacedPath: () => toNamespacedPath8
});
var sep8 = "/";
var delimiter8 = ":";
function resolve8(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    let path10;
    if (i2 >= 0)
      path10 = pathSegments[i2];
    else {
      const { Deno: Deno4 } = globalThis;
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path10 = Deno4.cwd();
    }
    assertPath3(path10);
    if (path10.length === 0) {
      continue;
    }
    resolvedPath = `${path10}/${resolvedPath}`;
    resolvedAbsolute = isPosixPathSeparator3(path10.charCodeAt(0));
  }
  resolvedPath = normalizeString3(
    resolvedPath,
    !resolvedAbsolute,
    "/",
    isPosixPathSeparator3
  );
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize10(path10) {
  assertPath3(path10);
  if (path10.length === 0)
    return ".";
  const isAbsolute15 = isPosixPathSeparator3(path10.charCodeAt(0));
  const trailingSeparator = isPosixPathSeparator3(
    path10.charCodeAt(path10.length - 1)
  );
  path10 = normalizeString3(path10, !isAbsolute15, "/", isPosixPathSeparator3);
  if (path10.length === 0 && !isAbsolute15)
    path10 = ".";
  if (path10.length > 0 && trailingSeparator)
    path10 += "/";
  if (isAbsolute15)
    return `/${path10}`;
  return path10;
}
function isAbsolute8(path10) {
  assertPath3(path10);
  return path10.length > 0 && isPosixPathSeparator3(path10.charCodeAt(0));
}
function join10(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i2 = 0, len = paths.length; i2 < len; ++i2) {
    const path10 = paths[i2];
    assertPath3(path10);
    if (path10.length > 0) {
      if (!joined)
        joined = path10;
      else
        joined += `/${path10}`;
    }
  }
  if (!joined)
    return ".";
  return normalize10(joined);
}
function relative8(from, to) {
  assertPath3(from);
  assertPath3(to);
  if (from === to)
    return "";
  from = resolve8(from);
  to = resolve8(to);
  if (from === to)
    return "";
  let fromStart = 1;
  const fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (!isPosixPathSeparator3(from.charCodeAt(fromStart)))
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (!isPosixPathSeparator3(to.charCodeAt(toStart)))
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length; ++i2) {
    if (i2 === length) {
      if (toLen > length) {
        if (isPosixPathSeparator3(to.charCodeAt(toStart + i2))) {
          return to.slice(toStart + i2 + 1);
        } else if (i2 === 0) {
          return to.slice(toStart + i2);
        }
      } else if (fromLen > length) {
        if (isPosixPathSeparator3(from.charCodeAt(fromStart + i2))) {
          lastCommonSep = i2;
        } else if (i2 === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode)
      break;
    else if (isPosixPathSeparator3(fromCode))
      lastCommonSep = i2;
  }
  let out = "";
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || isPosixPathSeparator3(from.charCodeAt(i2))) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (isPosixPathSeparator3(to.charCodeAt(toStart)))
      ++toStart;
    return to.slice(toStart);
  }
}
function toNamespacedPath8(path10) {
  return path10;
}
function dirname8(path10) {
  if (path10.length === 0)
    return ".";
  let end = -1;
  let matchedNonSeparator = false;
  for (let i2 = path10.length - 1; i2 >= 1; --i2) {
    if (isPosixPathSeparator3(path10.charCodeAt(i2))) {
      if (matchedNonSeparator) {
        end = i2;
        break;
      }
    } else {
      matchedNonSeparator = true;
    }
  }
  if (end === -1) {
    return isPosixPathSeparator3(path10.charCodeAt(0)) ? "/" : ".";
  }
  return stripTrailingSeparators(
    path10.slice(0, end),
    isPosixPathSeparator3
  );
}
function basename8(path10, suffix = "") {
  assertPath3(path10);
  if (path10.length === 0)
    return path10;
  if (typeof suffix !== "string") {
    throw new TypeError(
      `Suffix must be a string. Received ${JSON.stringify(suffix)}`
    );
  }
  const lastSegment = lastPathSegment(path10, isPosixPathSeparator3);
  const strippedSegment = stripTrailingSeparators(
    lastSegment,
    isPosixPathSeparator3
  );
  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function extname8(path10) {
  assertPath3(path10);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i2 = path10.length - 1; i2 >= 0; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (isPosixPathSeparator3(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT3) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path10.slice(startDot, end);
}
function format8(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(
      `The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`
    );
  }
  return _format3("/", pathObject);
}
function parse8(path10) {
  assertPath3(path10);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path10.length === 0)
    return ret;
  const isAbsolute15 = isPosixPathSeparator3(path10.charCodeAt(0));
  let start;
  if (isAbsolute15) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i2 = path10.length - 1;
  let preDotState = 0;
  for (; i2 >= start; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (isPosixPathSeparator3(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT3) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute15) {
        ret.base = ret.name = path10.slice(1, end);
      } else {
        ret.base = ret.name = path10.slice(startPart, end);
      }
    }
    ret.base = ret.base || "/";
  } else {
    if (startPart === 0 && isAbsolute15) {
      ret.name = path10.slice(1, startDot);
      ret.base = path10.slice(1, end);
    } else {
      ret.name = path10.slice(startPart, startDot);
      ret.base = path10.slice(startPart, end);
    }
    ret.ext = path10.slice(startDot, end);
  }
  if (startPart > 0) {
    ret.dir = stripTrailingSeparators(
      path10.slice(0, startPart - 1),
      isPosixPathSeparator3
    );
  } else if (isAbsolute15)
    ret.dir = "/";
  return ret;
}
function fromFileUrl8(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return decodeURIComponent(
    url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  );
}
function toFileUrl8(path10) {
  if (!isAbsolute8(path10)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace3(
    path10.replace(/%/g, "%25").replace(/\\/g, "%5C")
  );
  return url;
}

// https://deno.land/std@0.191.0/path/glob.ts
var path5 = isWindows3 ? win32_exports3 : posix_exports3;
var { join: join11, normalize: normalize11 } = path5;
var regExpEscapeChars = [
  "!",
  "$",
  "(",
  ")",
  "*",
  "+",
  ".",
  "=",
  "?",
  "[",
  "\\",
  "^",
  "{",
  "|"
];
var rangeEscapeChars = ["-", "\\", "]"];
function globToRegExp2(glob3, {
  extended: extended2 = true,
  globstar: globstarOption = true,
  os = osType3,
  caseInsensitive = false
} = {}) {
  if (glob3 == "") {
    return /(?!)/;
  }
  const sep15 = os == "windows" ? "(?:\\\\|/)+" : "/+";
  const sepMaybe = os == "windows" ? "(?:\\\\|/)*" : "/*";
  const seps = os == "windows" ? ["\\", "/"] : ["/"];
  const globstar = os == "windows" ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*";
  const wildcard = os == "windows" ? "[^\\\\/]*" : "[^/]*";
  const escapePrefix = os == "windows" ? "`" : "\\";
  let newLength = glob3.length;
  for (; newLength > 1 && seps.includes(glob3[newLength - 1]); newLength--)
    ;
  glob3 = glob3.slice(0, newLength);
  let regExpString = "";
  for (let j = 0; j < glob3.length; ) {
    let segment = "";
    const groupStack = [];
    let inRange = false;
    let inEscape = false;
    let endsWithSep = false;
    let i2 = j;
    for (; i2 < glob3.length && !seps.includes(glob3[i2]); i2++) {
      if (inEscape) {
        inEscape = false;
        const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
        segment += escapeChars.includes(glob3[i2]) ? `\\${glob3[i2]}` : glob3[i2];
        continue;
      }
      if (glob3[i2] == escapePrefix) {
        inEscape = true;
        continue;
      }
      if (glob3[i2] == "[") {
        if (!inRange) {
          inRange = true;
          segment += "[";
          if (glob3[i2 + 1] == "!") {
            i2++;
            segment += "^";
          } else if (glob3[i2 + 1] == "^") {
            i2++;
            segment += "\\^";
          }
          continue;
        } else if (glob3[i2 + 1] == ":") {
          let k = i2 + 1;
          let value = "";
          while (glob3[k + 1] != null && glob3[k + 1] != ":") {
            value += glob3[k + 1];
            k++;
          }
          if (glob3[k + 1] == ":" && glob3[k + 2] == "]") {
            i2 = k + 2;
            if (value == "alnum")
              segment += "\\dA-Za-z";
            else if (value == "alpha")
              segment += "A-Za-z";
            else if (value == "ascii")
              segment += "\0-\x7F";
            else if (value == "blank")
              segment += "	 ";
            else if (value == "cntrl")
              segment += "\0-\x7F";
            else if (value == "digit")
              segment += "\\d";
            else if (value == "graph")
              segment += "!-~";
            else if (value == "lower")
              segment += "a-z";
            else if (value == "print")
              segment += " -~";
            else if (value == "punct") {
              segment += `!"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_\u2018{|}~`;
            } else if (value == "space")
              segment += "\\s\v";
            else if (value == "upper")
              segment += "A-Z";
            else if (value == "word")
              segment += "\\w";
            else if (value == "xdigit")
              segment += "\\dA-Fa-f";
            continue;
          }
        }
      }
      if (glob3[i2] == "]" && inRange) {
        inRange = false;
        segment += "]";
        continue;
      }
      if (inRange) {
        if (glob3[i2] == "\\") {
          segment += `\\\\`;
        } else {
          segment += glob3[i2];
        }
        continue;
      }
      if (glob3[i2] == ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
        segment += ")";
        const type = groupStack.pop();
        if (type == "!") {
          segment += wildcard;
        } else if (type != "@") {
          segment += type;
        }
        continue;
      }
      if (glob3[i2] == "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
        segment += "|";
        continue;
      }
      if (glob3[i2] == "+" && extended2 && glob3[i2 + 1] == "(") {
        i2++;
        groupStack.push("+");
        segment += "(?:";
        continue;
      }
      if (glob3[i2] == "@" && extended2 && glob3[i2 + 1] == "(") {
        i2++;
        groupStack.push("@");
        segment += "(?:";
        continue;
      }
      if (glob3[i2] == "?") {
        if (extended2 && glob3[i2 + 1] == "(") {
          i2++;
          groupStack.push("?");
          segment += "(?:";
        } else {
          segment += ".";
        }
        continue;
      }
      if (glob3[i2] == "!" && extended2 && glob3[i2 + 1] == "(") {
        i2++;
        groupStack.push("!");
        segment += "(?!";
        continue;
      }
      if (glob3[i2] == "{") {
        groupStack.push("BRACE");
        segment += "(?:";
        continue;
      }
      if (glob3[i2] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
        groupStack.pop();
        segment += ")";
        continue;
      }
      if (glob3[i2] == "," && groupStack[groupStack.length - 1] == "BRACE") {
        segment += "|";
        continue;
      }
      if (glob3[i2] == "*") {
        if (extended2 && glob3[i2 + 1] == "(") {
          i2++;
          groupStack.push("*");
          segment += "(?:";
        } else {
          const prevChar = glob3[i2 - 1];
          let numStars = 1;
          while (glob3[i2 + 1] == "*") {
            i2++;
            numStars++;
          }
          const nextChar = glob3[i2 + 1];
          if (globstarOption && numStars == 2 && [...seps, void 0].includes(prevChar) && [...seps, void 0].includes(nextChar)) {
            segment += globstar;
            endsWithSep = true;
          } else {
            segment += wildcard;
          }
        }
        continue;
      }
      segment += regExpEscapeChars.includes(glob3[i2]) ? `\\${glob3[i2]}` : glob3[i2];
    }
    if (groupStack.length > 0 || inRange || inEscape) {
      segment = "";
      for (const c of glob3.slice(j, i2)) {
        segment += regExpEscapeChars.includes(c) ? `\\${c}` : c;
        endsWithSep = false;
      }
    }
    regExpString += segment;
    if (!endsWithSep) {
      regExpString += i2 < glob3.length ? sep15 : sepMaybe;
      endsWithSep = true;
    }
    while (seps.includes(glob3[i2]))
      i2++;
    if (!(i2 > j)) {
      throw new Error("Assertion failure: i > j (potential infinite loop)");
    }
    j = i2;
  }
  regExpString = `^${regExpString}$`;
  return new RegExp(regExpString, caseInsensitive ? "i" : "");
}

// https://deno.land/std@0.191.0/bytes/copy.ts
function copy2(src, dst, off = 0) {
  off = Math.max(0, Math.min(off, dst.byteLength));
  const dstBytesAvailable = dst.byteLength - off;
  if (src.byteLength > dstBytesAvailable) {
    src = src.subarray(0, dstBytesAvailable);
  }
  dst.set(src, off);
  return src.byteLength;
}

// https://deno.land/std@0.191.0/io/buf_reader.ts
var DEFAULT_BUF_SIZE = 4096;
var MIN_BUF_SIZE = 16;
var MAX_CONSECUTIVE_EMPTY_READS = 100;
var CR = "\r".charCodeAt(0);
var LF = "\n".charCodeAt(0);
var BufferFullError = class extends Error {
  constructor(partial) {
    super("Buffer full");
    this.partial = partial;
  }
  name = "BufferFullError";
};
var PartialReadError = class extends Error {
  name = "PartialReadError";
  partial;
  constructor() {
    super("Encountered UnexpectedEof, data only partially read");
  }
};
var BufReader = class _BufReader {
  #buf;
  #rd;
  // Reader provided by caller.
  #r = 0;
  // buf read position.
  #w = 0;
  // buf write position.
  #eof = false;
  // private lastByte: number;
  // private lastCharSize: number;
  /** return new BufReader unless r is BufReader */
  static create(r, size = DEFAULT_BUF_SIZE) {
    return r instanceof _BufReader ? r : new _BufReader(r, size);
  }
  constructor(rd, size = DEFAULT_BUF_SIZE) {
    if (size < MIN_BUF_SIZE) {
      size = MIN_BUF_SIZE;
    }
    this.#reset(new Uint8Array(size), rd);
  }
  /** Returns the size of the underlying buffer in bytes. */
  size() {
    return this.#buf.byteLength;
  }
  buffered() {
    return this.#w - this.#r;
  }
  // Reads a new chunk into the buffer.
  #fill = async () => {
    if (this.#r > 0) {
      this.#buf.copyWithin(0, this.#r, this.#w);
      this.#w -= this.#r;
      this.#r = 0;
    }
    if (this.#w >= this.#buf.byteLength) {
      throw Error("bufio: tried to fill full buffer");
    }
    for (let i2 = MAX_CONSECUTIVE_EMPTY_READS; i2 > 0; i2--) {
      const rr = await this.#rd.read(this.#buf.subarray(this.#w));
      if (rr === null) {
        this.#eof = true;
        return;
      }
      assert4(rr >= 0, "negative read");
      this.#w += rr;
      if (rr > 0) {
        return;
      }
    }
    throw new Error(
      `No progress after ${MAX_CONSECUTIVE_EMPTY_READS} read() calls`
    );
  };
  /** Discards any buffered data, resets all state, and switches
   * the buffered reader to read from r.
   */
  reset(r) {
    this.#reset(this.#buf, r);
  }
  #reset = (buf, rd) => {
    this.#buf = buf;
    this.#rd = rd;
    this.#eof = false;
  };
  /** reads data into p.
   * It returns the number of bytes read into p.
   * The bytes are taken from at most one Read on the underlying Reader,
   * hence n may be less than len(p).
   * To read exactly len(p) bytes, use io.ReadFull(b, p).
   */
  async read(p) {
    let rr = p.byteLength;
    if (p.byteLength === 0)
      return rr;
    if (this.#r === this.#w) {
      if (p.byteLength >= this.#buf.byteLength) {
        const rr2 = await this.#rd.read(p);
        const nread = rr2 ?? 0;
        assert4(nread >= 0, "negative read");
        return rr2;
      }
      this.#r = 0;
      this.#w = 0;
      rr = await this.#rd.read(this.#buf);
      if (rr === 0 || rr === null)
        return rr;
      assert4(rr >= 0, "negative read");
      this.#w += rr;
    }
    const copied = copy2(this.#buf.subarray(this.#r, this.#w), p, 0);
    this.#r += copied;
    return copied;
  }
  /** reads exactly `p.length` bytes into `p`.
   *
   * If successful, `p` is returned.
   *
   * If the end of the underlying stream has been reached, and there are no more
   * bytes available in the buffer, `readFull()` returns `null` instead.
   *
   * An error is thrown if some bytes could be read, but not enough to fill `p`
   * entirely before the underlying stream reported an error or EOF. Any error
   * thrown will have a `partial` property that indicates the slice of the
   * buffer that has been successfully filled with data.
   *
   * Ported from https://golang.org/pkg/io/#ReadFull
   */
  async readFull(p) {
    let bytesRead = 0;
    while (bytesRead < p.length) {
      try {
        const rr = await this.read(p.subarray(bytesRead));
        if (rr === null) {
          if (bytesRead === 0) {
            return null;
          } else {
            throw new PartialReadError();
          }
        }
        bytesRead += rr;
      } catch (err) {
        if (err instanceof PartialReadError) {
          err.partial = p.subarray(0, bytesRead);
        }
        throw err;
      }
    }
    return p;
  }
  /** Returns the next byte [0, 255] or `null`. */
  async readByte() {
    while (this.#r === this.#w) {
      if (this.#eof)
        return null;
      await this.#fill();
    }
    const c = this.#buf[this.#r];
    this.#r++;
    return c;
  }
  /** readString() reads until the first occurrence of delim in the input,
   * returning a string containing the data up to and including the delimiter.
   * If ReadString encounters an error before finding a delimiter,
   * it returns the data read before the error and the error itself
   * (often `null`).
   * ReadString returns err != nil if and only if the returned data does not end
   * in delim.
   * For simple uses, a Scanner may be more convenient.
   */
  async readString(delim) {
    if (delim.length !== 1) {
      throw new Error("Delimiter should be a single character");
    }
    const buffer = await this.readSlice(delim.charCodeAt(0));
    if (buffer === null)
      return null;
    return new TextDecoder().decode(buffer);
  }
  /** `readLine()` is a low-level line-reading primitive. Most callers should
   * use `readString('\n')` instead or use a Scanner.
   *
   * `readLine()` tries to return a single line, not including the end-of-line
   * bytes. If the line was too long for the buffer then `more` is set and the
   * beginning of the line is returned. The rest of the line will be returned
   * from future calls. `more` will be false when returning the last fragment
   * of the line. The returned buffer is only valid until the next call to
   * `readLine()`.
   *
   * The text returned from ReadLine does not include the line end ("\r\n" or
   * "\n").
   *
   * When the end of the underlying stream is reached, the final bytes in the
   * stream are returned. No indication or error is given if the input ends
   * without a final line end. When there are no more trailing bytes to read,
   * `readLine()` returns `null`.
   *
   * Calling `unreadByte()` after `readLine()` will always unread the last byte
   * read (possibly a character belonging to the line end) even if that byte is
   * not part of the line returned by `readLine()`.
   */
  async readLine() {
    let line = null;
    try {
      line = await this.readSlice(LF);
    } catch (err) {
      let partial;
      if (err instanceof PartialReadError) {
        partial = err.partial;
        assert4(
          partial instanceof Uint8Array,
          "bufio: caught error from `readSlice()` without `partial` property"
        );
      }
      if (!(err instanceof BufferFullError)) {
        throw err;
      }
      partial = err.partial;
      if (!this.#eof && partial && partial.byteLength > 0 && partial[partial.byteLength - 1] === CR) {
        assert4(this.#r > 0, "bufio: tried to rewind past start of buffer");
        this.#r--;
        partial = partial.subarray(0, partial.byteLength - 1);
      }
      if (partial) {
        return { line: partial, more: !this.#eof };
      }
    }
    if (line === null) {
      return null;
    }
    if (line.byteLength === 0) {
      return { line, more: false };
    }
    if (line[line.byteLength - 1] == LF) {
      let drop = 1;
      if (line.byteLength > 1 && line[line.byteLength - 2] === CR) {
        drop = 2;
      }
      line = line.subarray(0, line.byteLength - drop);
    }
    return { line, more: false };
  }
  /** `readSlice()` reads until the first occurrence of `delim` in the input,
   * returning a slice pointing at the bytes in the buffer. The bytes stop
   * being valid at the next read.
   *
   * If `readSlice()` encounters an error before finding a delimiter, or the
   * buffer fills without finding a delimiter, it throws an error with a
   * `partial` property that contains the entire buffer.
   *
   * If `readSlice()` encounters the end of the underlying stream and there are
   * any bytes left in the buffer, the rest of the buffer is returned. In other
   * words, EOF is always treated as a delimiter. Once the buffer is empty,
   * it returns `null`.
   *
   * Because the data returned from `readSlice()` will be overwritten by the
   * next I/O operation, most clients should use `readString()` instead.
   */
  async readSlice(delim) {
    let s = 0;
    let slice2;
    while (true) {
      let i2 = this.#buf.subarray(this.#r + s, this.#w).indexOf(delim);
      if (i2 >= 0) {
        i2 += s;
        slice2 = this.#buf.subarray(this.#r, this.#r + i2 + 1);
        this.#r += i2 + 1;
        break;
      }
      if (this.#eof) {
        if (this.#r === this.#w) {
          return null;
        }
        slice2 = this.#buf.subarray(this.#r, this.#w);
        this.#r = this.#w;
        break;
      }
      if (this.buffered() >= this.#buf.byteLength) {
        this.#r = this.#w;
        const oldbuf = this.#buf;
        const newbuf = this.#buf.slice(0);
        this.#buf = newbuf;
        throw new BufferFullError(oldbuf);
      }
      s = this.#w - this.#r;
      try {
        await this.#fill();
      } catch (err) {
        if (err instanceof PartialReadError) {
          err.partial = slice2;
        }
        throw err;
      }
    }
    return slice2;
  }
  /** `peek()` returns the next `n` bytes without advancing the reader. The
   * bytes stop being valid at the next read call.
   *
   * When the end of the underlying stream is reached, but there are unread
   * bytes left in the buffer, those bytes are returned. If there are no bytes
   * left in the buffer, it returns `null`.
   *
   * If an error is encountered before `n` bytes are available, `peek()` throws
   * an error with the `partial` property set to a slice of the buffer that
   * contains the bytes that were available before the error occurred.
   */
  async peek(n) {
    if (n < 0) {
      throw Error("negative count");
    }
    let avail = this.#w - this.#r;
    while (avail < n && avail < this.#buf.byteLength && !this.#eof) {
      try {
        await this.#fill();
      } catch (err) {
        if (err instanceof PartialReadError) {
          err.partial = this.#buf.subarray(this.#r, this.#w);
        }
        throw err;
      }
      avail = this.#w - this.#r;
    }
    if (avail === 0 && this.#eof) {
      return null;
    } else if (avail < n && this.#eof) {
      return this.#buf.subarray(this.#r, this.#r + avail);
    } else if (avail < n) {
      throw new BufferFullError(this.#buf.subarray(this.#r, this.#w));
    }
    return this.#buf.subarray(this.#r, this.#r + n);
  }
};

// https://deno.land/std@0.191.0/bytes/concat.ts
function concat(...buf) {
  let length = 0;
  for (const b of buf) {
    length += b.length;
  }
  const output2 = new Uint8Array(length);
  let index = 0;
  for (const b of buf) {
    output2.set(b, index);
    index += b.length;
  }
  return output2;
}

// https://deno.land/std@0.191.0/io/read_lines.ts
async function* readLines(reader, decoderOpts) {
  const bufReader = new BufReader(reader);
  let chunks = [];
  const decoder3 = new TextDecoder(decoderOpts?.encoding, decoderOpts);
  while (true) {
    const res = await bufReader.readLine();
    if (!res) {
      if (chunks.length > 0) {
        yield decoder3.decode(concat(...chunks));
      }
      break;
    }
    chunks.push(res.line);
    if (!res.more) {
      yield decoder3.decode(concat(...chunks));
      chunks = [];
    }
  }
}

// https://deno.land/x/good@1.5.0.3/value.js
var typedArrayClasses4 = [
  Uint16Array,
  Uint32Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Int32Array,
  Int8Array,
  Float32Array,
  Float64Array,
  globalThis.BigInt64Array,
  globalThis.BigUint64Array
].filter((each2) => each2);
var copyableClasses4 = /* @__PURE__ */ new Set([RegExp, Date, URL, ...typedArrayClasses4, globalThis.ArrayBuffer, globalThis.DataView]);
var IteratorPrototype4 = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
var ArrayIterator4 = Object.getPrototypeOf([][Symbol.iterator]);
var MapIterator4 = Object.getPrototypeOf((/* @__PURE__ */ new Map())[Symbol.iterator]);
var SetIterator4 = Object.getPrototypeOf((/* @__PURE__ */ new Set())[Symbol.iterator]);
var AsyncFunction4 = class {
};
var GeneratorFunction4 = class {
};
var AsyncGeneratorFunction4 = class {
};
var SyncGenerator4 = class {
};
var AsyncGenerator4 = class {
};
try {
  AsyncFunction4 = eval("(async function(){}).constructor");
  GeneratorFunction4 = eval("(function*(){}).constructor");
  AsyncGeneratorFunction4 = eval("(async function*(){}).constructor");
  SyncGenerator4 = eval("((function*(){})()).constructor");
  AsyncGenerator4 = eval("((async function*(){})()).constructor");
} catch (error) {
}
var isPrimitive4 = (value) => !(value instanceof Object);
var isPureObject4 = (value) => value instanceof Object && Object.getPrototypeOf(value).constructor == Object;
var isPracticallyPrimitive4 = (value) => isPrimitive4(value) || value instanceof Date || value instanceof RegExp || value instanceof URL;
var isBuiltInIterator4 = (value) => IteratorPrototype4.isPrototypeOf(value);
var isGeneratorType4 = (value) => {
  if (value instanceof Object) {
    if (isBuiltInIterator4(value)) {
      return true;
    }
    const constructor = value.constructor;
    return constructor == SyncGenerator4 || constructor == AsyncGenerator4;
  }
  return false;
};
var isAsyncIterable4 = function(value) {
  return value && typeof value[Symbol.asyncIterator] === "function";
};
var isSyncIterable4 = function(value) {
  return value && typeof value[Symbol.iterator] === "function";
};
var isIterableObjectOrContainer2 = function(value) {
  return value instanceof Object && (typeof value[Symbol.iterator] == "function" || typeof value[Symbol.asyncIterator] === "function");
};
var isTechnicallyIterable4 = function(value) {
  return value instanceof Object || typeof value == "string";
};
var isSyncIterableObjectOrContainer4 = function(value) {
  return value instanceof Object && typeof value[Symbol.iterator] == "function";
};
var deepCopySymbol4 = Symbol.for("deepCopy");
var clonedFromSymbol4 = Symbol();
var getThis4 = Symbol();
Object.getPrototypeOf(function() {
})[getThis4] = function() {
  return this;
};
function deepCopyInner4(value, valueChain = [], originalToCopyMap = /* @__PURE__ */ new Map()) {
  valueChain.push(value);
  if (value == null) {
    return value;
  }
  if (!(value instanceof Object)) {
    return value;
  }
  if (originalToCopyMap.has(value)) {
    return originalToCopyMap.get(value);
  }
  if (value[deepCopySymbol4] instanceof Function) {
    const clonedValue = value[deepCopySymbol4](originalToCopyMap);
    originalToCopyMap.set(value, clonedValue);
    return clonedValue;
  }
  if (isGeneratorType4(value)) {
    throw Error(`Sadly built-in generators cannot be deep copied.
And I found a generator along this path:
${valueChain.reverse().map((each2) => `${each2},
`)}`);
  }
  let object, theThis, thisCopy;
  if (value instanceof Date) {
    object = new Date(value.getTime());
  } else if (value instanceof RegExp) {
    object = new RegExp(value);
  } else if (value instanceof URL) {
    object = new URL(value);
  } else if (value instanceof Function) {
    theThis = value[getThis4]();
    object = value.bind(theThis);
  } else if (copyableClasses4.has(value.constructor)) {
    object = new value.constructor(value);
  } else if (value instanceof Array) {
    object = [];
  } else if (value instanceof Set) {
    object = /* @__PURE__ */ new Set();
  } else if (value instanceof Map) {
    object = /* @__PURE__ */ new Map();
  }
  originalToCopyMap.set(value, object);
  if (object instanceof Function) {
    thisCopy = deepCopyInner4(theThis, valueChain, originalToCopyMap);
    object = object.bind(thisCopy);
  }
  const output2 = object;
  try {
    output2.constructor = value.constructor;
  } catch (error) {
  }
  Object.setPrototypeOf(output2, Object.getPrototypeOf(value));
  const propertyDefinitions = {};
  for (const [key, description] of Object.entries(Object.getOwnPropertyDescriptors(value))) {
    const { value: value2, get, set: set2, ...options } = description;
    const getIsFunc = get instanceof Function;
    const setIsFunc = set2 instanceof Function;
    if (getIsFunc || setIsFunc) {
      propertyDefinitions[key] = {
        ...options,
        get: get ? function(...args) {
          return get.apply(output2, args);
        } : void 0,
        set: set2 ? function(...args) {
          return set2.apply(output2, args);
        } : void 0
      };
    } else {
      if (key == "length" && output2 instanceof Array) {
        continue;
      }
      propertyDefinitions[key] = {
        ...options,
        value: deepCopyInner4(value2, valueChain, originalToCopyMap)
      };
    }
  }
  Object.defineProperties(output2, propertyDefinitions);
  return output2;
}
var deepCopy4 = (value) => deepCopyInner4(value);
var shallowSortObject4 = (obj) => {
  return Object.keys(obj).sort().reduce(
    (newObj, key) => {
      newObj[key] = obj[key];
      return newObj;
    },
    {}
  );
};
var deepSortObject4 = (obj, seen = /* @__PURE__ */ new Map()) => {
  if (!(obj instanceof Object)) {
    return obj;
  } else if (seen.has(obj)) {
    return seen.get(obj);
  } else {
    if (obj instanceof Array) {
      const sortedChildren = [];
      seen.set(obj, sortedChildren);
      for (const each2 of obj) {
        sortedChildren.push(deepSortObject4(each2, seen));
      }
      return sortedChildren;
    } else {
      const sorted = {};
      seen.set(obj, sorted);
      for (const eachKey of Object.keys(obj).sort()) {
        sorted[eachKey] = deepSortObject4(obj[eachKey], seen);
      }
      return sorted;
    }
  }
};
var stableStringify4 = (value, ...args) => {
  return JSON.stringify(deepSortObject4(value), ...args);
};
var allKeys4 = function(obj) {
  let keys = [];
  if (obj == null) {
    return [];
  }
  if (!(obj instanceof Object)) {
    obj = Object.getPrototypeOf(obj);
  }
  while (obj) {
    keys = keys.concat(Reflect.ownKeys(obj));
    obj = Object.getPrototypeOf(obj);
  }
  return keys;
};
var ownKeyDescriptions4 = Object.getOwnPropertyDescriptors;
var allKeyDescriptions4 = function(value, options = { includingBuiltin: false }) {
  var { includingBuiltin } = { ...options };
  let descriptions = [];
  if (value == null) {
    return {};
  }
  if (!(value instanceof Object)) {
    value = Object.getPrototypeOf(value);
  }
  const rootPrototype = Object.getPrototypeOf({});
  let prevObj;
  while (value && value != prevObj) {
    if (!includingBuiltin && value == rootPrototype) {
      break;
    }
    descriptions = descriptions.concat(Object.entries(Object.getOwnPropertyDescriptors(value)));
    prevObj = value;
    value = Object.getPrototypeOf(value);
  }
  descriptions.reverse();
  return Object.fromEntries(descriptions);
};

// https://deno.land/x/quickr@0.6.56/main/file_system.js
ensure({ denoVersion: "1.17.1" });
var cache3 = {};
var PathInfo = class {
  constructor({ path: path10, _lstatData, _statData }) {
    this.path = path10;
    this._lstat = _lstatData;
    this._data = _statData;
  }
  // 
  // core data sources
  // 
  refresh() {
    this._lstat = null;
    this._data = null;
  }
  get lstat() {
    if (!this._lstat) {
      try {
        this._lstat = Deno.lstatSync(this.path);
      } catch (error) {
        this._lstat = { doesntExist: true };
      }
    }
    return this._lstat;
  }
  get stat() {
    if (!this._stat) {
      const lstat = this.lstat;
      if (!lstat.isSymlink) {
        this._stat = {
          isBrokenLink: false,
          isLoopOfLinks: false
        };
      } else {
        try {
          this._stat = Deno.statSync(this.path);
        } catch (error) {
          this._stat = {};
          if (error.message.match(/^Too many levels of symbolic links/)) {
            this._stat.isBrokenLink = true;
            this._stat.isLoopOfLinks = true;
          } else if (error.message.match(/^No such file or directory/)) {
            this._stat.isBrokenLink = true;
          } else {
            throw error;
          }
        }
      }
    }
    return this._stat;
  }
  // 
  // main attributes
  // 
  get exists() {
    const lstat = this.lstat;
    return !lstat.doesntExist;
  }
  get name() {
    return parse3(this.path).name;
  }
  get extension() {
    return parse3(this.path).ext;
  }
  get basename() {
    return this.path && basename3(this.path);
  }
  get parentPath() {
    return this.path && dirname3(this.path);
  }
  relativePathFrom(parentPath) {
    return relative3(parentPath, this.path);
  }
  get link() {
    const lstat = this.lstat;
    if (lstat.isSymlink) {
      return Deno.readLinkSync(this.path);
    } else {
      return null;
    }
  }
  get isSymlink() {
    const lstat = this.lstat;
    return !!lstat.isSymlink;
  }
  get isRelativeSymlink() {
    const lstat = this.lstat;
    const isNotSymlink = !lstat.isSymlink;
    if (isNotSymlink) {
      return false;
    }
    const relativeOrAbsolutePath = Deno.readLinkSync(this.path);
    return !isAbsolute3(relativeOrAbsolutePath);
  }
  get isAbsoluteSymlink() {
    const lstat = this.lstat;
    const isNotSymlink = !lstat.isSymlink;
    if (isNotSymlink) {
      return false;
    }
    const relativeOrAbsolutePath = Deno.readLinkSync(this.path);
    return isAbsolute3(relativeOrAbsolutePath);
  }
  get isBrokenLink() {
    const stat = this.stat;
    return !!stat.isBrokenLink;
  }
  get isLoopOfLinks() {
    const stat = this.stat;
    return !!stat.isLoopOfLinks;
  }
  get isFile() {
    const lstat = this.lstat;
    if (lstat.doesntExist) {
      return false;
    }
    if (!lstat.isSymlink) {
      return lstat.isFile;
    } else {
      return !!this.stat.isFile;
    }
  }
  get isFolder() {
    const lstat = this.lstat;
    if (lstat.doesntExist) {
      return false;
    }
    if (!lstat.isSymlink) {
      return lstat.isDirectory;
    } else {
      return !!this.stat.isDirectory;
    }
  }
  get sizeInBytes() {
    const lstat = this.lstat;
    return lstat.size;
  }
  get permissions() {
    const { mode } = this.lstat;
    return {
      owner: {
        //          rwxrwxrwx
        canRead: !!(256 & mode),
        canWrite: !!(128 & mode),
        canExecute: !!(64 & mode)
      },
      group: {
        canRead: !!(32 & mode),
        canWrite: !!(16 & mode),
        canExecute: !!(8 & mode)
      },
      others: {
        canRead: !!(4 & mode),
        canWrite: !!(2 & mode),
        canExecute: !!(1 & mode)
      }
    };
  }
  // aliases
  get isDirectory() {
    return this.isFolder;
  }
  get dirname() {
    return this.parentPath;
  }
  toJSON() {
    return {
      exists: this.exists,
      name: this.name,
      extension: this.extension,
      basename: this.basename,
      parentPath: this.parentPath,
      isSymlink: this.isSymlink,
      isBrokenLink: this.isBrokenLink,
      isLoopOfLinks: this.isLoopOfLinks,
      isFile: this.isFile,
      isFolder: this.isFolder,
      sizeInBytes: this.sizeInBytes,
      permissions: this.permissions,
      isDirectory: this.isDirectory,
      dirname: this.dirname
    };
  }
};
var defaultOptionsHelper = (options) => ({
  renameExtension: options.renameExtension || FileSystem.defaultRenameExtension,
  overwrite: options.overwrite
});
var fileLockSymbol = Symbol.for("fileLock");
var locker = globalThis[fileLockSymbol] || {};
var grabPathLock = async (path10) => {
  while (locker[path10]) {
    await new Promise((resolve15) => setTimeout(resolve15, 70));
  }
  locker[path10] = true;
};
var pathStandardize = (path10) => {
  path10 = path10.path || path10;
  if (typeof path10 == "string" && path10.startsWith("file:///")) {
    path10 = fromFileUrl3(path10);
  }
  return path10;
};
var FileSystem = {
  defaultRenameExtension: ".old",
  denoExecutablePath: Deno.execPath(),
  parentPath: dirname3,
  dirname: dirname3,
  basename: basename3,
  extname: extname3,
  join: join4,
  normalize: (path10) => normalize4(pathStandardize(path10)).replace(/\/$/, ""),
  isAbsolutePath: isAbsolute3,
  isRelativePath: (...args) => !isAbsolute3(...args),
  makeRelativePath: ({ from, to }) => relative3(from.path || from, to.path || to),
  makeAbsolutePath: (path10) => {
    if (!isAbsolute3(path10)) {
      return normalize4(join4(Deno.cwd(), path10));
    } else {
      return normalize4(path10);
    }
  },
  pathDepth(path10) {
    path10 = FileSystem.normalize(path10);
    let count4 = 0;
    for (const eachChar of path10.path || path10) {
      if (eachChar == "/") {
        count4++;
      }
    }
    if (path10[0] == "/") {
      count4--;
    }
    return count4 + 1;
  },
  pathPieces(path10) {
    path10 = path10.path || path10;
    const result2 = parse3(path10);
    const folderList = [];
    let dirname15 = result2.dir;
    while (true) {
      folderList.push(basename3(dirname15));
      if (dirname15 == dirname3(dirname15)) {
        break;
      }
      dirname15 = dirname3(dirname15);
    }
    folderList.reverse();
    return [folderList, result2.name, result2.ext];
  },
  /**
   * add to name, preserve file extension
   *
   * @example
   * ```js
   * let newName = FileSystem.extendName({ path: "a/blah.thing.js", string: ".old" })
   * newName == "a/blah.old.thing.js"
   * ```
   *
   * @param arg1.path - item path
   * @param arg1.string - the string to append to the name
   * @return {string} - the new path
   */
  extendName({ path: path10, string: string2 }) {
    path10 = pathStandardize(path10);
    const [name, ...extensions] = basename3(path10).split(".");
    return `${dirname3(path10)}/${name}${string2}${extensions.length == 0 ? "" : `.${extensions.join(".")}`}`;
  },
  /**
   * All Parent Paths
   *
   * @param {String} path - path doesnt need to exist
   * @return {[String]} longest to shortest parent path
   */
  allParentPaths(path10) {
    const pathStartsWithDotSlash = path10.startsWith("./");
    path10 = FileSystem.normalize(path10);
    if (path10 === ".") {
      return [];
    }
    const dotGotRemoved = pathStartsWithDotSlash && !path10.startsWith("./");
    let previousPath = null;
    let allPaths = [];
    while (1) {
      previousPath = path10;
      path10 = FileSystem.parentPath(path10);
      if (previousPath === path10) {
        break;
      }
      allPaths.push(path10);
    }
    allPaths.reverse();
    allPaths = allPaths.filter((each2) => each2 != ".");
    if (dotGotRemoved) {
      allPaths.push(".");
    }
    return allPaths;
  },
  pathOfCaller(callerNumber = void 0) {
    const err = new Error();
    let filePaths = findAll(/^.+file:\/\/(\/[\w\W]*?):/gm, err.stack).map((each2) => each2[1]);
    if (callerNumber) {
      filePaths = filePaths.slice(callerNumber);
    }
    try {
      const secondPath = filePaths[1];
      if (secondPath) {
        try {
          if (Deno.statSync(secondPath).isFile) {
            return secondPath;
          }
        } catch (error) {
        }
      }
    } catch (error) {
    }
    return Deno.cwd();
  },
  get home() {
    if (!cache3.home) {
      if (Deno.build.os != "windows") {
        cache3.home = Deno.env.get("HOME");
      } else {
        cache3.home = Deno.env.get("HOMEPATH");
      }
    }
    return cache3.home;
  },
  get workingDirectory() {
    return Deno.cwd();
  },
  set workingDirectory(value) {
    Deno.chdir(value);
  },
  get cwd() {
    return FileSystem.workingDirectory;
  },
  set cwd(value) {
    return FileSystem.workingDirectory = value;
  },
  get pwd() {
    return FileSystem.cwd;
  },
  set pwd(value) {
    return FileSystem.cwd = value;
  },
  cd(path10) {
    Deno.chdir(path10);
  },
  changeDirectory(path10) {
    Deno.chdir(path10);
  },
  get thisFile() {
    const err = new Error();
    const filePaths = findAll(/^.+file:\/\/(\/[\w\W]*?):/gm, err.stack).map((each2) => each2[1]);
    const firstPath = filePaths[0];
    if (firstPath) {
      try {
        if (Deno.statSync(firstPath).isFile) {
          return firstPath;
        }
      } catch (error) {
      }
    }
    return ":<interpreter>:";
  },
  get thisFolder() {
    const err = new Error();
    const filePaths = findAll(/^.+file:\/\/(\/[\w\W]*?):/gm, err.stack).map((each2) => each2[1]);
    const firstPath = filePaths[0];
    if (firstPath) {
      try {
        if (Deno.statSync(firstPath).isFile) {
          return dirname3(firstPath);
        }
      } catch (error) {
      }
    }
    return Deno.cwd();
  },
  async read(path10) {
    path10 = pathStandardize(path10);
    await grabPathLock(path10);
    let output2;
    try {
      output2 = await Deno.readTextFile(path10);
    } catch (error) {
    }
    delete locker[path10];
    return output2;
  },
  async readBytes(path10) {
    path10 = pathStandardize(path10);
    await grabPathLock(path10);
    let output2;
    try {
      output2 = await Deno.readFile(path10);
    } catch (error) {
    }
    delete locker[path10];
    return output2;
  },
  async *readLinesIteratively(path10) {
    path10 = pathStandardize(path10);
    await grabPathLock(path10);
    try {
      const file = await Deno.open(path10);
      try {
        yield* readLines(file);
      } finally {
        Deno.close(file.rid);
      }
    } finally {
      delete locker[path10];
    }
  },
  async info(fileOrFolderPath, _cachedLstat = null) {
    fileOrFolderPath = pathStandardize(fileOrFolderPath);
    await grabPathLock(fileOrFolderPath);
    try {
      const lstat = _cachedLstat || await Deno.lstat(fileOrFolderPath).catch(() => ({ doesntExist: true }));
      let stat = {};
      if (!lstat.isSymlink) {
        stat = {
          isBrokenLink: false,
          isLoopOfLinks: false
        };
      } else {
        try {
          stat = await Deno.stat(fileOrFolderPath);
        } catch (error) {
          if (error.message.match(/^Too many levels of symbolic links/)) {
            stat.isBrokenLink = true;
            stat.isLoopOfLinks = true;
          } else if (error.message.match(/^No such file or directory/)) {
            stat.isBrokenLink = true;
          } else {
            if (!error.message.match(/^PermissionDenied:/)) {
              return { doesntExist: true, permissionDenied: true };
            }
            throw error;
          }
        }
      }
      return new PathInfo({ path: fileOrFolderPath, _lstatData: lstat, _statData: stat });
    } finally {
      delete locker[fileOrFolderPath];
    }
  },
  async move({ path: path10, item, newParentFolder, newName, force = true, overwrite = false, renameExtension = null }) {
    item = item || path10;
    const oldPath = item.path || item;
    const oldName = FileSystem.basename(oldPath);
    const pathInfo = item instanceof Object || FileSystem.sync.info(oldPath);
    const newPath = `${newParentFolder || FileSystem.parentPath(oldPath)}/${newName || oldName}`;
    if (pathInfo.isSymlink && !item.isBrokenLink) {
      const link2 = Deno.readLinkSync(pathInfo.path);
      if (!isAbsolute3(link2)) {
        const linkTargetBeforeMove = `${FileSystem.parentPath(pathInfo.path)}/${link2}`;
        await FileSystem.relativeLink({
          existingItem: linkTargetBeforeMove,
          newItem: newPath,
          force,
          overwrite,
          renameExtension
        });
        await FileSystem.remove(pathInfo);
      }
    }
    if (force) {
      FileSystem.sync.clearAPathFor(newPath, { overwrite, renameExtension });
    }
    await move(oldPath, newPath);
  },
  async remove(fileOrFolder) {
    fileOrFolder = pathStandardize(fileOrFolder);
    if (fileOrFolder instanceof Array) {
      return Promise.all(fileOrFolder.map(FileSystem.remove));
    }
    fileOrFolder = fileOrFolder.path || fileOrFolder;
    const pathInfo = await FileSystem.info(fileOrFolder);
    if (pathInfo.isFile || pathInfo.isSymlink) {
      return Deno.remove(pathInfo.path.replace(/\/+$/, ""));
    } else if (pathInfo.exists) {
      return Deno.remove(pathInfo.path.replace(/\/+$/, ""), { recursive: true });
    }
  },
  async finalTargetOf(path10, options = {}) {
    const { _parentsHaveBeenChecked, cache: cache6 } = { _parentsHaveBeenChecked: false, cache: {}, ...options };
    const originalWasItem = path10 instanceof PathInfo;
    path10 = path10.path || path10;
    let result2 = await Deno.lstat(path10).catch(() => ({ doesntExist: true }));
    if (result2.doesntExist) {
      return null;
    }
    path10 = await FileSystem.makeHardPathTo(path10, { cache: cache6 });
    const pathChain = [];
    while (result2.isSymlink) {
      const relativeOrAbsolutePath = await Deno.readLink(path10);
      if (isAbsolute3(relativeOrAbsolutePath)) {
        path10 = relativeOrAbsolutePath;
      } else {
        path10 = `${FileSystem.parentPath(path10)}/${relativeOrAbsolutePath}`;
      }
      result2 = await Deno.lstat(path10).catch(() => ({ doesntExist: true }));
      if (result2.doesntExist) {
        return null;
      }
      path10 = await FileSystem.makeHardPathTo(path10, { cache: cache6 });
      if (pathChain.includes(path10)) {
        return null;
      }
      pathChain.push(path10);
    }
    path10 = FileSystem.normalize(path10);
    if (originalWasItem) {
      return new PathInfo({ path: path10 });
    } else {
      return path10;
    }
  },
  async nextTargetOf(path10, options = {}) {
    const originalWasItem = path10 instanceof PathInfo;
    const item = originalWasItem ? path10 : new PathInfo({ path: path10 });
    const lstat = item.lstat;
    if (lstat.isSymlink) {
      const relativeOrAbsolutePath = Deno.readLinkSync(item.path);
      if (isAbsolute3(relativeOrAbsolutePath)) {
        if (originalWasItem) {
          return new PathInfo({ path: relativeOrAbsolutePath });
        } else {
          return relativeOrAbsolutePath;
        }
      } else {
        const path11 = `${await FileSystem.makeHardPathTo(dirname3(item.path))}/${relativeOrAbsolutePath}`;
        if (originalWasItem) {
          return new PathInfo({ path: path11 });
        } else {
          return path11;
        }
      }
    } else {
      if (originalWasItem) {
        return item;
      } else {
        return item.path;
      }
    }
  },
  async ensureIsFile(path10, options = { overwrite: false, renameExtension: null }) {
    const { overwrite, renameExtension } = defaultOptionsHelper(options);
    await FileSystem.ensureIsFolder(FileSystem.parentPath(path10), { overwrite, renameExtension });
    path10 = path10.path || path10;
    const pathInfo = await FileSystem.info(path10);
    if (pathInfo.isFile && !pathInfo.isDirectory) {
      return path10;
    } else {
      await FileSystem.write({ path: path10, data: "" });
      return path10;
    }
  },
  async ensureIsFolder(path10, options = { overwrite: false, renameExtension: null }) {
    const { overwrite, renameExtension } = defaultOptionsHelper(options);
    path10 = path10.path || path10;
    path10 = FileSystem.makeAbsolutePath(path10);
    const parentPath = dirname3(path10);
    if (parentPath == path10) {
      return;
    }
    const parent = await FileSystem.info(parentPath);
    if (!parent.isDirectory) {
      FileSystem.sync.ensureIsFolder(parentPath, { overwrite, renameExtension });
    }
    let pathInfo = FileSystem.sync.info(path10);
    if (pathInfo.exists && !pathInfo.isDirectory) {
      if (overwrite) {
        await FileSystem.remove(path10);
      } else {
        await FileSystem.moveOutOfTheWay(eachPath, { extension: renameExtension });
      }
    }
    await Deno.mkdir(path10, { recursive: true });
    return path10;
  },
  /**
   * Move/Remove everything and Ensure parent folders
   *
   * @param path
   * @param options.overwrite - if false, then things in the way will be moved instead of deleted
   * @param options.renameExtension - the string to append when renaming files to get them out of the way
   * 
   * @note
   *     very agressive: will change whatever is necessary to make sure a parent exists
   * 
   * @example
   * ```js
   * await FileSystem.clearAPathFor("./something")
   * ```
   */
  async clearAPathFor(path10, options = { overwrite: false, renameExtension: null }) {
    const { overwrite, renameExtension } = defaultOptionsHelper(options);
    const originalPath = path10;
    const paths = [];
    while (dirname3(path10) !== path10) {
      paths.push(path10);
      path10 = dirname3(path10);
    }
    for (const eachPath2 of paths.reverse()) {
      const info = await FileSystem.info(eachPath2);
      if (!info.exists) {
        break;
      } else if (info.isFile) {
        if (overwrite) {
          await FileSystem.remove(eachPath2);
        } else {
          await FileSystem.moveOutOfTheWay(eachPath2, { extension: renameExtension });
        }
      }
    }
    await Deno.mkdir(dirname3(originalPath), { recursive: true });
    return originalPath;
  },
  async moveOutOfTheWay(path10, options = { extension: null }) {
    const extension = options?.extension || FileSystem.defaultRenameExtension;
    const info = await FileSystem.info(path10);
    if (info.exists) {
      const newPath = path10 + extension;
      await FileSystem.moveOutOfTheWay(newPath, { extension });
      await move(path10, newPath);
    }
  },
  /**
   * find a root folder based on a child path
   *
   * @example
   * ```js
   *     import { FileSystem } from "https://deno.land/x/quickr/main/file_system.js"
   * 
   *     var gitParentFolderOrNull = await FileSystem.walkUpUntil(".git")
   *     var gitParentFolderOrNull = await FileSystem.walkUpUntil({
   *         subPath:".git",
   *         startPath: FileSystem.pwd,
   *     })
   *
   *     // below will result in that^ same folder (assuming all your .git folders have config files)
   *     var gitParentFolderOrNull = await FileSystem.walkUpUntil(".git/config")
   * 
   *     // below will result in the same folder, but only if theres a local master branch
   *     var gitParentFolderOrNull = await FileSystem.walkUpUntil(".git/refs/heads/master")
   *```
   */
  async walkUpUntil(subPath, startPath = null) {
    subPath = subPath instanceof PathInfo ? subPath.path : subPath;
    if (subPath instanceof Object) {
      var { subPath, startPath } = subPath;
    }
    let here;
    if (!startPath) {
      here = Deno.cwd();
    } else if (isAbsolute3(startPath)) {
      here = startPath;
    } else {
      here = join4(here, startPath);
    }
    while (1) {
      let checkPath = join4(here, subPath);
      const pathInfo = await Deno.lstat(checkPath).catch(() => ({ doesntExist: true }));
      if (!pathInfo.doesntExist) {
        return here;
      }
      if (here == dirname3(here)) {
        return null;
      } else {
        here = dirname3(here);
      }
    }
  },
  // FIXME: make this work for folders with many options for how to handle symlinks
  async copy({ from, to, preserveTimestamps = true, force = true, overwrite = false, renameExtension = null }) {
    const existingItemDoesntExist = (await Deno.stat(from).catch(() => ({ doesntExist: true }))).doesntExist;
    if (existingItemDoesntExist) {
      throw Error(`
Tried to copy from:${from}, to:${to}
but "from" didn't seem to exist

`);
    }
    if (force) {
      FileSystem.sync.clearAPathFor(to, { overwrite, renameExtension });
    }
    return copy(from, to, { force, preserveTimestamps: true });
  },
  async relativeLink({ existingItem, newItem, force = true, overwrite = false, allowNonExistingTarget = false, renameExtension = null }) {
    const existingItemPath = (existingItem.path || existingItem).replace(/\/+$/, "");
    const newItemPath = FileSystem.normalize((newItem.path || newItem).replace(/\/+$/, ""));
    const existingItemDoesntExist = (await Deno.lstat(existingItemPath).catch(() => ({ doesntExist: true }))).doesntExist;
    if (!allowNonExistingTarget && existingItemDoesntExist) {
      throw Error(`
Tried to create a relativeLink between existingItem:${existingItemPath}, newItem:${newItemPath}
but existingItem didn't actually exist`);
    } else {
      const parentOfNewItem = FileSystem.parentPath(newItemPath);
      await FileSystem.ensureIsFolder(parentOfNewItem, { overwrite, renameExtension });
      const hardPathToNewItem = `${await FileSystem.makeHardPathTo(parentOfNewItem)}/${FileSystem.basename(newItemPath)}`;
      const hardPathToExistingItem = await FileSystem.makeHardPathTo(existingItemPath);
      const pathFromNewToExisting = relative3(hardPathToNewItem, hardPathToExistingItem).replace(/^\.\.\//, "");
      if (force) {
        FileSystem.sync.clearAPathFor(hardPathToNewItem, { overwrite, renameExtension });
      }
      return Deno.symlink(
        pathFromNewToExisting,
        hardPathToNewItem
      );
    }
  },
  async absoluteLink({ existingItem, newItem, force = true, allowNonExistingTarget = false, overwrite = false, renameExtension = null }) {
    existingItem = (existingItem.path || existingItem).replace(/\/+$/, "");
    const newItemPath = FileSystem.normalize(newItem.path || newItem).replace(/\/+$/, "");
    const existingItemDoesntExist = (await Deno.lstat(existingItem).catch(() => ({ doesntExist: true }))).doesntExist;
    if (!allowNonExistingTarget && existingItemDoesntExist) {
      throw Error(`
Tried to create a relativeLink between existingItem:${existingItem}, newItemPath:${newItemPath}
but existingItem didn't actually exist`);
    } else {
      const parentOfNewItem = FileSystem.parentPath(newItemPath);
      await FileSystem.ensureIsFolder(parentOfNewItem, { overwrite, renameExtension });
      const hardPathToNewItem = `${await FileSystem.makeHardPathTo(parentOfNewItem)}/${FileSystem.basename(newItemPath)}`;
      if (force) {
        FileSystem.sync.clearAPathFor(hardPathToNewItem, { overwrite, renameExtension });
      }
      return Deno.symlink(
        FileSystem.makeAbsolutePath(existingItem),
        newItemPath
      );
    }
  },
  async *iterateBasenamesIn(pathOrFileInfo) {
    const info = pathOrFileInfo instanceof PathInfo ? pathOrFileInfo : await FileSystem.info(pathOrFileInfo);
    if (info.isFolder) {
      for await (const dirEntry of Deno.readDir(info.path)) {
        yield dirEntry.name;
      }
    }
  },
  listBasenamesIn(pathOrFileInfo) {
    return asyncIteratorToList3(FileSystem.iterateBasenamesIn(pathOrFileInfo));
  },
  async *iteratePathsIn(pathOrFileInfo, options = { recursively: false, shouldntInclude: null, shouldntExplore: null, searchOrder: "breadthFirstSearch", maxDepth: Infinity, dontFollowSymlinks: false, dontReturnSymlinks: false, maxDepthFromRoot: null }) {
    let info;
    try {
      info = pathOrFileInfo instanceof PathInfo ? pathOrFileInfo : await FileSystem.info(pathOrFileInfo);
    } catch (error) {
      if (!error.message.match(/^PermissionDenied:/)) {
        throw error;
      }
    }
    const path10 = info.path;
    const startingDepth = FileSystem.makeAbsolutePath(path10).split("/").length - 1;
    options.recursively = options.recursively == false && options.maxDepth == 1 ? false : options.recursively;
    if (options.maxDepthFromRoot == null) {
      options.maxDepthFromRoot = Infinity;
    }
    if (options.maxDepth != Infinity && options.maxDepth != null) {
      options.maxDepthFromRoot = startingDepth + options.maxDepth;
    }
    options.maxDepth = null;
    if (startingDepth < options.maxDepthFromRoot) {
      if (!options.recursively) {
        if (info.isFolder) {
          if (!options.shouldntInclude) {
            for await (const each2 of Deno.readDir(path10)) {
              if (options.dontReturnSymlinks && each2.isSymlink) {
                continue;
              }
              yield join4(path10, each2.name);
            }
          } else {
            const shouldntInclude = options.shouldntInclude;
            for await (const each2 of Deno.readDir(path10)) {
              const eachPath2 = join4(path10, each2.name);
              if (options.dontReturnSymlinks && each2.isSymlink) {
                continue;
              }
              const shouldntIncludeThis = shouldntInclude && await shouldntInclude(eachPath2);
              if (!shouldntIncludeThis) {
                yield eachPath2;
              }
            }
          }
        }
      } else {
        options = { exclude: /* @__PURE__ */ new Set(), searchOrder: "breadthFirstSearch", maxDepth: Infinity, ...options };
        options.searchOrder = options.searchOrder || "breadthFirstSearch";
        const { shouldntExplore, shouldntInclude } = options;
        if (!["breadthFirstSearch", "depthFirstSearch"].includes(options.searchOrder)) {
          throw Error(`when calling FileSystem.iterateItemsIn('${path10}', { searchOrder: ${options.searchOrder} })

    The searchOrder currently can only be 'depthFirstSearch' or 'breadthFirstSearch'
    However, it was not either of those: ${options.searchOrder}`);
        }
        const useBreadthFirstSearch = options.searchOrder == "breadthFirstSearch";
        const shouldntExploreThis = shouldntExplore && await shouldntExplore(info.path, info);
        if (!shouldntExploreThis && info.isFolder) {
          options.exclude = options.exclude instanceof Set ? options.exclude : new Set(options.exclude);
          if (!options.exclude.has(path10)) {
            const followSymlinks = !options.dontFollowSymlinks;
            const absolutePathVersion = FileSystem.makeAbsolutePath(path10);
            options.exclude.add(absolutePathVersion);
            const searchAfterwords = [];
            for await (const entry of Deno.readDir(path10)) {
              const eachPath2 = join4(path10, entry.name);
              if (options.dontReturnSymlinks && each.isSymlink) {
                continue;
              }
              const shouldntIncludeThis = shouldntInclude && await shouldntInclude(eachPath2);
              if (!shouldntIncludeThis) {
                yield eachPath2;
              }
              if (entry.isFile) {
                continue;
              }
              if (followSymlinks && !entry.isDirectory) {
                let isSymlinkToDirectory = false;
                try {
                  isSymlinkToDirectory = (await Deno.stat(eachPath2)).isDirectory;
                } catch (error) {
                }
                if (!isSymlinkToDirectory) {
                  continue;
                }
              }
              if (useBreadthFirstSearch) {
                searchAfterwords.push(eachPath2);
              } else {
                for await (const eachSubPath of FileSystem.iteratePathsIn(eachPath2, options)) {
                  yield eachSubPath;
                }
              }
            }
            options.recursively = false;
            while (searchAfterwords.length > 0) {
              const next = searchAfterwords.shift();
              for await (const eachSubPath of FileSystem.iteratePathsIn(next, options)) {
                yield eachSubPath;
                searchAfterwords.push(eachSubPath);
              }
            }
          }
        }
      }
    }
  },
  listPathsIn(pathOrFileInfo, options) {
    return asyncIteratorToList3(FileSystem.iteratePathsIn(pathOrFileInfo, options));
  },
  async *iterateItemsIn(pathOrFileInfo, options = { recursively: false, shouldntInclude: null, shouldntExplore: null, searchOrder: "breadthFirstSearch", maxDepth: Infinity }) {
    options = { exclude: /* @__PURE__ */ new Set(), searchOrder: "breadthFirstSearch", maxDepth: Infinity, ...options };
    options.searchOrder = options.searchOrder || "breadthFirstSearch";
    options.recursively = options.recursively == false && options.maxDepth == 1 ? false : options.recursively;
    const { shouldntExplore, shouldntInclude } = options;
    const info = pathOrFileInfo instanceof PathInfo ? pathOrFileInfo : await FileSystem.info(pathOrFileInfo);
    const path10 = info.path;
    if (!["breadthFirstSearch", "depthFirstSearch"].includes(options.searchOrder)) {
      throw Error(`when calling FileSystem.iterateItemsIn('${path10}', { searchOrder: ${options.searchOrder} })

    The searchOrder currently can only be 'depthFirstSearch' or 'breadthFirstSearch'
    However, it was not either of those: ${options.searchOrder}`);
    }
    const useBreadthFirstSearch = options.searchOrder == "breadthFirstSearch";
    const shouldntExploreThis = shouldntExplore && await shouldntExplore(info);
    if (!shouldntExploreThis && options.maxDepth > 0 && info.isFolder) {
      options.exclude = options.exclude instanceof Set ? options.exclude : new Set(options.exclude);
      if (!options.exclude.has(path10)) {
        const absolutePathVersion = FileSystem.makeAbsolutePath(path10);
        options.exclude.add(absolutePathVersion);
        options.maxDepth -= 1;
        const searchAfterwords = [];
        for await (const entry of Deno.readDir(path10)) {
          const eachItem = await FileSystem.info(join4(path10, entry.name));
          const shouldntIncludeThis = shouldntInclude && await shouldntInclude(eachItem);
          if (!shouldntIncludeThis) {
            yield eachItem;
          }
          if (options.recursively) {
            if (eachItem.isFolder) {
              if (useBreadthFirstSearch) {
                searchAfterwords.push(eachItem);
              } else {
                for await (const eachSubPath of FileSystem.iterateItemsIn(eachItem, options)) {
                  yield eachSubPath;
                }
              }
            }
          }
        }
        options.recursively = false;
        while (searchAfterwords.length > 0) {
          const next = searchAfterwords.shift();
          for await (const eachSubItem of FileSystem.iterateItemsIn(next, options)) {
            yield eachSubItem;
            if (eachSubItem.isFolder) {
              searchAfterwords.push(eachSubItem);
            }
          }
        }
      }
    }
  },
  async listItemsIn(pathOrFileInfo, options) {
    const outputPromises = [];
    for await (const eachPath2 of FileSystem.iteratePathsIn(pathOrFileInfo, options)) {
      outputPromises.push(FileSystem.info(eachPath2));
    }
    return Promise.all(outputPromises);
  },
  // includes symlinks if they link to files and pipes
  async listFileItemsIn(pathOrFileInfo, options = { treatAllSymlinksAsFiles: false }) {
    const { treatAllSymlinksAsFiles } = { treatAllSymlinksAsFiles: false, ...options };
    const items = await FileSystem.listItemsIn(pathOrFileInfo, options);
    if (treatAllSymlinksAsFiles) {
      return items.filter((eachItem) => eachItem.isFile || treatAllSymlinksAsFiles && eachItem.isSymlink);
    } else {
      return items.filter((eachItem) => eachItem.isFile);
    }
  },
  async listFilePathsIn(pathOrFileInfo, options = { treatAllSymlinksAsFiles: false }) {
    return (await FileSystem.listFileItemsIn(pathOrFileInfo, options)).map((each2) => each2.path);
  },
  async listFileBasenamesIn(pathOrFileInfo, options = { treatAllSymlinksAsFiles: false }) {
    return (await FileSystem.listFileItemsIn(pathOrFileInfo, options)).map((each2) => each2.basename);
  },
  async listFolderItemsIn(pathOrFileInfo, options = { ignoreSymlinks: false }) {
    const { ignoreSymlinks } = { ignoreSymlinks: false, ...options };
    const items = await FileSystem.listItemsIn(pathOrFileInfo, options);
    if (ignoreSymlinks) {
      return items.filter((eachItem) => eachItem.isFolder && !eachItem.isSymlink);
    } else {
      return items.filter((eachItem) => eachItem.isFolder);
    }
  },
  async listFolderPathsIn(pathOrFileInfo, options = { ignoreSymlinks: false }) {
    return (await FileSystem.listFolderItemsIn(pathOrFileInfo, options)).map((each2) => each2.path);
  },
  async listFolderBasenamesIn(pathOrFileInfo, options = { ignoreSymlinks: false }) {
    return (await FileSystem.listFolderItemsIn(pathOrFileInfo, options)).map((each2) => each2.basename);
  },
  recursivelyIterateItemsIn(pathOrFileInfo, options = { onlyHardlinks: false, dontFollowSymlinks: false, searchOrder: "breadthFirstSearch", maxDepth: Infinity, shouldntExplore: null, shouldntInclude: null }) {
    options.recursively = true;
    if (options.onlyHardlinks) {
      if (options.shouldntInclude) {
        const originalshouldntInclude = options.shouldntInclude;
        options.shouldntInclude = (each2) => each2.isSymlink || originalshouldntInclude(each2);
      } else {
        options.shouldntInclude = (each2) => each2.isSymlink;
      }
    }
    if (options.dontFollowSymlinks) {
      if (options.shouldntExplore) {
        const originalShouldntExplore = options.shouldntInclude;
        options.shouldntExplore = (each2) => each2.isSymlink || originalShouldntExplore(each2);
      } else {
        options.shouldntExplore = (each2) => each2.isSymlink;
      }
    }
    return FileSystem.iterateItemsIn(pathOrFileInfo, options);
  },
  recursivelyIteratePathsIn(pathOrFileInfo, options = { onlyHardlinks: false, dontFollowSymlinks: false, searchOrder: "breadthFirstSearch", maxDepth: Infinity, shouldntExplore: null, shouldntInclude: null }) {
    options.recursively = true;
    if (options.onlyHardlinks) {
      if (options.shouldntInclude) {
        const originalshouldntInclude = options.shouldntInclude;
        options.shouldntInclude = (each2) => each2.isSymlink || originalshouldntInclude(each2);
      } else {
        options.shouldntInclude = (each2) => each2.isSymlink;
      }
    }
    return FileSystem.iteratePathsIn(pathOrFileInfo, options);
  },
  recursivelyListPathsIn(pathOrFileInfo, options = { onlyHardlinks: false, dontFollowSymlinks: false, searchOrder: "breadthFirstSearch", maxDepth: Infinity, shouldntExplore: null, shouldntInclude: null }) {
    return asyncIteratorToList3(FileSystem.recursivelyIteratePathsIn(pathOrFileInfo, options));
  },
  recursivelyListItemsIn(pathOrFileInfo, options = { onlyHardlinks: false, dontFollowSymlinks: false, searchOrder: "breadthFirstSearch", maxDepth: Infinity, shouldntExplore: null, shouldntInclude: null }) {
    return asyncIteratorToList3(FileSystem.recursivelyIterateItemsIn(pathOrFileInfo, options));
  },
  async *globIterator(pattern, options = { startPath: null }) {
    pattern = FileSystem.normalize(pattern);
    var { startPath, ...iteratePathsOptions } = options;
    startPath = startPath || "./";
    const originalStartPath = startPath;
    startPath = FileSystem.makeAbsolutePath(startPath);
    const firstGlob = pattern.indexOf("*");
    if (firstGlob != -1) {
      const startingString = pattern.slice(0, firstGlob);
      const furthestConstantSlash = startingString.lastIndexOf("/");
      if (furthestConstantSlash != -1) {
        if (pattern[0] == "/") {
          startPath = pattern.slice(0, furthestConstantSlash);
        } else {
          startPath = `${startPath}/${pattern.slice(0, furthestConstantSlash)}`;
        }
      }
      pattern = pattern.slice(furthestConstantSlash + 1);
    }
    let maxDepthFromRoot;
    if (pattern.match(/\*\*/)) {
      maxDepthFromRoot = Infinity;
    } else {
      maxDepthFromRoot = `${FileSystem.makeAbsolutePath(startPath)}/${pattern}`.split("/").length - 1;
    }
    const fullPattern = `${startPath}/${pattern}`;
    const regex3 = globToRegExp2(fullPattern);
    const partials = fullPattern.split("/");
    let partialPattern = partials.shift();
    let partialRegexString = `^\\.$|${globToRegExp2(partialPattern).source}`;
    for (const each2 of partials) {
      partialPattern += "/" + each2;
      partialRegexString += "|" + globToRegExp2(partialPattern).source;
    }
    const partialRegex = new RegExp(partialRegexString);
    for await (const eachPath2 of FileSystem.iteratePathsIn(startPath, { recursively: true, maxDepthFromRoot, ...iteratePathsOptions, shouldntExplore: (eachPath3) => !eachPath3.match(partialRegex) })) {
      if (eachPath2.match(regex3) || FileSystem.makeAbsolutePath(eachPath2).match(regex3)) {
        yield FileSystem.makeRelativePath({
          from: originalStartPath,
          to: eachPath2
        });
      }
    }
  },
  glob(pattern, options = { startPath: null }) {
    return asyncIteratorToList3(FileSystem.globIterator(pattern, options));
  },
  async getPermissions({ path: path10 }) {
    const { mode } = await Deno.lstat(path10);
    return {
      owner: {
        //          rwxrwxrwx
        canRead: !!(256 & mode),
        canWrite: !!(128 & mode),
        canExecute: !!(64 & mode)
      },
      group: {
        canRead: !!(32 & mode),
        canWrite: !!(16 & mode),
        canExecute: !!(8 & mode)
      },
      others: {
        canRead: !!(4 & mode),
        canWrite: !!(2 & mode),
        canExecute: !!(1 & mode)
      }
    };
  },
  /**
  * Add/set file permissions
  *
  * @param {String} args.path - 
  * @param {Object|Boolean} args.recursively - 
  * @param {Object} args.permissions - 
  * @param {Object} args.permissions.owner - 
  * @param {Boolean} args.permissions.owner.canRead - 
  * @param {Boolean} args.permissions.owner.canWrite - 
  * @param {Boolean} args.permissions.owner.canExecute - 
  * @param {Object} args.permissions.group - 
  * @param {Boolean} args.permissions.group.canRead - 
  * @param {Boolean} args.permissions.group.canWrite - 
  * @param {Boolean} args.permissions.group.canExecute - 
  * @param {Object} args.permissions.others - 
  * @param {Boolean} args.permissions.others.canRead - 
  * @param {Boolean} args.permissions.others.canWrite - 
  * @param {Boolean} args.permissions.others.canExecute - 
  * @return {null} 
  *
  * @example
  * ```js
  *  await FileSystem.addPermissions({
  *      path: fileOrFolderPath,
  *      permissions: {
  *          owner: {
  *              canExecute: true,
  *          },
  *      }
  *  })
  * ```
  */
  async addPermissions({ path: path10, permissions = { owner: {}, group: {}, others: {} }, recursively = false }) {
    permissions = { owner: {}, group: {}, others: {}, ...permissions };
    let permissionNumber = 0;
    let fileInfo;
    if (!(Object.keys(permissions.owner).length === Object.keys(permissions.group).length === Object.keys(permissions.others).length === 3)) {
      fileInfo = await FileSystem.info(path10);
      permissionNumber = fileInfo.lstat.mode & 511;
    }
    if (permissions.owner.canRead != null) {
      if (permissions.owner.canRead) {
        permissionNumber |= 256;
      } else {
        permissionNumber &= 767;
      }
    }
    if (permissions.owner.canWrite != null) {
      if (permissions.owner.canWrite) {
        permissionNumber |= 128;
      } else {
        permissionNumber &= 895;
      }
    }
    if (permissions.owner.canExecute != null) {
      if (permissions.owner.canExecute) {
        permissionNumber |= 64;
      } else {
        permissionNumber &= 959;
      }
    }
    if (permissions.group.canRead != null) {
      if (permissions.group.canRead) {
        permissionNumber |= 32;
      } else {
        permissionNumber &= 991;
      }
    }
    if (permissions.group.canWrite != null) {
      if (permissions.group.canWrite) {
        permissionNumber |= 16;
      } else {
        permissionNumber &= 1007;
      }
    }
    if (permissions.group.canExecute != null) {
      if (permissions.group.canExecute) {
        permissionNumber |= 8;
      } else {
        permissionNumber &= 1015;
      }
    }
    if (permissions.others.canRead != null) {
      if (permissions.others.canRead) {
        permissionNumber |= 4;
      } else {
        permissionNumber &= 1019;
      }
    }
    if (permissions.others.canWrite != null) {
      if (permissions.others.canWrite) {
        permissionNumber |= 2;
      } else {
        permissionNumber &= 1021;
      }
    }
    if (permissions.others.canExecute != null) {
      if (permissions.others.canExecute) {
        permissionNumber |= 1;
      } else {
        permissionNumber &= 1022;
      }
    }
    if (recursively == false || fileInfo instanceof Object && fileInfo.isFile || !(fileInfo instanceof Object) && (await FileSystem.info(path10)).isFile) {
      return Deno.chmod(path10.path || path10, permissionNumber);
    } else {
      const promises = [];
      const paths = await FileSystem.recursivelyListPathsIn(path10, { onlyHardlinks: false, dontFollowSymlinks: false, ...recursively });
      for (const eachPath2 of paths) {
        promises.push(
          Deno.chmod(eachPath2, permissionNumber).catch(console.error)
        );
      }
      return new Promise(async (resolve15, reject) => {
        for (const each2 of promises) {
          await each2;
        }
        resolve15();
      });
    }
  },
  // alias
  setPermissions(...args) {
    return FileSystem.addPermissions(...args);
  },
  async write({ path: path10, data, force = true, overwrite = false, renameExtension = null }) {
    path10 = pathStandardize(path10);
    await grabPathLock(path10);
    if (force) {
      FileSystem.sync.ensureIsFolder(FileSystem.parentPath(path10), { overwrite, renameExtension });
      const info = FileSystem.sync.info(path10);
      if (info.isDirectory) {
        FileSystem.sync.remove(path10);
      }
    }
    let output2;
    if (typeof data == "string") {
      output2 = await Deno.writeTextFile(path10, data);
    } else if (typedArrayClasses4.some((dataClass) => data instanceof dataClass)) {
      output2 = await Deno.writeFile(path10, data);
    } else if (isGeneratorType3(data) || data[Symbol.iterator] || data[Symbol.asyncIterator]) {
      const file = await Deno.open(path10, { read: true, write: true, create: true, truncate: true });
      const encoder3 = new TextEncoder();
      const encode2 = encoder3.encode.bind(encoder3);
      try {
        let index = 0;
        for await (let packet of data) {
          if (typeof packet == "string") {
            packet = encode2(packet);
          }
          await Deno.write(file.rid, packet);
        }
      } finally {
        Deno.close(file.rid);
      }
    }
    delete locker[path10];
    return output2;
  },
  async append({ path: path10, data, force = true, overwrite = false, renameExtension = null }) {
    path10 = pathStandardize(path10);
    await grabPathLock(path10);
    if (force) {
      FileSystem.sync.ensureIsFolder(FileSystem.parentPath(path10), { overwrite, renameExtension });
      const info = FileSystem.sync.info(path10);
      if (info.isDirectory) {
        FileSystem.sync.remove(path10);
      }
    }
    const file = await Deno.open(path10, { read: true, write: true, create: true });
    await file.seek(0, Deno.SeekMode.End);
    if (typeof data == "string") {
      await file.write(new TextEncoder().encode(data));
    } else {
      await file.write(data);
    }
    await file.close();
    delete locker[path10];
  },
  async makeHardPathTo(path10, options = {}) {
    var { cache: cache6 } = { cache: {}, ...options };
    if (cache6[path10]) {
      return cache6[path10];
    }
    const [folders, name, extension] = FileSystem.pathPieces(FileSystem.makeAbsolutePath(path10));
    let topDownPath = ``;
    for (const eachFolderName of folders) {
      topDownPath += `/${eachFolderName}`;
      if (cache6[topDownPath]) {
        topDownPath = cache6[topDownPath];
        continue;
      }
      const unchangedPath = topDownPath;
      const info = await FileSystem.info(topDownPath);
      if (info.isSymlink) {
        const absolutePathToIntermediate = await FileSystem.finalTargetOf(info.path, { _parentsHaveBeenChecked: true, cache: cache6 });
        if (absolutePathToIntermediate == null) {
          return null;
        }
        topDownPath = topDownPath.slice(0, -(eachFolderName.length + 1));
        const relativePath = FileSystem.makeRelativePath({
          from: topDownPath,
          to: absolutePathToIntermediate
        });
        topDownPath += `/${relativePath}`;
        topDownPath = normalize4(topDownPath);
      }
      cache6[unchangedPath] = topDownPath;
    }
    const hardPath = normalize4(`${topDownPath}/${name}${extension}`);
    cache6[path10] = hardPath;
    return hardPath;
  },
  async walkUpImport(path10, start) {
    const startPath = start || FileSystem.pathOfCaller(1);
    const nearestPath = await FileSystem.walkUpUntil(path10, startPath);
    if (nearestPath) {
      const absolutePath = FileSystem.makeAbsolutePath(`${nearestPath}/${path10}`);
      return import(toFileUrl3(absolutePath).href);
    } else {
      throw Error(`Tried to walkUpImport ${path10}, starting at ${startPath}, but was unable to find any files`);
    }
  },
  sync: {
    // things that are already sync
    get parentPath() {
      return FileSystem.parentPath;
    },
    get dirname() {
      return FileSystem.dirname;
    },
    get basename() {
      return FileSystem.basename;
    },
    get extname() {
      return FileSystem.extname;
    },
    get join() {
      return FileSystem.join;
    },
    get thisFile() {
      return FileSystem.thisFile;
    },
    get thisFolder() {
      return FileSystem.thisFolder;
    },
    get normalize() {
      return FileSystem.normalize;
    },
    get isAbsolutePath() {
      return FileSystem.isAbsolutePath;
    },
    get isRelativePath() {
      return FileSystem.isRelativePath;
    },
    get makeRelativePath() {
      return FileSystem.makeRelativePath;
    },
    get makeAbsolutePath() {
      return FileSystem.makeAbsolutePath;
    },
    get pathDepth() {
      return FileSystem.pathDepth;
    },
    get pathPieces() {
      return FileSystem.pathPieces;
    },
    get extendName() {
      return FileSystem.extendName;
    },
    get allParentPaths() {
      return FileSystem.allParentPaths;
    },
    get pathOfCaller() {
      return FileSystem.pathOfCaller;
    },
    get home() {
      return FileSystem.home;
    },
    get workingDirectory() {
      return FileSystem.workingDirectory;
    },
    get cwd() {
      return FileSystem.cwd;
    },
    get pwd() {
      return FileSystem.pwd;
    },
    get cd() {
      return FileSystem.cd;
    },
    get changeDirectory() {
      return FileSystem.changeDirectory;
    },
    set workingDirectory(value) {
      return FileSystem.workingDirectory = value;
    },
    set cwd(value) {
      return FileSystem.workingDirectory = value;
    },
    set pwd(value) {
      return FileSystem.workingDirectory = value;
    },
    info(fileOrFolderPath, _cachedLstat = null) {
      let lstat = _cachedLstat;
      try {
        lstat = Deno.lstatSync(fileOrFolderPath);
      } catch (error) {
        lstat = { doesntExist: true };
      }
      let stat = {};
      if (!lstat.isSymlink) {
        stat = {
          isBrokenLink: false,
          isLoopOfLinks: false
        };
      } else {
        try {
          stat = Deno.statSync(fileOrFolderPath);
        } catch (error) {
          if (error.message.match(/^Too many levels of symbolic links/)) {
            stat.isBrokenLink = true;
            stat.isLoopOfLinks = true;
          } else if (error.message.match(/^No such file or directory/)) {
            stat.isBrokenLink = true;
          } else {
            throw error;
          }
        }
      }
      return new PathInfo({ path: fileOrFolderPath, _lstatData: lstat, _statData: stat });
    },
    read(path10) {
      path10 = pathStandardize(path10);
      let output2;
      try {
        output2 = Deno.readTextFileSync(path10);
      } catch (error) {
      }
      return output2;
    },
    readBytes(path10) {
      path10 = pathStandardize(path10);
      let output2;
      try {
        output2 = Deno.readFileSync(path10);
      } catch (error) {
      }
      return output2;
    },
    *readLinesIteratively(path10) {
      path10 = pathStandardize(path10);
      const file = Deno.openSync(path10);
      try {
        yield* readLines(file);
      } finally {
        Deno.close(file.rid);
      }
    },
    /**
     * find a root folder based on a child path
     *
     * @example
     * ```js
     *     import { FileSystem } from "https://deno.land/x/quickr/main/file_system.js"
     * 
     *     var gitParentFolderOrNull = FileSystem.sync.walkUpUntil(".git")
     *     var gitParentFolderOrNull = FileSystem.sync.walkUpUntil({
     *         subPath:".git",
     *         startPath: FileSystem.pwd,
     *     })
     *
     *     // below will result in that^ same folder (assuming all your .git folders have config files)
     *     var gitParentFolderOrNull = FileSystem.sync.walkUpUntil(".git/config")
     * 
     *     // below will result in the same folder, but only if theres a local master branch
     *     var gitParentFolderOrNull = FileSystem.sync.walkUpUntil(".git/refs/heads/master")
     *```
     */
    walkUpUntil(subPath, startPath = null) {
      subPath = subPath instanceof PathInfo ? subPath.path : subPath;
      if (subPath instanceof Object) {
        var { subPath, startPath } = subPath;
      }
      let here;
      if (!startPath) {
        here = Deno.cwd();
      } else if (isAbsolute3(startPath)) {
        here = startPath;
      } else {
        here = join4(here, startPath);
      }
      while (1) {
        let checkPath = join4(here, subPath);
        const pathInfo = Deno.lstatSync(checkPath).catch(() => ({ doesntExist: true }));
        if (!pathInfo.doesntExist) {
          return here;
        }
        if (here == dirname3(here)) {
          return null;
        } else {
          here = dirname3(here);
        }
      }
    },
    nextTargetOf(path10, options = {}) {
      const originalWasItem = path10 instanceof PathInfo;
      const item = originalWasItem ? path10 : new PathInfo({ path: path10 });
      const lstat = item.lstat;
      if (lstat.isSymlink) {
        const relativeOrAbsolutePath = Deno.readLinkSync(item.path);
        if (isAbsolute3(relativeOrAbsolutePath)) {
          if (originalWasItem) {
            return new PathInfo({ path: relativeOrAbsolutePath });
          } else {
            return relativeOrAbsolutePath;
          }
        } else {
          const path11 = `${FileSystem.sync.makeHardPathTo(dirname3(item.path))}/${relativeOrAbsolutePath}`;
          if (originalWasItem) {
            return new PathInfo({ path: path11 });
          } else {
            return path11;
          }
        }
      } else {
        if (originalWasItem) {
          return item;
        } else {
          return item.path;
        }
      }
    },
    finalTargetOf(path10, options = {}) {
      const { _parentsHaveBeenChecked, cache: cache6 } = { _parentsHaveBeenChecked: false, cache: {}, ...options };
      const originalWasItem = path10 instanceof PathInfo;
      path10 = path10.path || path10;
      let result2 = Deno.lstatSync(path10).catch(() => ({ doesntExist: true }));
      if (result2.doesntExist) {
        return null;
      }
      path10 = FileSystem.sync.makeHardPathTo(path10, { cache: cache6 });
      const pathChain = [];
      while (result2.isSymlink) {
        const relativeOrAbsolutePath = Deno.readLinkSync(path10);
        if (isAbsolute3(relativeOrAbsolutePath)) {
          path10 = relativeOrAbsolutePath;
        } else {
          path10 = `${FileSystem.parentPath(path10)}/${relativeOrAbsolutePath}`;
        }
        result2 = Deno.lstatSync(path10).catch(() => ({ doesntExist: true }));
        if (result2.doesntExist) {
          return null;
        }
        path10 = FileSystem.sync.makeHardPathTo(path10, { cache: cache6 });
        if (pathChain.includes(path10)) {
          return null;
        }
        pathChain.push(path10);
      }
      path10 = FileSystem.normalize(path10);
      if (originalWasItem) {
        return new PathInfo({ path: path10 });
      } else {
        return path10;
      }
    },
    makeHardPathTo(path10, options = {}) {
      var { cache: cache6 } = { cache: {}, ...options };
      if (cache6[path10]) {
        return cache6[path10];
      }
      const [folders, name, extension] = FileSystem.pathPieces(FileSystem.makeAbsolutePath(path10));
      let topDownPath = ``;
      for (const eachFolderName of folders) {
        topDownPath += `/${eachFolderName}`;
        if (cache6[topDownPath]) {
          topDownPath = cache6[topDownPath];
          continue;
        }
        const unchangedPath = topDownPath;
        const info = FileSystem.sync.info(topDownPath);
        if (info.isSymlink) {
          const absolutePathToIntermediate = FileSystem.sync.finalTargetOf(info.path, { _parentsHaveBeenChecked: true, cache: cache6 });
          if (absolutePathToIntermediate == null) {
            return null;
          }
          topDownPath = topDownPath.slice(0, -(eachFolderName.length + 1));
          const relativePath = FileSystem.makeRelativePath({
            from: topDownPath,
            to: absolutePathToIntermediate
          });
          topDownPath += `/${relativePath}`;
          topDownPath = normalize4(topDownPath);
        }
        cache6[unchangedPath] = topDownPath;
      }
      const hardPath = normalize4(`${topDownPath}/${name}${extension}`);
      cache6[path10] = hardPath;
      return hardPath;
    },
    remove(fileOrFolder) {
      if (fileOrFolder instanceof Array) {
        return fileOrFolder.map(FileSystem.sync.remove);
      }
      fileOrFolder = fileOrFolder.path || fileOrFolder;
      let exists2 = false;
      let item;
      try {
        item = Deno.lstatSync(fileOrFolder);
        exists2 = true;
      } catch (error) {
      }
      if (exists2) {
        if (item.isFile || item.isSymlink) {
          return Deno.removeSync(fileOrFolder.replace(/\/+$/, ""));
        } else {
          return Deno.removeSync(fileOrFolder.replace(/\/+$/, ""), { recursive: true });
        }
      }
    },
    moveOutOfTheWay(path10, options = { extension: null }) {
      path10 = pathStandardize(path10);
      const extension = options?.extension || FileSystem.defaultRenameExtension;
      const info = FileSystem.sync.info(path10);
      if (info.exists) {
        const newPath = path10 + extension;
        FileSystem.sync.moveOutOfTheWay(newPath, { extension });
        moveSync(path10, newPath);
      }
    },
    ensureIsFolder(path10, options = { overwrite: false, renameExtension: null }) {
      path10 = pathStandardize(path10);
      const { overwrite, renameExtension } = defaultOptionsHelper(options);
      path10 = path10.path || path10;
      path10 = FileSystem.makeAbsolutePath(path10);
      const parentPath = dirname3(path10);
      if (parentPath == path10) {
        return;
      }
      const parent = FileSystem.sync.info(parentPath);
      if (!parent.isDirectory) {
        FileSystem.sync.ensureIsFolder(parentPath, { overwrite, renameExtension });
      }
      let pathInfo = FileSystem.sync.info(path10);
      if (pathInfo.exists && !pathInfo.isDirectory) {
        if (overwrite) {
          FileSystem.sync.remove(path10);
        } else {
          FileSystem.sync.moveOutOfTheWay(path10, { extension: renameExtension });
        }
      }
      Deno.mkdirSync(path10, { recursive: true });
      return path10;
    },
    /**
     * Move/Remove everything and Ensure parent folders
     *
     * @param path
     * @param options.overwrite - if false, then things in the way will be moved instead of deleted
     * @param options.extension - the string to append when renaming files to get them out of the way
     * 
     * @example
     * ```js
     *     FileSystem.sync.clearAPathFor("./something")
     * ```
     */
    clearAPathFor(path10, options = { overwrite: false, renameExtension: null }) {
      const { overwrite, renameExtension } = defaultOptionsHelper(options);
      const originalPath = path10;
      const paths = [];
      while (dirname3(path10) !== path10) {
        paths.push(path10);
        path10 = dirname3(path10);
      }
      for (const eachPath2 of paths.reverse()) {
        const info = FileSystem.sync.info(eachPath2);
        if (!info.exists) {
          break;
        } else if (info.isFile) {
          if (overwrite) {
            FileSystem.sync.remove(eachPath2);
          } else {
            FileSystem.sync.moveOutOfTheWay(eachPath2, { extension: renameExtension });
          }
        }
      }
      Deno.mkdirSync(dirname3(originalPath), { recursive: true });
      return originalPath;
    },
    append({ path: path10, data, force = true, overwrite = false, renameExtension = null }) {
      path10 = pathStandardize(path10);
      if (force) {
        FileSystem.sync.ensureIsFolder(FileSystem.parentPath(path10), { overwrite, renameExtension });
        const info = FileSystem.sync.info(path10);
        if (info.isDirectory) {
          FileSystem.sync.remove(path10);
        }
      }
      const file = Deno.openSync(path10, { read: true, write: true, create: true });
      file.seekSync(0, Deno.SeekMode.End);
      if (typeof data == "string") {
        file.writeSync(new TextEncoder().encode(data));
      } else {
        file.writeSync(data);
      }
      file.close();
    },
    write({ path: path10, data, force = true, overwrite = false, renameExtension = null }) {
      path10 = pathStandardize(path10);
      if (force) {
        FileSystem.sync.ensureIsFolder(FileSystem.parentPath(path10), { overwrite, renameExtension });
        const info = FileSystem.sync.info(path10);
        if (info.isDirectory) {
          FileSystem.sync.remove(path10);
        }
      }
      let output2;
      if (typeof data == "string") {
        output2 = Deno.writeTextFileSync(path10, data);
      } else if (typedArrayClasses4.some((dataClass) => data instanceof dataClass)) {
        output2 = Deno.writeFileSync(path10, data);
      } else if (isGeneratorType3(data) || data[Symbol.iterator] || data[Symbol.asyncIterator]) {
        const file = Deno.openSync(path10, { read: true, write: true, create: true, truncate: true });
        const encoder3 = new TextEncoder();
        const encode2 = encoder3.encode.bind(encoder3);
        try {
          let index = 0;
          for (let packet of data) {
            if (typeof packet == "string") {
              packet = encode2(packet);
            }
            Deno.writeSync(file.rid, packet);
          }
        } finally {
          Deno.close(file.rid);
        }
      }
      return output2;
    }
    // TODO:
    // move
    // ensureIsFile
    // copy
    // relativeLink
    // absoluteLink
    // iterateBasenamesIn
    // iteratePathsIn
    // iterateItemsIn
    // listItemsIn
    // listFileItemsIn
    // listFilePathsIn
    // listFileBasenamesIn
    // listFolderItemsIn
    // listFolderPathsIn
    // listFolderBasenamesIn
    // globIterator
    // getPermissions
    // addPermissions
    // Note:
    // cannot be sync:
    // walkUpImport 
  }
};
var glob = FileSystem.glob;

// https://deno.land/std@0.121.0/io/buffer.ts
var MIN_READ = 32 * 1024;
var MAX_SIZE = 2 ** 32 - 2;
var CR2 = "\r".charCodeAt(0);
var LF2 = "\n".charCodeAt(0);

// https://deno.land/std@0.121.0/streams/conversion.ts
var DEFAULT_CHUNK_SIZE = 16640;
var DEFAULT_BUFFER_SIZE = 32 * 1024;
function isCloser(value) {
  return typeof value === "object" && value != null && "close" in value && // deno-lint-ignore no-explicit-any
  typeof value["close"] === "function";
}
function writableStreamFromWriter(writer, options = {}) {
  const { autoClose = true } = options;
  return new WritableStream({
    async write(chunk, controller) {
      try {
        await writeAll(writer, chunk);
      } catch (e) {
        controller.error(e);
        if (isCloser(writer) && autoClose) {
          writer.close();
        }
      }
    },
    close() {
      if (isCloser(writer) && autoClose) {
        writer.close();
      }
    },
    abort() {
      if (isCloser(writer) && autoClose) {
        writer.close();
      }
    }
  });
}
function readableStreamFromReader(reader, options = {}) {
  const {
    autoClose = true,
    chunkSize = DEFAULT_CHUNK_SIZE,
    strategy
  } = options;
  return new ReadableStream({
    async pull(controller) {
      const chunk = new Uint8Array(chunkSize);
      try {
        const read = await reader.read(chunk);
        if (read === null) {
          if (isCloser(reader) && autoClose) {
            reader.close();
          }
          controller.close();
          return;
        }
        controller.enqueue(chunk.subarray(0, read));
      } catch (e) {
        controller.error(e);
        if (isCloser(reader)) {
          reader.close();
        }
      }
    },
    cancel() {
      if (isCloser(reader) && autoClose) {
        reader.close();
      }
    }
  }, strategy);
}
async function writeAll(w, arr) {
  let nwritten = 0;
  while (nwritten < arr.length) {
    nwritten += await w.write(arr.subarray(nwritten));
  }
}

// https://deno.land/std@0.128.0/bytes/mod.ts
function copy4(src, dst, off = 0) {
  off = Math.max(0, Math.min(off, dst.byteLength));
  const dstBytesAvailable = dst.byteLength - off;
  if (src.byteLength > dstBytesAvailable) {
    src = src.subarray(0, dstBytesAvailable);
  }
  dst.set(src, off);
  return src.byteLength;
}

// https://deno.land/std@0.128.0/io/buffer.ts
var MIN_READ2 = 32 * 1024;
var MAX_SIZE2 = 2 ** 32 - 2;
var Buffer3 = class {
  #buf;
  // contents are the bytes buf[off : len(buf)]
  #off = 0;
  // read at buf[off], write at buf[buf.byteLength]
  constructor(ab) {
    this.#buf = ab === void 0 ? new Uint8Array(0) : new Uint8Array(ab);
  }
  /** Returns a slice holding the unread portion of the buffer.
   *
   * The slice is valid for use only until the next buffer modification (that
   * is, only until the next call to a method like `read()`, `write()`,
   * `reset()`, or `truncate()`). If `options.copy` is false the slice aliases the buffer content at
   * least until the next buffer modification, so immediate changes to the
   * slice will affect the result of future reads.
   * @param options Defaults to `{ copy: true }`
   */
  bytes(options = { copy: true }) {
    if (options.copy === false)
      return this.#buf.subarray(this.#off);
    return this.#buf.slice(this.#off);
  }
  /** Returns whether the unread portion of the buffer is empty. */
  empty() {
    return this.#buf.byteLength <= this.#off;
  }
  /** A read only number of bytes of the unread portion of the buffer. */
  get length() {
    return this.#buf.byteLength - this.#off;
  }
  /** The read only capacity of the buffer's underlying byte slice, that is,
   * the total space allocated for the buffer's data. */
  get capacity() {
    return this.#buf.buffer.byteLength;
  }
  /** Discards all but the first `n` unread bytes from the buffer but
   * continues to use the same allocated storage. It throws if `n` is
   * negative or greater than the length of the buffer. */
  truncate(n) {
    if (n === 0) {
      this.reset();
      return;
    }
    if (n < 0 || n > this.length) {
      throw Error("bytes.Buffer: truncation out of range");
    }
    this.#reslice(this.#off + n);
  }
  reset() {
    this.#reslice(0);
    this.#off = 0;
  }
  #tryGrowByReslice(n) {
    const l2 = this.#buf.byteLength;
    if (n <= this.capacity - l2) {
      this.#reslice(l2 + n);
      return l2;
    }
    return -1;
  }
  #reslice(len) {
    assert2(len <= this.#buf.buffer.byteLength);
    this.#buf = new Uint8Array(this.#buf.buffer, 0, len);
  }
  /** Reads the next `p.length` bytes from the buffer or until the buffer is
   * drained. Returns the number of bytes read. If the buffer has no data to
   * return, the return is EOF (`null`). */
  readSync(p) {
    if (this.empty()) {
      this.reset();
      if (p.byteLength === 0) {
        return 0;
      }
      return null;
    }
    const nread = copy4(this.#buf.subarray(this.#off), p);
    this.#off += nread;
    return nread;
  }
  /** Reads the next `p.length` bytes from the buffer or until the buffer is
   * drained. Resolves to the number of bytes read. If the buffer has no
   * data to return, resolves to EOF (`null`).
   *
   * NOTE: This methods reads bytes synchronously; it's provided for
   * compatibility with `Reader` interfaces.
   */
  read(p) {
    const rr = this.readSync(p);
    return Promise.resolve(rr);
  }
  writeSync(p) {
    const m = this.#grow(p.byteLength);
    return copy4(p, this.#buf, m);
  }
  /** NOTE: This methods writes bytes synchronously; it's provided for
   * compatibility with `Writer` interface. */
  write(p) {
    const n = this.writeSync(p);
    return Promise.resolve(n);
  }
  #grow(n) {
    const m = this.length;
    if (m === 0 && this.#off !== 0) {
      this.reset();
    }
    const i2 = this.#tryGrowByReslice(n);
    if (i2 >= 0) {
      return i2;
    }
    const c = this.capacity;
    if (n <= Math.floor(c / 2) - m) {
      copy4(this.#buf.subarray(this.#off), this.#buf);
    } else if (c + n > MAX_SIZE2) {
      throw new Error("The buffer cannot be grown beyond the maximum size.");
    } else {
      const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE2));
      copy4(this.#buf.subarray(this.#off), buf);
      this.#buf = buf;
    }
    this.#off = 0;
    this.#reslice(Math.min(m + n, MAX_SIZE2));
    return m;
  }
  /** Grows the buffer's capacity, if necessary, to guarantee space for
   * another `n` bytes. After `.grow(n)`, at least `n` bytes can be written to
   * the buffer without another allocation. If `n` is negative, `.grow()` will
   * throw. If the buffer can't grow it will throw an error.
   *
   * Based on Go Lang's
   * [Buffer.Grow](https://golang.org/pkg/bytes/#Buffer.Grow). */
  grow(n) {
    if (n < 0) {
      throw Error("Buffer.grow: negative count");
    }
    const m = this.#grow(n);
    this.#reslice(m);
  }
  /** Reads data from `r` until EOF (`null`) and appends it to the buffer,
   * growing the buffer as needed. It resolves to the number of bytes read.
   * If the buffer becomes too large, `.readFrom()` will reject with an error.
   *
   * Based on Go Lang's
   * [Buffer.ReadFrom](https://golang.org/pkg/bytes/#Buffer.ReadFrom). */
  async readFrom(r) {
    let n = 0;
    const tmp = new Uint8Array(MIN_READ2);
    while (true) {
      const shouldGrow = this.capacity - this.length < MIN_READ2;
      const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
      const nread = await r.read(buf);
      if (nread === null) {
        return n;
      }
      if (shouldGrow)
        this.writeSync(buf.subarray(0, nread));
      else
        this.#reslice(this.length + nread);
      n += nread;
    }
  }
  /** Reads data from `r` until EOF (`null`) and appends it to the buffer,
   * growing the buffer as needed. It returns the number of bytes read. If the
   * buffer becomes too large, `.readFromSync()` will throw an error.
   *
   * Based on Go Lang's
   * [Buffer.ReadFrom](https://golang.org/pkg/bytes/#Buffer.ReadFrom). */
  readFromSync(r) {
    let n = 0;
    const tmp = new Uint8Array(MIN_READ2);
    while (true) {
      const shouldGrow = this.capacity - this.length < MIN_READ2;
      const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
      const nread = r.readSync(buf);
      if (nread === null) {
        return n;
      }
      if (shouldGrow)
        this.writeSync(buf.subarray(0, nread));
      else
        this.#reslice(this.length + nread);
      n += nread;
    }
  }
};
var CR3 = "\r".charCodeAt(0);
var LF3 = "\n".charCodeAt(0);

// https://deno.land/std@0.128.0/io/readers.ts
var StringReader = class extends Buffer3 {
  constructor(s) {
    super(new TextEncoder().encode(s).buffer);
  }
};

// https://deno.land/std@0.128.0/streams/conversion.ts
var DEFAULT_BUFFER_SIZE2 = 32 * 1024;

// https://deno.land/std@0.128.0/fmt/colors.ts
var { Deno: Deno3 } = globalThis;
var noColor2 = typeof Deno3?.noColor === "boolean" ? Deno3.noColor : true;
var ANSI_PATTERN2 = new RegExp(
  [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|"),
  "g"
);

// https://deno.land/std@0.128.0/io/files.ts
var DEFAULT_BUFFER_SIZE3 = 32 * 1024;

// https://deno.land/std@0.128.0/io/util.ts
var DEFAULT_BUFFER_SIZE4 = 32 * 1024;
var MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);

// https://deno.land/std@0.128.0/io/writers.ts
var decoder = new TextDecoder();

// https://deno.land/std@0.117.0/_util/os.ts
var osType4 = (() => {
  const { Deno: Deno4 } = globalThis;
  if (typeof Deno4?.build?.os === "string") {
    return Deno4.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win") ?? false) {
    return "windows";
  }
  return "linux";
})();
var isWindows4 = osType4 === "windows";

// https://deno.land/std@0.117.0/path/win32.ts
var win32_exports4 = {};
__export(win32_exports4, {
  basename: () => basename9,
  delimiter: () => delimiter9,
  dirname: () => dirname9,
  extname: () => extname9,
  format: () => format9,
  fromFileUrl: () => fromFileUrl9,
  isAbsolute: () => isAbsolute9,
  join: () => join12,
  normalize: () => normalize12,
  parse: () => parse9,
  relative: () => relative9,
  resolve: () => resolve9,
  sep: () => sep9,
  toFileUrl: () => toFileUrl9,
  toNamespacedPath: () => toNamespacedPath9
});

// https://deno.land/std@0.117.0/path/_constants.ts
var CHAR_UPPERCASE_A4 = 65;
var CHAR_LOWERCASE_A4 = 97;
var CHAR_UPPERCASE_Z4 = 90;
var CHAR_LOWERCASE_Z4 = 122;
var CHAR_DOT4 = 46;
var CHAR_FORWARD_SLASH4 = 47;
var CHAR_BACKWARD_SLASH4 = 92;
var CHAR_COLON4 = 58;
var CHAR_QUESTION_MARK4 = 63;

// https://deno.land/std@0.117.0/path/_util.ts
function assertPath4(path10) {
  if (typeof path10 !== "string") {
    throw new TypeError(
      `Path must be a string. Received ${JSON.stringify(path10)}`
    );
  }
}
function isPosixPathSeparator4(code2) {
  return code2 === CHAR_FORWARD_SLASH4;
}
function isPathSeparator4(code2) {
  return isPosixPathSeparator4(code2) || code2 === CHAR_BACKWARD_SLASH4;
}
function isWindowsDeviceRoot4(code2) {
  return code2 >= CHAR_LOWERCASE_A4 && code2 <= CHAR_LOWERCASE_Z4 || code2 >= CHAR_UPPERCASE_A4 && code2 <= CHAR_UPPERCASE_Z4;
}
function normalizeString4(path10, allowAboveRoot, separator, isPathSeparator6) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i2 = 0, len = path10.length; i2 <= len; ++i2) {
    if (i2 < len)
      code2 = path10.charCodeAt(i2);
    else if (isPathSeparator6(code2))
      break;
    else
      code2 = CHAR_FORWARD_SLASH4;
    if (isPathSeparator6(code2)) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT4 || res.charCodeAt(res.length - 2) !== CHAR_DOT4) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i2;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path10.slice(lastSlash + 1, i2);
        else
          res = path10.slice(lastSlash + 1, i2);
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code2 === CHAR_DOT4 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format4(sep15, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base;
  if (dir === pathObject.root)
    return dir + base;
  return dir + sep15 + base;
}
var WHITESPACE_ENCODINGS4 = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace4(string2) {
  return string2.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS4[c] ?? c;
  });
}

// https://deno.land/std@0.117.0/_util/assert.ts
var DenoStdInternalError4 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert7(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError4(msg);
  }
}

// https://deno.land/std@0.117.0/path/win32.ts
var sep9 = "\\";
var delimiter9 = ";";
function resolve9(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1; i2--) {
    let path10;
    const { Deno: Deno4 } = globalThis;
    if (i2 >= 0) {
      path10 = pathSegments[i2];
    } else if (!resolvedDevice) {
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path10 = Deno4.cwd();
    } else {
      if (typeof Deno4?.env?.get !== "function" || typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path10 = Deno4.cwd();
      if (path10 === void 0 || path10.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path10 = `${resolvedDevice}\\`;
      }
    }
    assertPath4(path10);
    const len = path10.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute15 = false;
    const code2 = path10.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator4(code2)) {
        isAbsolute15 = true;
        if (isPathSeparator4(path10.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator4(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            const firstPart = path10.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator4(path10.charCodeAt(j)))
                break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator4(path10.charCodeAt(j)))
                  break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path10.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path10.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot4(code2)) {
        if (path10.charCodeAt(1) === CHAR_COLON4) {
          device = path10.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator4(path10.charCodeAt(2))) {
              isAbsolute15 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator4(code2)) {
      rootEnd = 1;
      isAbsolute15 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path10.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute15;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString4(
    resolvedTail,
    !resolvedAbsolute,
    "\\",
    isPathSeparator4
  );
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize12(path10) {
  assertPath4(path10);
  const len = path10.length;
  if (len === 0)
    return ".";
  let rootEnd = 0;
  let device;
  let isAbsolute15 = false;
  const code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator4(code2)) {
      isAbsolute15 = true;
      if (isPathSeparator4(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator4(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          const firstPart = path10.slice(last, j);
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator4(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator4(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path10.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path10.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot4(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON4) {
        device = path10.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator4(path10.charCodeAt(2))) {
            isAbsolute15 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator4(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString4(
      path10.slice(rootEnd),
      !isAbsolute15,
      "\\",
      isPathSeparator4
    );
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute15)
    tail = ".";
  if (tail.length > 0 && isPathSeparator4(path10.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute15) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute15) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function isAbsolute9(path10) {
  assertPath4(path10);
  const len = path10.length;
  if (len === 0)
    return false;
  const code2 = path10.charCodeAt(0);
  if (isPathSeparator4(code2)) {
    return true;
  } else if (isWindowsDeviceRoot4(code2)) {
    if (len > 2 && path10.charCodeAt(1) === CHAR_COLON4) {
      if (isPathSeparator4(path10.charCodeAt(2)))
        return true;
    }
  }
  return false;
}
function join12(...paths) {
  const pathsCount = paths.length;
  if (pathsCount === 0)
    return ".";
  let joined;
  let firstPart = null;
  for (let i2 = 0; i2 < pathsCount; ++i2) {
    const path10 = paths[i2];
    assertPath4(path10);
    if (path10.length > 0) {
      if (joined === void 0)
        joined = firstPart = path10;
      else
        joined += `\\${path10}`;
    }
  }
  if (joined === void 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert7(firstPart != null);
  if (isPathSeparator4(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator4(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator4(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator4(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize12(joined);
}
function relative9(from, to) {
  assertPath4(from);
  assertPath4(to);
  if (from === to)
    return "";
  const fromOrig = resolve9(from);
  const toOrig = resolve9(to);
  if (fromOrig === toOrig)
    return "";
  from = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from === to)
    return "";
  let fromStart = 0;
  let fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH4)
      break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH4)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH4)
      break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH4)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length; ++i2) {
    if (i2 === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i2) === CHAR_BACKWARD_SLASH4) {
          return toOrig.slice(toStart + i2 + 1);
        } else if (i2 === 2) {
          return toOrig.slice(toStart + i2);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i2) === CHAR_BACKWARD_SLASH4) {
          lastCommonSep = i2;
        } else if (i2 === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_BACKWARD_SLASH4)
      lastCommonSep = i2;
  }
  if (i2 !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || from.charCodeAt(i2) === CHAR_BACKWARD_SLASH4) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH4)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function toNamespacedPath9(path10) {
  if (typeof path10 !== "string")
    return path10;
  if (path10.length === 0)
    return "";
  const resolvedPath = resolve9(path10);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH4) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH4) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== CHAR_QUESTION_MARK4 && code2 !== CHAR_DOT4) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot4(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === CHAR_COLON4 && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH4) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path10;
}
function dirname9(path10) {
  assertPath4(path10);
  const len = path10.length;
  if (len === 0)
    return ".";
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator4(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator4(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator4(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator4(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator4(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return path10;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot4(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON4) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator4(path10.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator4(code2)) {
    return path10;
  }
  for (let i2 = len - 1; i2 >= offset; --i2) {
    if (isPathSeparator4(path10.charCodeAt(i2))) {
      if (!matchedSlash) {
        end = i2;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return path10.slice(0, end);
}
function basename9(path10, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath4(path10);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i2;
  if (path10.length >= 2) {
    const drive = path10.charCodeAt(0);
    if (isWindowsDeviceRoot4(drive)) {
      if (path10.charCodeAt(1) === CHAR_COLON4)
        start = 2;
    }
  }
  if (ext !== void 0 && ext.length > 0 && ext.length <= path10.length) {
    if (ext.length === path10.length && ext === path10)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i2 = path10.length - 1; i2 >= start; --i2) {
      const code2 = path10.charCodeAt(i2);
      if (isPathSeparator4(code2)) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i2 + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i2;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path10.length;
    return path10.slice(start, end);
  } else {
    for (i2 = path10.length - 1; i2 >= start; --i2) {
      if (isPathSeparator4(path10.charCodeAt(i2))) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
    }
    if (end === -1)
      return "";
    return path10.slice(start, end);
  }
}
function extname9(path10) {
  assertPath4(path10);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path10.length >= 2 && path10.charCodeAt(1) === CHAR_COLON4 && isWindowsDeviceRoot4(path10.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i2 = path10.length - 1; i2 >= start; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (isPathSeparator4(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT4) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path10.slice(startDot, end);
}
function format9(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(
      `The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`
    );
  }
  return _format4("\\", pathObject);
}
function parse9(path10) {
  assertPath4(path10);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  const len = path10.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator4(code2)) {
      rootEnd = 1;
      if (isPathSeparator4(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator4(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator4(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator4(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot4(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON4) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator4(path10.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path10;
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path10;
          return ret;
        }
      }
    }
  } else if (isPathSeparator4(code2)) {
    ret.root = ret.dir = path10;
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path10.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i2 = path10.length - 1;
  let preDotState = 0;
  for (; i2 >= rootEnd; --i2) {
    code2 = path10.charCodeAt(i2);
    if (isPathSeparator4(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT4) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path10.slice(startPart, end);
    }
  } else {
    ret.name = path10.slice(startPart, startDot);
    ret.base = path10.slice(startPart, end);
    ret.ext = path10.slice(startDot, end);
  }
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path10.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}
function fromFileUrl9(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  let path10 = decodeURIComponent(
    url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  ).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname != "") {
    path10 = `\\\\${url.hostname}${path10}`;
  }
  return path10;
}
function toFileUrl9(path10) {
  if (!isAbsolute9(path10)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path10.match(
    /^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/
  );
  const url = new URL("file:///");
  url.pathname = encodeWhitespace4(pathname.replace(/%/g, "%25"));
  if (hostname != null && hostname != "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}

// https://deno.land/std@0.117.0/path/posix.ts
var posix_exports4 = {};
__export(posix_exports4, {
  basename: () => basename10,
  delimiter: () => delimiter10,
  dirname: () => dirname10,
  extname: () => extname10,
  format: () => format10,
  fromFileUrl: () => fromFileUrl10,
  isAbsolute: () => isAbsolute10,
  join: () => join13,
  normalize: () => normalize13,
  parse: () => parse10,
  relative: () => relative10,
  resolve: () => resolve10,
  sep: () => sep10,
  toFileUrl: () => toFileUrl10,
  toNamespacedPath: () => toNamespacedPath10
});
var sep10 = "/";
var delimiter10 = ":";
function resolve10(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    let path10;
    if (i2 >= 0)
      path10 = pathSegments[i2];
    else {
      const { Deno: Deno4 } = globalThis;
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path10 = Deno4.cwd();
    }
    assertPath4(path10);
    if (path10.length === 0) {
      continue;
    }
    resolvedPath = `${path10}/${resolvedPath}`;
    resolvedAbsolute = path10.charCodeAt(0) === CHAR_FORWARD_SLASH4;
  }
  resolvedPath = normalizeString4(
    resolvedPath,
    !resolvedAbsolute,
    "/",
    isPosixPathSeparator4
  );
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize13(path10) {
  assertPath4(path10);
  if (path10.length === 0)
    return ".";
  const isAbsolute15 = path10.charCodeAt(0) === CHAR_FORWARD_SLASH4;
  const trailingSeparator = path10.charCodeAt(path10.length - 1) === CHAR_FORWARD_SLASH4;
  path10 = normalizeString4(path10, !isAbsolute15, "/", isPosixPathSeparator4);
  if (path10.length === 0 && !isAbsolute15)
    path10 = ".";
  if (path10.length > 0 && trailingSeparator)
    path10 += "/";
  if (isAbsolute15)
    return `/${path10}`;
  return path10;
}
function isAbsolute10(path10) {
  assertPath4(path10);
  return path10.length > 0 && path10.charCodeAt(0) === CHAR_FORWARD_SLASH4;
}
function join13(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i2 = 0, len = paths.length; i2 < len; ++i2) {
    const path10 = paths[i2];
    assertPath4(path10);
    if (path10.length > 0) {
      if (!joined)
        joined = path10;
      else
        joined += `/${path10}`;
    }
  }
  if (!joined)
    return ".";
  return normalize13(joined);
}
function relative10(from, to) {
  assertPath4(from);
  assertPath4(to);
  if (from === to)
    return "";
  from = resolve10(from);
  to = resolve10(to);
  if (from === to)
    return "";
  let fromStart = 1;
  const fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from.charCodeAt(fromStart) !== CHAR_FORWARD_SLASH4)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_FORWARD_SLASH4)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length; ++i2) {
    if (i2 === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i2) === CHAR_FORWARD_SLASH4) {
          return to.slice(toStart + i2 + 1);
        } else if (i2 === 0) {
          return to.slice(toStart + i2);
        }
      } else if (fromLen > length) {
        if (from.charCodeAt(fromStart + i2) === CHAR_FORWARD_SLASH4) {
          lastCommonSep = i2;
        } else if (i2 === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_FORWARD_SLASH4)
      lastCommonSep = i2;
  }
  let out = "";
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || from.charCodeAt(i2) === CHAR_FORWARD_SLASH4) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (to.charCodeAt(toStart) === CHAR_FORWARD_SLASH4)
      ++toStart;
    return to.slice(toStart);
  }
}
function toNamespacedPath10(path10) {
  return path10;
}
function dirname10(path10) {
  assertPath4(path10);
  if (path10.length === 0)
    return ".";
  const hasRoot = path10.charCodeAt(0) === CHAR_FORWARD_SLASH4;
  let end = -1;
  let matchedSlash = true;
  for (let i2 = path10.length - 1; i2 >= 1; --i2) {
    if (path10.charCodeAt(i2) === CHAR_FORWARD_SLASH4) {
      if (!matchedSlash) {
        end = i2;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1)
    return hasRoot ? "/" : ".";
  if (hasRoot && end === 1)
    return "//";
  return path10.slice(0, end);
}
function basename10(path10, ext = "") {
  if (ext !== void 0 && typeof ext !== "string") {
    throw new TypeError('"ext" argument must be a string');
  }
  assertPath4(path10);
  let start = 0;
  let end = -1;
  let matchedSlash = true;
  let i2;
  if (ext !== void 0 && ext.length > 0 && ext.length <= path10.length) {
    if (ext.length === path10.length && ext === path10)
      return "";
    let extIdx = ext.length - 1;
    let firstNonSlashEnd = -1;
    for (i2 = path10.length - 1; i2 >= 0; --i2) {
      const code2 = path10.charCodeAt(i2);
      if (code2 === CHAR_FORWARD_SLASH4) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else {
        if (firstNonSlashEnd === -1) {
          matchedSlash = false;
          firstNonSlashEnd = i2 + 1;
        }
        if (extIdx >= 0) {
          if (code2 === ext.charCodeAt(extIdx)) {
            if (--extIdx === -1) {
              end = i2;
            }
          } else {
            extIdx = -1;
            end = firstNonSlashEnd;
          }
        }
      }
    }
    if (start === end)
      end = firstNonSlashEnd;
    else if (end === -1)
      end = path10.length;
    return path10.slice(start, end);
  } else {
    for (i2 = path10.length - 1; i2 >= 0; --i2) {
      if (path10.charCodeAt(i2) === CHAR_FORWARD_SLASH4) {
        if (!matchedSlash) {
          start = i2 + 1;
          break;
        }
      } else if (end === -1) {
        matchedSlash = false;
        end = i2 + 1;
      }
    }
    if (end === -1)
      return "";
    return path10.slice(start, end);
  }
}
function extname10(path10) {
  assertPath4(path10);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i2 = path10.length - 1; i2 >= 0; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (code2 === CHAR_FORWARD_SLASH4) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT4) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path10.slice(startDot, end);
}
function format10(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(
      `The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`
    );
  }
  return _format4("/", pathObject);
}
function parse10(path10) {
  assertPath4(path10);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path10.length === 0)
    return ret;
  const isAbsolute15 = path10.charCodeAt(0) === CHAR_FORWARD_SLASH4;
  let start;
  if (isAbsolute15) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i2 = path10.length - 1;
  let preDotState = 0;
  for (; i2 >= start; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (code2 === CHAR_FORWARD_SLASH4) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT4) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute15) {
        ret.base = ret.name = path10.slice(1, end);
      } else {
        ret.base = ret.name = path10.slice(startPart, end);
      }
    }
  } else {
    if (startPart === 0 && isAbsolute15) {
      ret.name = path10.slice(1, startDot);
      ret.base = path10.slice(1, end);
    } else {
      ret.name = path10.slice(startPart, startDot);
      ret.base = path10.slice(startPart, end);
    }
    ret.ext = path10.slice(startDot, end);
  }
  if (startPart > 0)
    ret.dir = path10.slice(0, startPart - 1);
  else if (isAbsolute15)
    ret.dir = "/";
  return ret;
}
function fromFileUrl10(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return decodeURIComponent(
    url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  );
}
function toFileUrl10(path10) {
  if (!isAbsolute10(path10)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace4(
    path10.replace(/%/g, "%25").replace(/\\/g, "%5C")
  );
  return url;
}

// https://deno.land/std@0.117.0/path/glob.ts
var path6 = isWindows4 ? win32_exports4 : posix_exports4;
var { join: join14, normalize: normalize14 } = path6;

// https://deno.land/std@0.117.0/path/mod.ts
var path7 = isWindows4 ? win32_exports4 : posix_exports4;
var {
  basename: basename11,
  delimiter: delimiter11,
  dirname: dirname11,
  extname: extname11,
  format: format11,
  fromFileUrl: fromFileUrl11,
  isAbsolute: isAbsolute11,
  join: join15,
  normalize: normalize15,
  parse: parse11,
  relative: relative11,
  resolve: resolve11,
  sep: sep11,
  toFileUrl: toFileUrl11,
  toNamespacedPath: toNamespacedPath11
} = path7;

// https://deno.land/x/good@0.7.8/value.js
var primitiveArrayClasses = [Uint16Array, Uint32Array, Uint8Array, Uint8ClampedArray, Int16Array, Int32Array, Int8Array, Float32Array, Float64Array, globalThis.BigInt64Array, globalThis.BigUint64Array].filter((each2) => each2);
var allKeys5 = function(obj) {
  let keys = [];
  if (obj == null) {
    return [];
  }
  if (!(obj instanceof Object)) {
    obj = Object.getPrototypeOf(obj);
  }
  while (obj) {
    keys = keys.concat(Reflect.ownKeys(obj));
    obj = Object.getPrototypeOf(obj);
  }
  return keys;
};
var ownKeyDescriptions5 = Object.getOwnPropertyDescriptors;
var allKeyDescriptions5 = function(value, options = { includingBuiltin: false }) {
  var { includingBuiltin } = { ...options };
  let descriptions = [];
  if (value == null) {
    return {};
  }
  if (!(value instanceof Object)) {
    value = Object.getPrototypeOf(value);
  }
  const rootPrototype = Object.getPrototypeOf({});
  let prevObj;
  while (value && value != prevObj) {
    if (!includingBuiltin && value == rootPrototype) {
      break;
    }
    descriptions = descriptions.concat(Object.entries(Object.getOwnPropertyDescriptors(value)));
    prevObj = value;
    value = Object.getPrototypeOf(value);
  }
  descriptions.reverse();
  return Object.fromEntries(descriptions);
};
var MapIterator5 = Object.getPrototypeOf((/* @__PURE__ */ new Map()).keys());
var SetIterator5 = Object.getPrototypeOf((/* @__PURE__ */ new Set()).keys());
var GeneratorFunction5 = class {
};
var AsyncGeneratorFunction5 = class {
};
try {
  GeneratorFunction5 = eval("((function*(){})()).constructor");
  AsyncGeneratorFunction5 = eval("((async function*(){})()).constructor");
} catch (error) {
}
var isGeneratorType5 = (value) => {
  if (value instanceof Object) {
    const prototype = Object.getPrototypeOf(value);
    if (prototype == MapIterator5 || prototype == SetIterator5) {
      return true;
    }
    const constructor = value.constructor;
    return constructor == GeneratorFunction5 || constructor == AsyncGeneratorFunction5;
  }
  return false;
};
var deepCopySymbol5 = Symbol.for("deepCopy");
var clonedFromSymbol5 = Symbol();
var getThis5 = Symbol();
Object.getPrototypeOf(function() {
})[getThis5] = function() {
  return this;
};
function deepCopyInner5(value, valueChain = [], originalToCopyMap = /* @__PURE__ */ new Map()) {
  valueChain.push(value);
  if (value == null) {
    return value;
  }
  if (!(value instanceof Object)) {
    return value;
  }
  if (originalToCopyMap.has(value)) {
    return originalToCopyMap.get(value);
  }
  if (value[deepCopySymbol5] instanceof Function) {
    const clonedValue = value[deepCopySymbol5]();
    originalToCopyMap.set(value, clonedValue);
    return clonedValue;
  }
  if (isGeneratorType5(value)) {
    throw Error(`Sadly built-in generators cannot be deep copied.
And I found a generator along this path:
${valueChain.reverse().map((each2) => `${each2},
`)}`);
  }
  let object, theThis, thisCopy;
  if (value instanceof Date) {
    object = new Date(value.getTime());
  } else if (value instanceof RegExp) {
    object = new RegExp(value);
  } else if (value instanceof Function) {
    theThis = value[getThis5]();
    object = function(...args) {
      return value.apply(thisCopy, args);
    };
  } else if (primitiveArrayClasses.includes(value.constructor)) {
    object = new value.constructor([...value]);
  } else if (value instanceof Array) {
    object = [];
  } else if (value instanceof Set) {
    object = /* @__PURE__ */ new Set();
  } else if (value instanceof Map) {
    object = /* @__PURE__ */ new Map();
  }
  originalToCopyMap.set(value, object);
  if (object instanceof Function) {
    thisCopy = deepCopyInner5(theThis, valueChain, originalToCopyMap);
  }
  const output2 = object;
  try {
    output2.constructor = value.constructor;
  } catch (error) {
  }
  Object.setPrototypeOf(output2, Object.getPrototypeOf(value));
  const propertyDefinitions = {};
  for (const [key, description] of Object.entries(Object.getOwnPropertyDescriptors(value))) {
    const { value: value2, get, set: set2, ...options } = description;
    const getIsFunc = get instanceof Function;
    const setIsFunc = set2 instanceof Function;
    if (getIsFunc || setIsFunc) {
      propertyDefinitions[key] = {
        ...options,
        get: get ? function(...args) {
          return get.apply(output2, args);
        } : void 0,
        set: set2 ? function(...args) {
          return set2.apply(output2, args);
        } : void 0
      };
    } else {
      if (key == "length" && output2 instanceof Array) {
        continue;
      }
      propertyDefinitions[key] = {
        ...options,
        value: deepCopyInner5(value2, valueChain, originalToCopyMap)
      };
    }
  }
  Object.defineProperties(output2, propertyDefinitions);
  return output2;
}
var deepCopy5 = (value) => deepCopyInner5(value);
var shallowSortObject5 = (obj) => {
  return Object.keys(obj).sort().reduce(
    (newObj, key) => {
      newObj[key] = obj[key];
      return newObj;
    },
    {}
  );
};
var deepSortObject5 = (obj, seen = /* @__PURE__ */ new Map()) => {
  if (!(obj instanceof Object)) {
    return obj;
  } else if (seen.has(obj)) {
    return seen.get(obj);
  } else {
    if (obj instanceof Array) {
      const sortedChildren = [];
      seen.set(obj, sortedChildren);
      for (const each2 of obj) {
        sortedChildren.push(deepSortObject5(each2, seen));
      }
      return sortedChildren;
    } else {
      const sorted = {};
      seen.set(obj, sorted);
      for (const eachKey of Object.keys(obj).sort()) {
        sorted[eachKey] = deepSortObject5(obj[eachKey], seen);
      }
      return sorted;
    }
  }
};
var stableStringify5 = (value, ...args) => {
  return JSON.stringify(deepSortObject5(value), ...args);
};

// https://deno.land/x/good@0.7.8/debug.js
var allKeysDescriptionsAsString = function(obj) {
  const descriptors = allKeyDescriptions5(obj);
  const stringKeys = descriptors.map(({ from, key, descriptor }) => [`${from.constructor instanceof Object && from.constructor.name || from}[${JSON.stringify(key)}]: `, key, descriptor]);
  const maxLength2 = Math.max(...stringKeys.map((each2) => each2[0].length));
  const paddedStringKeys = stringKeys.map(([string2, key, descriptor]) => [string2.padEnd(maxLength2, " "), key, descriptor]);
  const booleanSpacer = (bool2) => bool2 ? `true ` : `false`;
  let descriptorsString = `[
`;
  for (const [stringKey, key, descriptor] of paddedStringKeys) {
    let { value, writable, get, set: set2, configurable, enumerable } = descriptor;
    get = get instanceof Function ? `Function ` : `undefined`;
    set2 = set2 instanceof Function ? `Function ` : `undefined`;
    const isGetterSetter = get === `Function ` || set2 === `Function `;
    if (isGetterSetter) {
      try {
        value = value[key];
      } catch (error) {
        value = error;
      }
    }
    const isMethod = value instanceof Function;
    descriptorsString += `${indent}${indent}${stringKey}{ get:${get}, set:${set2}, isMethod:${booleanSpacer(isMethod)}, configurable:${booleanSpacer(configurable)}, enumerable:${booleanSpacer(enumerable)}, writable:${booleanSpacer(writable)}, value: ${value} },
`;
  }
  return descriptorsString + `${indent}]`;
};
var debugValueAsString = (value) => {
  const indent4 = `    `;
  if (value === void 0) {
    return JSON.stringify({
      valueItself: value,
      isUndefined: true,
      isNull: false,
      doubleEqualToNull: true,
      tripleEqualToNull: false,
      typeof: typeof value,
      stringified: void 0,
      objectIsFrozen: Object.isFrozen(value)
    }, 0, indent4.length);
  } else if (value === null) {
    return JSON.stringify({
      valueItself: value,
      isUndefined: false,
      isNull: true,
      doubleEqualToNull: true,
      tripleEqualToNull: true,
      typeof: typeof value,
      stringified: "null",
      objectIsFrozen: Object.isFrozen(value)
    }, 0, indent4.length);
  } else {
    const output2 = {
      valueItself: value,
      typeof: typeof value,
      constructorName: value.constructor instanceof Object && value.constructor.name,
      prototype: Object.getPrototypeOf(value),
      stringified: Error,
      instanceofObject: value instanceof Object,
      ifStatementTreatsAs: value ? true : false,
      doubleEqualToFalse: value == false,
      doubleEqualToTrue: value == false,
      objectIsFrozen: Object.isFrozen(value),
      isNaN: value !== value,
      isUndefined: false,
      isNull: false,
      doubleEqualToNull: value == null,
      tripleEqualToNull: value === null,
      valueOf: void 0,
      toString: void 0,
      isArray: value instanceof Array,
      iterableUsingForIn: false,
      iterableUsingForof: false,
      keys: JSON.stringify(Object.keys(value).map((each2) => typeof each2 == "symbol" ? `${each2}` : each2), indent4.length * 2),
      getOwnPropertyNames: JSON.stringify(Object.getOwnPropertyNames(value).map((each2) => typeof each2 == "symbol" ? `${each2}` : each2), indent4.length * 2),
      allPropertyDescriptions: allKeysDescriptionsAsString(value)
    };
    if (value.valueOf instanceof Function) {
      output2.valueOf = value.valueOf();
    }
    if (value.toString instanceof Function) {
      output2.toString = value.toString();
      if (typeof output2.toString == "string") {
        output2.toString = JSON.stringify(output2.toString);
      }
    }
    try {
      output2.stringified = JSON.stringify(value);
    } catch (error) {
      output2.stringified = error;
    }
    try {
      for (const each2 in value) {
        break;
      }
      output2.iterableUsingForIn = true;
    } catch (error) {
    }
    try {
      for (const each2 of value) {
        break;
      }
      output2.iterableUsingForOf = true;
    } catch (error) {
    }
    return `
{
    valueItself: ${output2.valueItself},
    typeof: ${output2.typeof},
    constructorName: ${output2.constructorName},
    prototype: ${output2.prototype},
    stringified: ${output2.stringified},
    instanceofObject: ${output2.instanceofObject},
    ifStatementTreatsAs: ${output2.ifStatementTreatsAs},
    doubleEqualToFalse: ${output2.doubleEqualToFalse},
    doubleEqualToTrue: ${output2.doubleEqualToTrue},
    objectIsFrozen: ${output2.objectIsFrozen},
    isNaN: ${output2.isNaN},
    isUndefined: ${output2.isUndefined},
    isNull: ${output2.isNull},
    doubleEqualToNull: ${output2.doubleEqualToNull},
    tripleEqualToNull: ${output2.tripleEqualToNull},
    valueOf: ${output2.valueOf},
    toString: ${output2.toString},
    isArray: ${output2.isArray},
    iterableUsingForIn: ${output2.iterableUsingForIn},
    iterableUsingForof: ${output2.iterableUsingForof},
    keys: ${output2.keys},
    getOwnPropertyNames: ${output2.getOwnPropertyNames},
    allPropertyDescriptions: ${output2.allPropertyDescriptions},
}
`;
  }
};

// https://deno.land/x/quickr@0.6.56/main/run.js
var timeoutSymbol = Symbol("timeout");
var envSymbol = Symbol("env");
var cwdSymbol = Symbol("cwd");
var stdinSymbol = Symbol("stdin");
var stdoutSymbol = Symbol("stdout");
var stderrSymbol = Symbol("stderr");
var stdoutAndErrSymbol = Symbol("stdoutAndErr");
var overwriteSymbol = Symbol("overwrite");
var appendSymbol = Symbol("append");
var asString = Symbol("asString");
var throwIfFails = Symbol("throwIfFails");
var zipInto = Symbol("zipInto");
var mergeInto = Symbol("mergeInto");
var returnAsString = Symbol("returnAsString");
var Timeout = ({ gentlyBy, waitBeforeUsingForce }) => [timeoutSymbol, { gentlyBy, waitBeforeUsingForce }];
var Env = (envVars) => [envSymbol, envVars];
var Cwd = (newDirectory) => [cwdSymbol, newDirectory];
var Stdin = (...streamsFilesOrStrings) => [stdinSymbol, streamsFilesOrStrings];
var Stdout = (...pathsFilesStreamsOrSymbols) => [stdoutSymbol, pathsFilesStreamsOrSymbols];
var Stderr = (...pathsFilesStreamsOrSymbols) => [stderrSymbol, pathsFilesStreamsOrSymbols];
var Out = (...pathsFilesStreamsOrSymbols) => [stdoutAndErrSymbol, pathsFilesStreamsOrSymbols];
var Overwrite = (fileOrFilePath) => [overwriteSymbol, fileOrFilePath];
var AppendTo = (fileOrFilePath) => [appendSymbol, fileOrFilePath];
var isReadable = (obj) => obj instanceof Object && obj.read instanceof Function;
var isWritable = (obj) => obj instanceof Object && obj.write instanceof Function;
var concatUint8Arrays = (arrays) => new Uint8Array(
  // simplified from: https://stackoverflow.com/questions/49129643/how-do-i-merge-an-array-of-uint8arrays
  arrays.reduce((acc, curr) => (acc.push(...curr), acc), [])
);
var { isWindows: isWindows5, isLinux, isMac } = OperatingSystem.commonChecks;
var alreadyOpenFiles = {};
var ridToPath = {};
var realDenoOpen = Deno.open.bind(Deno);
Deno.open = function(...args) {
  const path10 = FileSystem.makeAbsolutePath(args[0]);
  if (!alreadyOpenFiles[path10]) {
    alreadyOpenFiles[path10] = realDenoOpen(...args).then((file) => {
      ridToPath[file.rid] = path10;
      const realClose = file.close;
      file.close = function(...args2) {
        delete alreadyOpenFiles[path10];
        realClose(...args2);
      }.bind(file);
      return file;
    });
  }
  return alreadyOpenFiles[path10];
}.bind(Deno);
var realDenoOpenSync = Deno.openSync.bind(Deno);
Deno.openSync = function(...args) {
  const path10 = FileSystem.makeAbsolutePath(args[0]);
  if (!alreadyOpenFiles[path10]) {
    const file = realDenoOpenSync(...args);
    ridToPath[file.rid] = path10;
    const realClose = file.close;
    file.close = function(...args2) {
      delete alreadyOpenFiles[path10];
      realClose(...args2);
    }.bind(file);
    alreadyOpenFiles[path10] = file;
  }
  return alreadyOpenFiles[path10];
}.bind(Deno);
var run2 = (maybeStrings, ...args) => {
  let newArgs = [];
  const argSplitter = /[ \t]+/;
  if (maybeStrings instanceof Array) {
    maybeStrings = [...maybeStrings];
    const lastString = maybeStrings.pop();
    for (const eachString of maybeStrings) {
      const innerArgs = eachString.split(argSplitter);
      for (const each2 of innerArgs) {
        if (each2.length > 0) {
          newArgs.push(each2);
        }
      }
      newArgs.push(args.shift());
    }
    const endingArgsString = lastString.trim();
    if (endingArgsString.length > 0) {
      const endingArgs = endingArgsString.split(argSplitter);
      for (const each2 of endingArgs) {
        newArgs.push(each2);
      }
    }
    args = newArgs;
  } else {
    args = [maybeStrings, ...args];
  }
  const commandMetaData = {
    timeout: { gentlyBy: void 0, waitBeforeUsingForce: void 0 },
    env: void 0,
    cwd: void 0,
    stdin: void 0,
    stdout: void 0,
    stderr: void 0,
    outAndError: []
  };
  for (const each2 of args) {
    if (typeof each2 == "symbol") {
      if (each2 == throwIfFails) {
        commandMetaData.throwIfFails = true;
      }
    }
    if (each2 instanceof Array && typeof each2[0] == "symbol") {
      const [symbol, value] = each2;
      if (symbol === timeoutSymbol) {
        Object.assign(commandMetaData.timeout, value);
      }
      if (symbol === envSymbol) {
        commandMetaData.env = value;
      }
      if (symbol === cwdSymbol) {
        commandMetaData.cwd = value;
      }
      if (symbol === stdinSymbol) {
        commandMetaData.stdin = value;
      }
      if (symbol === stdoutSymbol) {
        commandMetaData.stdout = value;
      }
      if (symbol === stderrSymbol) {
        commandMetaData.stderr = value;
      }
      if (symbol === stdoutAndErrSymbol) {
        commandMetaData.outAndError = value;
      }
    }
  }
  const runArg = {
    cmd: args.filter((each2) => typeof each2 == "string"),
    env: commandMetaData.env,
    cwd: commandMetaData.cwd,
    stdin: void 0,
    stdout: void 0,
    stderr: void 0
  };
  const syncStatus = { done: false, exitCode: void 0, success: void 0 };
  const asyncPart = async () => {
    if (
      // either both should be null or both should be set
      commandMetaData.timeout.gentlyBy == null !== (commandMetaData.timeout.waitBeforeUsingForce == null) || commandMetaData.timeout.gentlyBy != null && (!(commandMetaData.timeout.gentlyBy >= 0) || !(commandMetaData.timeout.waitBeforeUsingForce >= 0))
    ) {
      throw Error(`
When running command:
    ${JSON.stringify(runArg.cmd)}
it was given a:
    Timeout(${JSON.stringify(commandMetaData.timeout)})
however both "gentlyBy" and "waitBeforeUsingForce" are needed.
For example, if 
    gentlyBy: 1000
    waitBeforeUsingForce: 500
it would be force killed 1.5sec after the process started.
If you never want force to be used, do {waitBeforeUsingForce: Infinity}

`);
    }
    if (runArg.cwd !== void 0) {
      const folderExists = await Deno.stat(runArg.cwd).then(({ isDirectory: isDirectory2 }) => isDirectory2).catch(() => false);
      if (!folderExists) {
        throw Error(`
When running command:
    ${JSON.stringify(runArg.cmd)}
it was given a Cwd (cwd) of:
${JSON.stringify(runArg.cwd)}
but that doesn't seem to be a path to a folder, so the command would fail.

`);
      }
    }
    let stdinWriter = void 0;
    if (commandMetaData.stdin !== void 0) {
      let stdinArgs = commandMetaData.stdin;
      let index = 0;
      for (const each2 of stdinArgs) {
        if (each2 instanceof Promise) {
          stdinArgs[index] = await each2;
        }
        ++index;
      }
      if (stdinArgs.length == 0) {
        runArg.stdin = "piped";
      } else if (stdinArgs.length == 1 && stdinArgs[0] == null) {
        runArg.stdin = "null";
      } else {
        stdinArgs = stdinArgs.filter((each2) => each2 != null);
        if (stdinArgs.length == 0) {
          throw Error(`when calling run() with the command: 
    ${JSON.stringify(runArg.cmd)}
An Stdin() was given, but it wasn't given any arguments
if you want Stdin to be nothing (instead of the default Stdin(Deno.stdin)) put Stdin(null)

`);
        } else {
          runArg.stdin = "piped";
          if (stdinArgs.every((each2) => typeof each2 == "string" || each2 instanceof Uint8Array)) {
            const allUint8Arrays = stdinArgs.map((each2) => typeof each2 != "string" ? each2 : new TextEncoder().encode(each2));
            stdinWriter = concatUint8Arrays(allUint8Arrays);
          } else {
            const first = stdinArgs[0];
            let prev;
            if (typeof first == "string") {
              stdinWriter = readableStreamFromReader(new StringReader(first));
              prev = "string";
            } else if (first instanceof Uint8Array) {
              stdinWriter = readableStreamFromReader(new Buffer(first));
              prev = "uint8array";
            } else if (first instanceof ReadableStream) {
              stdinWriter = first;
              prev = "readableStream";
            } else if (isReadable(first)) {
              stdinWriter = readableStreamFromReader(first);
              prev = "readable";
            } else {
              throw Error(`when calling run() with the command: 
    ${JSON.stringify(runArg.cmd)}
An Stdin() was given, but there was a problem with one of the arguments.
The argument can be a string, a file (Deno.open("./path")), bytes (Uint8Array), or any readable object (like Deno.stdin or the .stdout of another run command)
but instead of any of those I received:
    ${first}

`);
            }
            for (const each2 of stdinArgs.slice(1)) {
              if (each2 === mergeInto || each2 === zipInto) {
                prev = each2;
                continue;
              }
              let newStream;
              if (typeof each2 == "string") {
                newStream = readableStreamFromReader(new StringReader(each2));
                current = "string";
              } else if (each2 instanceof Uint8Array) {
                newStream = readableStreamFromReader(new Buffer(each2));
                current = "uint8";
              } else if (each2 instanceof ReadableStream) {
                newStream = each2;
                current = "readableStream";
              } else if (isReadable(each2)) {
                newStream = readableStreamFromReader(each2);
                current = "readable";
              } else {
                throw Error(`when calling run() with the command: 
    ${JSON.stringify(runArg.cmd)}
An Stdin() was given, but there was a problem with one of the arguments.
The argument can be a string, a file (Deno.open("./path")), bytes (Uint8Array), or any readable object (like Deno.stdin or the .stdout of another run command)
but instead of any of those I received:
    ${each2}

`);
              }
              if (prev !== zipInto && (prev === mergeInto || prev == "string" || prev == "uint8array" || current == "string" || current == "uint8array")) {
                stdinWriter = stdinWriter.mergeReadableStreams(stdinWriter, newStream);
              } else {
                stdinWriter = stdinWriter.zipReadableStreams(stdinWriter, newStream);
              }
            }
          }
        }
      }
    }
    const outStreamNames = ["stdout", "stderr"];
    if (commandMetaData.outAndError.length > 0) {
      for (const each2 of outStreamNames) {
        if (!(commandMetaData[each2] instanceof Array)) {
          commandMetaData[each2] = [];
        }
        commandMetaData[each2] = commandMetaData[each2].concat(commandMetaData.outAndError);
      }
    }
    for (const each2 of outStreamNames) {
      if (commandMetaData[each2] !== void 0) {
        if (commandMetaData[each2].length == 0) {
          runArg[each2] = "piped";
        } else if (commandMetaData[each2].length == 1 && commandMetaData[each2][0] === null) {
          runArg[each2] = "null";
        } else {
          runArg[each2] = "piped";
          commandMetaData[each2] = [...new Set(commandMetaData[each2].filter((each3) => each3 != null))];
        }
      }
    }
    const openFiles = {};
    const convertReturnStreamArg = async (arg) => {
      if (arg === returnAsString) {
        return arg;
      }
      if (arg instanceof Array) {
        if (typeof arg[0] == "symbol") {
          let [symbol, value] = arg;
          if (symbol === overwriteSymbol) {
            if (typeof value == "string") {
              const path10 = FileSystem.makeAbsolutePath(value);
              if (!openFiles[path10]) {
                await FileSystem.clearAPathFor(value, { overwrite: true });
                openFiles[path10] = await Deno.open(value, { write: true, truncate: true, create: true });
              }
              value = openFiles[path10];
            }
            if (value instanceof Deno.File) {
              value.truncate();
            } else {
              throw Error(`
When running command:
    ${JSON.stringify(runArg.cmd)}
it was given one of:
    Stdout(Overwrite(arg))
    Stdin(Overwrite(arg))
    Out(Overwrite(arg))
However the given arg was not a string path or a file object.
Here's what I know about the argument:${debugValueAsString(value)}

`);
            }
          } else if (symbol === appendSymbol) {
            if (typeof value == "string") {
              const path10 = FileSystem.makeAbsolutePath(value);
              if (!openFiles[path10]) {
                await FileSystem.ensureIsFolder(FileSystem.parentPath(value));
                openFiles[path10] = await Deno.open(value, { write: true, create: true });
              }
              value = openFiles[path10];
            }
            if (value instanceof Deno.File) {
              await Deno.seek(value.rid, 0, Deno.SeekMode.End);
            } else {
              throw Error(`
When running command:
    ${JSON.stringify(runArg.cmd)}
it was given one of:
    Stdout(AppendTo(arg))
    Stdin(AppendTo(arg))
    Out(AppendTo(arg))
However the given arg was not a string path or a file object.
Here's what I know about the argument:${debugValueAsString(value)}

`);
            }
          }
          arg = value;
        }
      }
      if (arg instanceof WritableStream) {
        return arg;
      } else if (isWritable(arg)) {
        return writableStreamFromWriter(arg);
      } else if (typeof arg == "string") {
        throw Error(`
When running command:
    ${JSON.stringify(runArg.cmd)}
it was given one of:
    Stdout(${JSON.stringify(arg)})
    Stdin(${JSON.stringify(arg)})
    Out(${JSON.stringify(arg)})
if you want to have them write to a file:
    dont:    Out(${JSON.stringify(arg)})
    instead: Out(Overwrite(${JSON.stringify(arg)}))
    or:      Out(AppendTo(${JSON.stringify(arg)}))

`);
      }
    };
    const alreadyComputed = /* @__PURE__ */ new Map();
    const convertArgsToWritables = (...args2) => args2.map((eachArg) => {
      let key;
      if (eachArg instanceof Array) {
        key = JSON.stringify(eachArg.map((each2) => {
          if (typeof each2 == "symbol") {
            return each2.toString();
          } else if (each2 instanceof Deno.File) {
            if (ridToPath[each2.id]) {
              return FileSystem.makeAbsolutePath(ridToPath[each2.id]);
            }
            return `Deno.File(${each2.rid})`;
          } else if (typeof each2 == "string") {
            return FileSystem.makeAbsolutePath(each2);
          } else {
            return JSON.stringify(each2);
          }
        }));
      } else {
        key = JSON.stringify(eachArg) + Deno.inspect(eachArg);
      }
      if (alreadyComputed.has(key)) {
        return alreadyComputed.get(key);
      } else {
        const output2 = convertReturnStreamArg(eachArg);
        alreadyComputed.set(key, output2);
        return output2;
      }
    });
    const stdoutWritables = await Promise.all(convertArgsToWritables(...commandMetaData.stdout || []));
    const stderrWritables = await Promise.all(convertArgsToWritables(...commandMetaData.stderr || []));
    let process = {};
    try {
      process = Deno.run(runArg);
    } catch (error) {
      const rejection = new Promise((resolve15, reject) => reject(`
${error}
This was from a run() call, which was converted to Deno.run(${JSON.stringify(runArg, 0, 4)})`));
      return [rejection, rejection, rejection];
    }
    if (commandMetaData.timeout.gentlyBy) {
      let outcome = false;
      process.status().then(() => outcome = true);
      setTimeout(async () => {
        if (!outcome) {
          process.kill("SIGINT");
          setTimeout(() => {
            if (!outcome) {
              process.kill("SIGKILL");
            }
          }, commandMetaData.timeout.waitBeforeUsingForce);
        }
      }, commandMetaData.timeout.gentlyBy);
    }
    let hasReturnString = false;
    let stdoutAndStderrDoneWritingPromise = { then(func2) {
      func2();
    } };
    const returnStringChunks = [];
    if (runArg.stdout == "piped" || runArg.stderr == "piped") {
      stdoutAndStderrDoneWritingPromise = deferredPromise();
      let stdoutIsDone = false;
      let stderrIsDone = false;
      const writableToWriter = /* @__PURE__ */ new Map();
      for (const eachWritable of stdoutWritables.concat(stderrWritables)) {
        if (!writableToWriter.has(eachWritable)) {
          if (eachWritable == returnAsString) {
            hasReturnString = true;
            const decoder3 = new TextDecoder();
            writableToWriter.set(eachWritable, {
              write(value) {
                const stringValue = decoder3.decode(value);
                returnStringChunks.push(stringValue);
              }
            });
          } else {
            if (eachWritable != null) {
              const writer = eachWritable.getWriter();
              writableToWriter.set(eachWritable, writer);
            }
          }
        }
      }
      const stdoutWriters = stdoutWritables.map((each2) => writableToWriter.get(each2));
      const stderrWriters = stderrWritables.map((each2) => writableToWriter.get(each2));
      if (runArg.stdout != "piped") {
        stdoutIsDone = true;
      } else {
        const reader = readableStreamFromReader(process.stdout).getReader();
        setTimeout(async () => {
          while (1) {
            const { value, done } = await reader.read();
            if (done) {
              stdoutIsDone = true;
              if (stderrIsDone) {
                stdoutAndStderrDoneWritingPromise.resolve();
              }
              break;
            }
            for (const each2 of stdoutWriters) {
              each2.write(value);
            }
          }
        });
      }
      if (runArg.stderr != "piped") {
        stderrIsDone = true;
      } else {
        const reader = readableStreamFromReader(process.stderr).getReader();
        setTimeout(async () => {
          while (1) {
            const { value, done } = await reader.read();
            if (done) {
              stderrIsDone = true;
              if (stdoutIsDone) {
                stdoutAndStderrDoneWritingPromise.resolve();
              }
              break;
            }
            for (const each2 of stderrWriters) {
              each2.write(value);
            }
          }
        });
      }
    }
    if (runArg.stdin == "piped") {
      if (stdinWriter instanceof Uint8Array) {
        process.stdin.write(stdinWriter).then(() => process.stdin.close());
      } else if (stdinWriter instanceof ReadableStream) {
        writableStreamFromWriter(process.stdin);
      }
    }
    let statusPromise2 = process.status();
    statusPromise2.then(({ code: code2, success }) => {
      syncStatus.done = true;
      syncStatus.exitCode = code2;
      syncStatus.success = success;
    });
    let processFinishedValue;
    if (hasReturnString) {
      processFinishedValue = statusPromise2.then(() => stdoutAndStderrDoneWritingPromise.then(() => returnStringChunks.join("")));
    } else {
      processFinishedValue = statusPromise2.then(({ success, code: code2 }) => {
        return {
          isDone: true,
          status: syncStatus,
          sendSignal: () => 0,
          success,
          exitCode: code2,
          pid: process.pid,
          rid: process.rid,
          kill: () => 0,
          close: process.close,
          stdin: runArg.stdin == "null" ? null : process.stdin || Deno.stdin,
          stdout: process.stdout || Deno.stdout,
          stderr: process.stderr || Deno.stderr
        };
      });
    }
    const returnValueOrError = new Promise(async (resolve15, reject) => {
      if (commandMetaData.throwIfFails) {
        const status = await statusPromise2;
        if (!status.success) {
          reject(await processFinishedValue);
          return;
        }
      }
      resolve15(processFinishedValue);
    });
    return [process, returnValueOrError, statusPromise2];
  };
  const asyncPartPromise = asyncPart();
  const processPromise = asyncPartPromise.then(([process, processFinishedValue, statusPromise2]) => process).catch((err) => err);
  const statusPromise = asyncPartPromise.then(([process, processFinishedValue, statusPromise2]) => statusPromise2).catch((err) => err);
  const returnValuePromise = asyncPartPromise.then(([process, processFinishedValue, statusPromise2]) => processFinishedValue);
  Object.defineProperties(returnValuePromise, {
    status: { get() {
      return syncStatus;
    } },
    isDone: { get() {
      return syncStatus.done;
    } },
    sendSignal: { get() {
      return (...args2) => processPromise.then((process) => process.kill(...args2)).catch((error) => error);
    } },
    kill: { get() {
      return (signal = "SIGKILL") => processPromise.then((process) => process.kill(signal));
    } },
    close: { get() {
      return (...args2) => processPromise.then((process) => process.close(...args2));
    } },
    success: { get() {
      return statusPromise.then(({ success }) => success);
    } },
    exitCode: { get() {
      return statusPromise.then(({ code: code2 }) => code2);
    } },
    outcome: { get() {
      return statusPromise;
    } },
    rid: { get() {
      return processPromise.then(({ rid }) => rid);
    } },
    pid: { get() {
      return processPromise.then(({ pid }) => pid);
    } },
    stdout: { get() {
      return processPromise.then(({ stdout }) => stdout || Deno.stdout);
    } },
    stderr: { get() {
      return processPromise.then(({ stderr }) => stderr || Deno.stderr);
    } },
    stdin: {
      get() {
        const realStdinPromise = processPromise.then(({ stdin }) => stdin || Deno.stdin);
        return {
          send(rawDataOrString) {
            if (typeof rawDataOrString == "string") {
              return { ...realStdinPromise.then((realStdin) => realStdin.write(new TextEncoder().encode(rawDataOrString))), ...this };
            } else {
              return { ...realStdinPromise.then((realStdin) => realStdin.write(rawDataOrString)), ...this };
            }
          },
          close(...args2) {
            return realStdinPromise.then((realStdin) => (realStdin.close(...args2), this));
          }
        };
      }
    }
  });
  return returnValuePromise;
};
run2.Timeout = Timeout;
run2.Env = Env;
run2.Cwd = Cwd;
run2.Stdin = Stdin;
run2.Stdout = Stdout;
run2.Stderr = Stderr;
run2.Out = Out;
run2.Overwrite = Overwrite;
run2.AppendTo = AppendTo;
run2.zipInto = zipInto;
run2.mergeInto = mergeInto;
run2.returnAsString = returnAsString;

// https://deno.land/x/good@1.5.1.0/string.js
var indent3 = ({ string: string2, by = "    ", noLead = false }) => (noLead ? "" : by) + string2.replace(/\n/g, "\n" + by);
var toString2 = (value) => {
  if (typeof value == "symbol") {
    return toRepresentation3(value);
  } else if (!(value instanceof Object)) {
    return value != null ? value.toString() : `${value}`;
  } else {
    return toRepresentation3(value);
  }
};
var reprSymbol2 = Symbol.for("representation");
var denoInspectSymbol2 = Symbol.for("Deno.customInspect");
var toRepresentation3 = (item) => {
  const alreadySeen = /* @__PURE__ */ new Set();
  const recursionWrapper = (item2) => {
    if (item2 instanceof Object) {
      if (alreadySeen.has(item2)) {
        return `[Self Reference]`;
      } else {
        alreadySeen.add(item2);
      }
    }
    let output2;
    if (item2 === void 0) {
      output2 = "undefined";
    } else if (item2 === null) {
      output2 = "null";
    } else if (typeof item2 == "string") {
      output2 = JSON.stringify(item2);
    } else if (typeof item2 == "symbol") {
      if (!item2.description) {
        output2 = "Symbol()";
      } else {
        const globalVersion = Symbol.for(item2.description);
        if (globalVersion == item2) {
          output2 = `Symbol.for(${JSON.stringify(item2.description)})`;
        } else {
          output2 = `Symbol(${JSON.stringify(item2.description)})`;
        }
      }
    } else if (item2 instanceof Date) {
      output2 = `new Date(${item2.getTime()})`;
    } else if (item2 instanceof Array) {
      output2 = `[${item2.map((each2) => recursionWrapper(each2)).join(",")}]`;
    } else if (item2 instanceof Set) {
      output2 = `new Set(${[...item2].map((each2) => recursionWrapper(each2)).join(",")})`;
    } else if (item2 instanceof Object && item2.constructor == Object) {
      output2 = pureObjectRepr(item2);
    } else if (item2 instanceof Map) {
      let string2 = "new Map(";
      for (const [key, value] of item2.entries()) {
        const stringKey = recursionWrapper(key);
        const stringValue = recursionWrapper(value);
        if (!stringKey.match(/\n/g)) {
          string2 += `
  [${stringKey}, ${indent3({ string: stringValue, by: "  ", noLead: true })}],`;
        } else {
          string2 += `
  [${indent3({ string: stringKey, by: "  ", noLead: true })},
  ${indent3({ string: stringValue, by: "    ", noLead: true })}],`;
        }
      }
      string2 += "\n)";
      output2 = string2;
    } else {
      if (item2[reprSymbol2] instanceof Function) {
        try {
          output2 = item2[reprSymbol2]();
          return output2;
        } catch (error) {
        }
      }
      if (item2[denoInspectSymbol2] instanceof Function) {
        try {
          output2 = item2[denoInspectSymbol2]();
          return output2;
        } catch (error) {
        }
      }
      try {
        output2 = item2.toString();
        if (output2 !== "[object Object]") {
          return output2;
        }
      } catch (error) {
      }
      try {
        if (item2.constructor instanceof Function && item2.prototype && typeof item2.name == "string") {
          output2 = `class ${item2.name} { /*...*/ }`;
          return output2;
        }
      } catch (error) {
      }
      try {
        if (item2.constructor instanceof Function && typeof item2.constructor.name == "string") {
          output2 = `new ${item2.constructor.name}(${pureObjectRepr(item2)})`;
          return output2;
        }
      } catch (error) {
      }
      return pureObjectRepr(item2);
    }
    return output2;
  };
  const pureObjectRepr = (item2) => {
    let string2 = "{";
    for (const [key, value] of Object.entries(item2)) {
      const stringKey = recursionWrapper(key);
      const stringValue = recursionWrapper(value);
      string2 += `
  ${stringKey}: ${indent3({ string: stringValue, by: "  ", noLead: true })},`;
    }
    string2 += "\n}";
    return string2;
  };
  return recursionWrapper(item);
};
var wordList = (str2) => {
  const addedSeperator = str2.replace(/([a-z0-9])([A-Z])/g, "$1_$2").replace(/[^a-zA-Z0-9 _.-]/, "_").toLowerCase();
  const words = addedSeperator.split(/[ _.-]+/g);
  return words;
};
var toCamelCase = (str2) => {
  const words = wordList(str2);
  const capatalizedWords = words.map((each2) => each2.replace(/^\w/, (group0) => group0.toUpperCase()));
  capatalizedWords[0] = capatalizedWords[0].toLowerCase();
  return capatalizedWords.join("");
};
var reservedCharMap = {
  "&": "\\x26",
  "!": "\\x21",
  "#": "\\x23",
  "$": "\\$",
  "%": "\\x25",
  "*": "\\*",
  "+": "\\+",
  ",": "\\x2c",
  ".": "\\.",
  ":": "\\x3a",
  ";": "\\x3b",
  "<": "\\x3c",
  "=": "\\x3d",
  ">": "\\x3e",
  "?": "\\?",
  "@": "\\x40",
  "^": "\\^",
  "`": "\\x60",
  "~": "\\x7e",
  "(": "\\(",
  ")": "\\)",
  "[": "\\[",
  "]": "\\]",
  "{": "\\{",
  "}": "\\}",
  "/": "\\/",
  "-": "\\x2d",
  "\\": "\\\\",
  "|": "\\|"
};
var RX_REGEXP_ESCAPE = new RegExp(
  `[${Object.values(reservedCharMap).join("")}]`,
  "gu"
);
function escapeRegexMatch2(str2) {
  return str2.replaceAll(
    RX_REGEXP_ESCAPE,
    (m) => reservedCharMap[m]
  );
}
var regexpProxy2 = Symbol("regexpProxy");
var realExec2 = RegExp.prototype.exec;
RegExp.prototype.exec = function(...args) {
  if (this[regexpProxy2]) {
    return realExec2.apply(this[regexpProxy2], args);
  }
  return realExec2.apply(this, args);
};
var proxyRegExp2;
var regexProxyOptions2 = Object.freeze({
  get(original, key) {
    if (typeof key == "string" && key.match(/^[igmusyv]+$/)) {
      return proxyRegExp2(original, key);
    }
    if (key == regexpProxy2) {
      return original;
    }
    return original[key];
  },
  set(original, key, value) {
    original[key] = value;
    return true;
  }
});
proxyRegExp2 = (parent, flags) => {
  const regex3 = new RegExp(parent, flags);
  const output2 = new Proxy(regex3, regexProxyOptions2);
  Object.setPrototypeOf(output2, Object.getPrototypeOf(regex3));
  return output2;
};
function regexWithStripWarning2(shouldStrip) {
  return (strings, ...values) => {
    let newRegexString = "";
    for (const [string2, value] of zip(strings, values)) {
      newRegexString += string2;
      if (value instanceof RegExp) {
        if (!shouldStrip && value.flags.replace(/g/, "").length > 0) {
          console.warn(`Warning: flags inside of regex:
    The RegExp trigging this warning is: ${value}
    When calling the regex interpolater (e.g. regex\`something\${stuff}\`)
    one of the \${} values (the one above) was a RegExp with a flag enabled
    e.g. /stuff/i  <- i = ignoreCase flag enabled
    When the /stuff/i gets interpolated, its going to loose its flags
    (thats what I'm warning you about)
    
    To disable/ignore this warning do:
        regex.stripFlags\`something\${/stuff/i}\`
    If you want to add flags to the output of regex\`something\${stuff}\` do:
        regex\`something\${stuff}\`.i   // ignoreCase
        regex\`something\${stuff}\`.ig  // ignoreCase and global
        regex\`something\${stuff}\`.gi  // functionally equivlent
`);
        }
        newRegexString += `(?:${value.source})`;
      } else if (value != null) {
        newRegexString += escapeRegexMatch2(toString2(value));
      }
    }
    return proxyRegExp2(newRegexString, "");
  };
}
var regex2 = regexWithStripWarning2(false);
regex2.stripFlags = regexWithStripWarning2(true);
var textDecoder2 = new TextDecoder("utf-8");
var textEncoder2 = new TextEncoder("utf-8");
var utf8BytesToString2 = textDecoder2.decode.bind(textDecoder2);
var stringToUtf8Bytes2 = textEncoder2.encode.bind(textEncoder2);

// https://deno.land/std@0.168.0/encoding/_yaml/error.ts
var YAMLError = class extends Error {
  constructor(message = "(unknown reason)", mark = "") {
    super(`${message} ${mark}`);
    this.mark = mark;
    this.name = this.constructor.name;
  }
  toString(_compact) {
    return `${this.name}: ${this.message} ${this.mark}`;
  }
};

// https://deno.land/std@0.168.0/encoding/_yaml/utils.ts
function isBoolean(value) {
  return typeof value === "boolean" || value instanceof Boolean;
}
function isObject(value) {
  return value !== null && typeof value === "object";
}
function repeat(str2, count4) {
  let result2 = "";
  for (let cycle = 0; cycle < count4; cycle++) {
    result2 += str2;
  }
  return result2;
}
function isNegativeZero(i2) {
  return i2 === 0 && Number.NEGATIVE_INFINITY === 1 / i2;
}

// https://deno.land/std@0.168.0/encoding/_yaml/mark.ts
var Mark = class {
  constructor(name, buffer, position, line, column) {
    this.name = name;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
  }
  getSnippet(indent4 = 4, maxLength2 = 75) {
    if (!this.buffer)
      return null;
    let head = "";
    let start = this.position;
    while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
      start -= 1;
      if (this.position - start > maxLength2 / 2 - 1) {
        head = " ... ";
        start += 5;
        break;
      }
    }
    let tail = "";
    let end = this.position;
    while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
      end += 1;
      if (end - this.position > maxLength2 / 2 - 1) {
        tail = " ... ";
        end -= 5;
        break;
      }
    }
    const snippet = this.buffer.slice(start, end);
    return `${repeat(" ", indent4)}${head}${snippet}${tail}
${repeat(
      " ",
      indent4 + this.position - start + head.length
    )}^`;
  }
  toString(compact) {
    let snippet, where = "";
    if (this.name) {
      where += `in "${this.name}" `;
    }
    where += `at line ${this.line + 1}, column ${this.column + 1}`;
    if (!compact) {
      snippet = this.getSnippet();
      if (snippet) {
        where += `:
${snippet}`;
      }
    }
    return where;
  }
};

// https://deno.land/std@0.168.0/encoding/_yaml/schema.ts
function compileList(schema, name, result2) {
  const exclude = [];
  for (const includedSchema of schema.include) {
    result2 = compileList(includedSchema, name, result2);
  }
  for (const currentType of schema[name]) {
    for (let previousIndex = 0; previousIndex < result2.length; previousIndex++) {
      const previousType = result2[previousIndex];
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    }
    result2.push(currentType);
  }
  return result2.filter((_type, index) => !exclude.includes(index));
}
function compileMap(...typesList) {
  const result2 = {
    fallback: {},
    mapping: {},
    scalar: {},
    sequence: {}
  };
  for (const types of typesList) {
    for (const type of types) {
      if (type.kind !== null) {
        result2[type.kind][type.tag] = result2["fallback"][type.tag] = type;
      }
    }
  }
  return result2;
}
var Schema = class _Schema {
  static SCHEMA_DEFAULT;
  implicit;
  explicit;
  include;
  compiledImplicit;
  compiledExplicit;
  compiledTypeMap;
  constructor(definition) {
    this.explicit = definition.explicit || [];
    this.implicit = definition.implicit || [];
    this.include = definition.include || [];
    for (const type of this.implicit) {
      if (type.loadKind && type.loadKind !== "scalar") {
        throw new YAMLError(
          "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported."
        );
      }
    }
    this.compiledImplicit = compileList(this, "implicit", []);
    this.compiledExplicit = compileList(this, "explicit", []);
    this.compiledTypeMap = compileMap(
      this.compiledImplicit,
      this.compiledExplicit
    );
  }
  /* Returns a new extended schema from current schema */
  extend(definition) {
    return new _Schema({
      implicit: [
        .../* @__PURE__ */ new Set([...this.implicit, ...definition?.implicit ?? []])
      ],
      explicit: [
        .../* @__PURE__ */ new Set([...this.explicit, ...definition?.explicit ?? []])
      ],
      include: [.../* @__PURE__ */ new Set([...this.include, ...definition?.include ?? []])]
    });
  }
  static create() {
  }
};

// https://deno.land/std@0.168.0/encoding/_yaml/type.ts
var DEFAULT_RESOLVE = () => true;
var DEFAULT_CONSTRUCT = (data) => data;
function checkTagFormat(tag) {
  return tag;
}
var Type2 = class {
  tag;
  kind = null;
  instanceOf;
  predicate;
  represent;
  defaultStyle;
  styleAliases;
  loadKind;
  constructor(tag, options) {
    this.tag = checkTagFormat(tag);
    if (options) {
      this.kind = options.kind;
      this.resolve = options.resolve || DEFAULT_RESOLVE;
      this.construct = options.construct || DEFAULT_CONSTRUCT;
      this.instanceOf = options.instanceOf;
      this.predicate = options.predicate;
      this.represent = options.represent;
      this.defaultStyle = options.defaultStyle;
      this.styleAliases = options.styleAliases;
    }
  }
  resolve = () => true;
  construct = (data) => data;
};

// https://deno.land/std@0.168.0/_util/asserts.ts
var DenoStdInternalError5 = class extends Error {
  constructor(message) {
    super(message);
    this.name = "DenoStdInternalError";
  }
};
function assert8(expr, msg = "") {
  if (!expr) {
    throw new DenoStdInternalError5(msg);
  }
}

// https://deno.land/std@0.168.0/bytes/copy.ts
function copy6(src, dst, off = 0) {
  off = Math.max(0, Math.min(off, dst.byteLength));
  const dstBytesAvailable = dst.byteLength - off;
  if (src.byteLength > dstBytesAvailable) {
    src = src.subarray(0, dstBytesAvailable);
  }
  dst.set(src, off);
  return src.byteLength;
}

// https://deno.land/std@0.168.0/io/buf_reader.ts
var CR4 = "\r".charCodeAt(0);
var LF4 = "\n".charCodeAt(0);

// https://deno.land/std@0.168.0/io/buffer.ts
var MIN_READ3 = 32 * 1024;
var MAX_SIZE3 = 2 ** 32 - 2;
var Buffer4 = class {
  #buf;
  // contents are the bytes buf[off : len(buf)]
  #off = 0;
  // read at buf[off], write at buf[buf.byteLength]
  constructor(ab) {
    this.#buf = ab === void 0 ? new Uint8Array(0) : new Uint8Array(ab);
  }
  /** Returns a slice holding the unread portion of the buffer.
   *
   * The slice is valid for use only until the next buffer modification (that
   * is, only until the next call to a method like `read()`, `write()`,
   * `reset()`, or `truncate()`). If `options.copy` is false the slice aliases the buffer content at
   * least until the next buffer modification, so immediate changes to the
   * slice will affect the result of future reads.
   * @param [options={ copy: true }]
   */
  bytes(options = { copy: true }) {
    if (options.copy === false)
      return this.#buf.subarray(this.#off);
    return this.#buf.slice(this.#off);
  }
  /** Returns whether the unread portion of the buffer is empty. */
  empty() {
    return this.#buf.byteLength <= this.#off;
  }
  /** A read only number of bytes of the unread portion of the buffer. */
  get length() {
    return this.#buf.byteLength - this.#off;
  }
  /** The read only capacity of the buffer's underlying byte slice, that is,
   * the total space allocated for the buffer's data. */
  get capacity() {
    return this.#buf.buffer.byteLength;
  }
  /** Discards all but the first `n` unread bytes from the buffer but
   * continues to use the same allocated storage. It throws if `n` is
   * negative or greater than the length of the buffer. */
  truncate(n) {
    if (n === 0) {
      this.reset();
      return;
    }
    if (n < 0 || n > this.length) {
      throw Error("bytes.Buffer: truncation out of range");
    }
    this.#reslice(this.#off + n);
  }
  reset() {
    this.#reslice(0);
    this.#off = 0;
  }
  #tryGrowByReslice(n) {
    const l2 = this.#buf.byteLength;
    if (n <= this.capacity - l2) {
      this.#reslice(l2 + n);
      return l2;
    }
    return -1;
  }
  #reslice(len) {
    assert8(len <= this.#buf.buffer.byteLength);
    this.#buf = new Uint8Array(this.#buf.buffer, 0, len);
  }
  /** Reads the next `p.length` bytes from the buffer or until the buffer is
   * drained. Returns the number of bytes read. If the buffer has no data to
   * return, the return is EOF (`null`). */
  readSync(p) {
    if (this.empty()) {
      this.reset();
      if (p.byteLength === 0) {
        return 0;
      }
      return null;
    }
    const nread = copy6(this.#buf.subarray(this.#off), p);
    this.#off += nread;
    return nread;
  }
  /** Reads the next `p.length` bytes from the buffer or until the buffer is
   * drained. Resolves to the number of bytes read. If the buffer has no
   * data to return, resolves to EOF (`null`).
   *
   * NOTE: This methods reads bytes synchronously; it's provided for
   * compatibility with `Reader` interfaces.
   */
  read(p) {
    const rr = this.readSync(p);
    return Promise.resolve(rr);
  }
  writeSync(p) {
    const m = this.#grow(p.byteLength);
    return copy6(p, this.#buf, m);
  }
  /** NOTE: This methods writes bytes synchronously; it's provided for
   * compatibility with `Writer` interface. */
  write(p) {
    const n = this.writeSync(p);
    return Promise.resolve(n);
  }
  #grow(n) {
    const m = this.length;
    if (m === 0 && this.#off !== 0) {
      this.reset();
    }
    const i2 = this.#tryGrowByReslice(n);
    if (i2 >= 0) {
      return i2;
    }
    const c = this.capacity;
    if (n <= Math.floor(c / 2) - m) {
      copy6(this.#buf.subarray(this.#off), this.#buf);
    } else if (c + n > MAX_SIZE3) {
      throw new Error("The buffer cannot be grown beyond the maximum size.");
    } else {
      const buf = new Uint8Array(Math.min(2 * c + n, MAX_SIZE3));
      copy6(this.#buf.subarray(this.#off), buf);
      this.#buf = buf;
    }
    this.#off = 0;
    this.#reslice(Math.min(m + n, MAX_SIZE3));
    return m;
  }
  /** Grows the buffer's capacity, if necessary, to guarantee space for
   * another `n` bytes. After `.grow(n)`, at least `n` bytes can be written to
   * the buffer without another allocation. If `n` is negative, `.grow()` will
   * throw. If the buffer can't grow it will throw an error.
   *
   * Based on Go Lang's
   * [Buffer.Grow](https://golang.org/pkg/bytes/#Buffer.Grow). */
  grow(n) {
    if (n < 0) {
      throw Error("Buffer.grow: negative count");
    }
    const m = this.#grow(n);
    this.#reslice(m);
  }
  /** Reads data from `r` until EOF (`null`) and appends it to the buffer,
   * growing the buffer as needed. It resolves to the number of bytes read.
   * If the buffer becomes too large, `.readFrom()` will reject with an error.
   *
   * Based on Go Lang's
   * [Buffer.ReadFrom](https://golang.org/pkg/bytes/#Buffer.ReadFrom). */
  async readFrom(r) {
    let n = 0;
    const tmp = new Uint8Array(MIN_READ3);
    while (true) {
      const shouldGrow = this.capacity - this.length < MIN_READ3;
      const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
      const nread = await r.read(buf);
      if (nread === null) {
        return n;
      }
      if (shouldGrow)
        this.writeSync(buf.subarray(0, nread));
      else
        this.#reslice(this.length + nread);
      n += nread;
    }
  }
  /** Reads data from `r` until EOF (`null`) and appends it to the buffer,
   * growing the buffer as needed. It returns the number of bytes read. If the
   * buffer becomes too large, `.readFromSync()` will throw an error.
   *
   * Based on Go Lang's
   * [Buffer.ReadFrom](https://golang.org/pkg/bytes/#Buffer.ReadFrom). */
  readFromSync(r) {
    let n = 0;
    const tmp = new Uint8Array(MIN_READ3);
    while (true) {
      const shouldGrow = this.capacity - this.length < MIN_READ3;
      const buf = shouldGrow ? tmp : new Uint8Array(this.#buf.buffer, this.length);
      const nread = r.readSync(buf);
      if (nread === null) {
        return n;
      }
      if (shouldGrow)
        this.writeSync(buf.subarray(0, nread));
      else
        this.#reslice(this.length + nread);
      n += nread;
    }
  }
};

// https://deno.land/std@0.168.0/encoding/_yaml/type/binary.ts
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  let code2;
  let bitlen = 0;
  const max = data.length;
  const map2 = BASE64_MAP;
  for (let idx = 0; idx < max; idx++) {
    code2 = map2.indexOf(data.charAt(idx));
    if (code2 > 64)
      continue;
    if (code2 < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  const input = data.replace(/[\r\n=]/g, "");
  const max = input.length;
  const map2 = BASE64_MAP;
  const result2 = [];
  let bits = 0;
  for (let idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result2.push(bits >> 16 & 255);
      result2.push(bits >> 8 & 255);
      result2.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  const tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result2.push(bits >> 16 & 255);
    result2.push(bits >> 8 & 255);
    result2.push(bits & 255);
  } else if (tailbits === 18) {
    result2.push(bits >> 10 & 255);
    result2.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result2.push(bits >> 4 & 255);
  }
  return new Buffer4(new Uint8Array(result2));
}
function representYamlBinary(object) {
  const max = object.length;
  const map2 = BASE64_MAP;
  let result2 = "";
  let bits = 0;
  for (let idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result2 += map2[bits >> 18 & 63];
      result2 += map2[bits >> 12 & 63];
      result2 += map2[bits >> 6 & 63];
      result2 += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  const tail = max % 3;
  if (tail === 0) {
    result2 += map2[bits >> 18 & 63];
    result2 += map2[bits >> 12 & 63];
    result2 += map2[bits >> 6 & 63];
    result2 += map2[bits & 63];
  } else if (tail === 2) {
    result2 += map2[bits >> 10 & 63];
    result2 += map2[bits >> 4 & 63];
    result2 += map2[bits << 2 & 63];
    result2 += map2[64];
  } else if (tail === 1) {
    result2 += map2[bits >> 2 & 63];
    result2 += map2[bits << 4 & 63];
    result2 += map2[64];
    result2 += map2[64];
  }
  return result2;
}
function isBinary(obj) {
  if (typeof obj?.readSync !== "function") {
    return false;
  }
  const buf = new Buffer4();
  try {
    if (0 > buf.readFromSync(obj))
      return true;
    return false;
  } catch {
    return false;
  } finally {
    buf.reset();
  }
}
var binary = new Type2("tag:yaml.org,2002:binary", {
  construct: constructYamlBinary,
  kind: "scalar",
  predicate: isBinary,
  represent: representYamlBinary,
  resolve: resolveYamlBinary
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/bool.ts
function resolveYamlBoolean(data) {
  const max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
var bool = new Type2("tag:yaml.org,2002:bool", {
  construct: constructYamlBoolean,
  defaultStyle: "lowercase",
  kind: "scalar",
  predicate: isBoolean,
  represent: {
    lowercase(object) {
      return object ? "true" : "false";
    },
    uppercase(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase(object) {
      return object ? "True" : "False";
    }
  },
  resolve: resolveYamlBoolean
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/float.ts
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  let value = data.replace(/_/g, "").toLowerCase();
  const sign = value[0] === "-" ? -1 : 1;
  const digits = [];
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  }
  if (value === ".nan") {
    return NaN;
  }
  if (value.indexOf(":") >= 0) {
    value.split(":").forEach((v) => {
      digits.unshift(parseFloat(v));
    });
    let valueNb = 0;
    let base = 1;
    digits.forEach((d) => {
      valueNb += d * base;
      base *= 60;
    });
    return sign * valueNb;
  }
  return sign * parseFloat(value);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (isNegativeZero(object)) {
    return "-0.0";
  }
  const res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || isNegativeZero(object));
}
var float = new Type2("tag:yaml.org,2002:float", {
  construct: constructYamlFloat,
  defaultStyle: "lowercase",
  kind: "scalar",
  predicate: isFloat,
  represent: representYamlFloat,
  resolve: resolveYamlFloat
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/function.ts
function reconstructFunction(code2) {
  const func2 = new Function(`return ${code2}`)();
  if (!(func2 instanceof Function)) {
    throw new TypeError(`Expected function but got ${typeof func2}: ${code2}`);
  }
  return func2;
}
var func = new Type2("tag:yaml.org,2002:js/function", {
  kind: "scalar",
  resolve(data) {
    if (data === null) {
      return false;
    }
    try {
      reconstructFunction(`${data}`);
      return true;
    } catch (_err) {
      return false;
    }
  },
  construct(data) {
    return reconstructFunction(data);
  },
  predicate(object) {
    return object instanceof Function;
  },
  represent(object) {
    return object.toString();
  }
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/int.ts
function isHexCode(c) {
  return 48 <= /* 0 */
  c && c <= 57 || 65 <= /* A */
  c && c <= 70 || 97 <= /* a */
  c && c <= 102;
}
function isOctCode(c) {
  return 48 <= /* 0 */
  c && c <= 55;
}
function isDecCode(c) {
  return 48 <= /* 0 */
  c && c <= 57;
}
function resolveYamlInteger(data) {
  const max = data.length;
  let index = 0;
  let hasDigits = false;
  if (!max)
    return false;
  let ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    for (; index < max; index++) {
      ch = data[index];
      if (ch === "_")
        continue;
      if (!isOctCode(data.charCodeAt(index)))
        return false;
      hasDigits = true;
    }
    return hasDigits && ch !== "_";
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (ch === ":")
      break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  if (ch !== ":")
    return true;
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function constructYamlInteger(data) {
  let value = data;
  const digits = [];
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  let sign = 1;
  let ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }
  if (value.indexOf(":") !== -1) {
    value.split(":").forEach((v) => {
      digits.unshift(parseInt(v, 10));
    });
    let valueInt = 0;
    let base = 1;
    digits.forEach((d) => {
      valueInt += d * base;
      base *= 60;
    });
    return sign * valueInt;
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && object % 1 === 0 && !isNegativeZero(object);
}
var int = new Type2("tag:yaml.org,2002:int", {
  construct: constructYamlInteger,
  defaultStyle: "decimal",
  kind: "scalar",
  predicate: isInteger,
  represent: {
    binary(obj) {
      return obj >= 0 ? `0b${obj.toString(2)}` : `-0b${obj.toString(2).slice(1)}`;
    },
    octal(obj) {
      return obj >= 0 ? `0${obj.toString(8)}` : `-0${obj.toString(8).slice(1)}`;
    },
    decimal(obj) {
      return obj.toString(10);
    },
    hexadecimal(obj) {
      return obj >= 0 ? `0x${obj.toString(16).toUpperCase()}` : `-0x${obj.toString(16).toUpperCase().slice(1)}`;
    }
  },
  resolve: resolveYamlInteger,
  styleAliases: {
    binary: [2, "bin"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"],
    octal: [8, "oct"]
  }
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/map.ts
var map = new Type2("tag:yaml.org,2002:map", {
  construct(data) {
    return data !== null ? data : {};
  },
  kind: "mapping"
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/merge.ts
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new Type2("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/nil.ts
function resolveYamlNull(data) {
  const max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var nil = new Type2("tag:yaml.org,2002:null", {
  construct: constructYamlNull,
  defaultStyle: "lowercase",
  kind: "scalar",
  predicate: isNull,
  represent: {
    canonical() {
      return "~";
    },
    lowercase() {
      return "null";
    },
    uppercase() {
      return "NULL";
    },
    camelcase() {
      return "Null";
    }
  },
  resolve: resolveYamlNull
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/omap.ts
var { hasOwn } = Object;
var _toString = Object.prototype.toString;
function resolveYamlOmap(data) {
  const objectKeys = [];
  let pairKey = "";
  let pairHasKey = false;
  for (const pair of data) {
    pairHasKey = false;
    if (_toString.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (hasOwn(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new Type2("tag:yaml.org,2002:omap", {
  construct: constructYamlOmap,
  kind: "sequence",
  resolve: resolveYamlOmap
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/pairs.ts
var _toString2 = Object.prototype.toString;
function resolveYamlPairs(data) {
  const result2 = Array.from({ length: data.length });
  for (let index = 0; index < data.length; index++) {
    const pair = data[index];
    if (_toString2.call(pair) !== "[object Object]")
      return false;
    const keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result2[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  const result2 = Array.from({ length: data.length });
  for (let index = 0; index < data.length; index += 1) {
    const pair = data[index];
    const keys = Object.keys(pair);
    result2[index] = [keys[0], pair[keys[0]]];
  }
  return result2;
}
var pairs = new Type2("tag:yaml.org,2002:pairs", {
  construct: constructYamlPairs,
  kind: "sequence",
  resolve: resolveYamlPairs
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/regexp.ts
var REGEXP = /^\/(?<regexp>[\s\S]+)\/(?<modifiers>[gismuy]*)$/;
var regexp = new Type2("tag:yaml.org,2002:js/regexp", {
  kind: "scalar",
  resolve(data) {
    if (data === null || !data.length) {
      return false;
    }
    const regexp2 = `${data}`;
    if (regexp2.charAt(0) === "/") {
      if (!REGEXP.test(data)) {
        return false;
      }
      const modifiers = [...regexp2.match(REGEXP)?.groups?.modifiers ?? ""];
      if (new Set(modifiers).size < modifiers.length) {
        return false;
      }
    }
    return true;
  },
  construct(data) {
    const { regexp: regexp2 = `${data}`, modifiers = "" } = `${data}`.match(REGEXP)?.groups ?? {};
    return new RegExp(regexp2, modifiers);
  },
  predicate(object) {
    return object instanceof RegExp;
  },
  represent(object) {
    return object.toString();
  }
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/seq.ts
var seq = new Type2("tag:yaml.org,2002:seq", {
  construct(data) {
    return data !== null ? data : [];
  },
  kind: "sequence"
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/set.ts
var { hasOwn: hasOwn2 } = Object;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  for (const key in data) {
    if (hasOwn2(data, key)) {
      if (data[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new Type2("tag:yaml.org,2002:set", {
  construct: constructYamlSet,
  kind: "mapping",
  resolve: resolveYamlSet
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/str.ts
var str = new Type2("tag:yaml.org,2002:str", {
  construct(data) {
    return data !== null ? data : "";
  },
  kind: "scalar"
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/timestamp.ts
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  // [3] day
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  // [11] tz_minute
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  let match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  const year = +match[1];
  const month = +match[2] - 1;
  const day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  const hour = +match[4];
  const minute = +match[5];
  const second = +match[6];
  let fraction = 0;
  if (match[7]) {
    let partFraction = match[7].slice(0, 3);
    while (partFraction.length < 3) {
      partFraction += "0";
    }
    fraction = +partFraction;
  }
  let delta = null;
  if (match[9]) {
    const tzHour = +match[10];
    const tzMinute = +(match[11] || 0);
    delta = (tzHour * 60 + tzMinute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  const date = new Date(
    Date.UTC(year, month, day, hour, minute, second, fraction)
  );
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(date) {
  return date.toISOString();
}
var timestamp = new Type2("tag:yaml.org,2002:timestamp", {
  construct: constructYamlTimestamp,
  instanceOf: Date,
  kind: "scalar",
  represent: representYamlTimestamp,
  resolve: resolveYamlTimestamp
});

// https://deno.land/std@0.168.0/encoding/_yaml/type/undefined.ts
var undefinedType = new Type2("tag:yaml.org,2002:js/undefined", {
  kind: "scalar",
  resolve() {
    return true;
  },
  construct() {
    return void 0;
  },
  predicate(object) {
    return typeof object === "undefined";
  },
  represent() {
    return "";
  }
});

// https://deno.land/std@0.168.0/encoding/_yaml/schema/failsafe.ts
var failsafe = new Schema({
  explicit: [str, seq, map]
});

// https://deno.land/std@0.168.0/encoding/_yaml/schema/json.ts
var json = new Schema({
  implicit: [nil, bool, int, float],
  include: [failsafe]
});

// https://deno.land/std@0.168.0/encoding/_yaml/schema/core.ts
var core = new Schema({
  include: [json]
});

// https://deno.land/std@0.168.0/encoding/_yaml/schema/default.ts
var def = new Schema({
  explicit: [binary, omap, pairs, set],
  implicit: [timestamp, merge],
  include: [core]
});

// https://deno.land/std@0.168.0/encoding/_yaml/schema/extended.ts
var extended = new Schema({
  explicit: [regexp, undefinedType],
  include: [def]
});

// https://deno.land/std@0.168.0/encoding/_yaml/state.ts
var State = class {
  constructor(schema = def) {
    this.schema = schema;
  }
};

// https://deno.land/std@0.168.0/encoding/_yaml/loader/loader_state.ts
var LoaderState = class extends State {
  constructor(input, {
    filename,
    schema,
    onWarning,
    legacy = false,
    json: json2 = false,
    listener = null
  }) {
    super(schema);
    this.input = input;
    this.filename = filename;
    this.onWarning = onWarning;
    this.legacy = legacy;
    this.json = json2;
    this.listener = listener;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
  }
  documents = [];
  length;
  lineIndent = 0;
  lineStart = 0;
  position = 0;
  line = 0;
  filename;
  onWarning;
  legacy;
  json;
  listener;
  implicitTypes;
  typeMap;
  version;
  checkLineBreaks;
  tagMap;
  anchorMap;
  tag;
  anchor;
  kind;
  result = "";
};

// https://deno.land/std@0.168.0/encoding/_yaml/loader/loader.ts
var { hasOwn: hasOwn3 } = Object;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = (
  // deno-lint-ignore no-control-regex
  /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
);
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isEOL(c) {
  return c === 10 || /* LF */
  c === 13;
}
function isWhiteSpace(c) {
  return c === 9 || /* Tab */
  c === 32;
}
function isWsOrEol(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
function isFlowIndicator(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
function fromHexCode(c) {
  if (48 <= /* 0 */
  c && c <= 57) {
    return c - 48;
  }
  const lc = c | 32;
  if (97 <= /* a */
  lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c) {
  if (48 <= /* 0 */
  c && c <= 57) {
    return c - 48;
  }
  return -1;
}
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = Array.from({ length: 256 });
var simpleEscapeMap = Array.from({ length: 256 });
for (let i2 = 0; i2 < 256; i2++) {
  simpleEscapeCheck[i2] = simpleEscapeSequence(i2) ? 1 : 0;
  simpleEscapeMap[i2] = simpleEscapeSequence(i2);
}
function generateError(state, message) {
  return new YAMLError(
    message,
    new Mark(
      state.filename,
      state.input,
      state.position,
      state.line,
      state.position - state.lineStart
    )
  );
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML(state, _name, ...args) {
    if (state.version !== null) {
      return throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      return throwError(state, "YAML directive accepts exactly one argument");
    }
    const match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      return throwError(state, "ill-formed argument of the YAML directive");
    }
    const major = parseInt(match[1], 10);
    const minor = parseInt(match[2], 10);
    if (major !== 1) {
      return throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      return throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG(state, _name, ...args) {
    if (args.length !== 2) {
      return throwError(state, "TAG directive accepts exactly two arguments");
    }
    const handle = args[0];
    const prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      return throwError(
        state,
        "ill-formed tag handle (first argument) of the TAG directive"
      );
    }
    if (state.tagMap && hasOwn3(state.tagMap, handle)) {
      return throwError(
        state,
        `there is a previously declared suffix for "${handle}" tag handle`
      );
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      return throwError(
        state,
        "ill-formed tag prefix (second argument) of the TAG directive"
      );
    }
    if (typeof state.tagMap === "undefined") {
      state.tagMap = {};
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  let result2;
  if (start < end) {
    result2 = state.input.slice(start, end);
    if (checkJson) {
      for (let position = 0, length = result2.length; position < length; position++) {
        const character = result2.charCodeAt(position);
        if (!(character === 9 || 32 <= character && character <= 1114111)) {
          return throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(result2)) {
      return throwError(state, "the stream contains non-printable characters");
    }
    state.result += result2;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  if (!isObject(source)) {
    return throwError(
      state,
      "cannot merge mappings; the provided source object is unacceptable"
    );
  }
  const keys = Object.keys(source);
  for (let i2 = 0, len = keys.length; i2 < len; i2++) {
    const key = keys[i2];
    if (!hasOwn3(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, result2, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (let index = 0, quantity = keyNode.length; index < quantity; index++) {
      if (Array.isArray(keyNode[index])) {
        return throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (result2 === null) {
    result2 = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (let index = 0, quantity = valueNode.length; index < quantity; index++) {
        mergeMappings(state, result2, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, result2, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !hasOwn3(overridableKeys, keyNode) && hasOwn3(result2, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      return throwError(state, "duplicated mapping key");
    }
    result2[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }
  return result2;
}
function readLineBreak(state) {
  const ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    return throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  let lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (isWhiteSpace(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && /* LF */
      ch !== 13 && /* CR */
      ch !== 0);
    }
    if (isEOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  let _position = state.position;
  let ch = state.input.charCodeAt(_position);
  if ((ch === 45 || /* - */
  ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || isWsOrEol(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count4) {
  if (count4 === 1) {
    state.result += " ";
  } else if (count4 > 1) {
    state.result += repeat("\n", count4 - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  const kind = state.kind;
  const result2 = state.result;
  let ch = state.input.charCodeAt(state.position);
  if (isWsOrEol(ch) || isFlowIndicator(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  let following;
  if (ch === 63 || /* ? */
  ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (isWsOrEol(following) || withinFlowCollection && isFlowIndicator(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  let captureEnd, captureStart = captureEnd = state.position;
  let hasPendingContent = false;
  let line = 0;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (isWsOrEol(following) || withinFlowCollection && isFlowIndicator(following)) {
        break;
      }
    } else if (ch === 35) {
      const preceding = state.input.charCodeAt(state.position - 1);
      if (isWsOrEol(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && isFlowIndicator(ch)) {
      break;
    } else if (isEOL(ch)) {
      line = state.line;
      const lineStart = state.lineStart;
      const lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = line;
        state.lineStart = lineStart;
        state.lineIndent = lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!isWhiteSpace(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = kind;
  state.result = result2;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  let ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (isEOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      return throwError(
        state,
        "unexpected end of the document within a single quoted scalar"
      );
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  return throwError(
    state,
    "unexpected end of the stream within a single quoted scalar"
  );
}
function readDoubleQuotedScalar(state, nodeIndent) {
  let ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  let captureEnd, captureStart = captureEnd = state.position;
  let tmp;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    }
    if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (isEOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        let hexLength = tmp;
        let hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            return throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        return throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (isEOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      return throwError(
        state,
        "unexpected end of the document within a double quoted scalar"
      );
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  return throwError(
    state,
    "unexpected end of the stream within a double quoted scalar"
  );
}
function readFlowCollection(state, nodeIndent) {
  let ch = state.input.charCodeAt(state.position);
  let terminator;
  let isMapping = true;
  let result2 = {};
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    result2 = [];
  } else if (ch === 123) {
    terminator = 125;
  } else {
    return false;
  }
  if (state.anchor !== null && typeof state.anchor != "undefined" && typeof state.anchorMap != "undefined") {
    state.anchorMap[state.anchor] = result2;
  }
  ch = state.input.charCodeAt(++state.position);
  const tag = state.tag, anchor = state.anchor;
  let readNext = true;
  let valueNode, keyNode, keyTag = keyNode = valueNode = null, isExplicitPair, isPair = isExplicitPair = false;
  let following = 0, line = 0;
  const overridableKeys = {};
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = tag;
      state.anchor = anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = result2;
      return true;
    }
    if (!readNext) {
      return throwError(state, "missed comma between flow collection entries");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (isWsOrEol(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag || null;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(
        state,
        result2,
        overridableKeys,
        keyTag,
        keyNode,
        valueNode
      );
    } else if (isPair) {
      result2.push(
        storeMappingPair(
          state,
          null,
          overridableKeys,
          keyTag,
          keyNode,
          valueNode
        )
      );
    } else {
      result2.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  return throwError(
    state,
    "unexpected end of the stream within a flow collection"
  );
}
function readBlockScalar(state, nodeIndent) {
  let chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false;
  let ch = state.input.charCodeAt(state.position);
  let folding = false;
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  let tmp = 0;
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || /* + */
    ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        return throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        return throwError(
          state,
          "bad explicit indentation width of a block scalar; it cannot be less than one"
        );
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        return throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (isWhiteSpace(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (isWhiteSpace(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!isEOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (isEOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += repeat(
          "\n",
          didReadContent ? 1 + emptyLines : emptyLines
        );
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (isWhiteSpace(ch)) {
        atMoreIndented = true;
        state.result += repeat(
          "\n",
          didReadContent ? 1 + emptyLines : emptyLines
        );
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += repeat("\n", emptyLines);
      }
    } else {
      state.result += repeat(
        "\n",
        didReadContent ? 1 + emptyLines : emptyLines
      );
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    const captureStart = state.position;
    while (!isEOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  let line, following, detected = false, ch;
  const tag = state.tag, anchor = state.anchor, result2 = [];
  if (state.anchor !== null && typeof state.anchor !== "undefined" && typeof state.anchorMap !== "undefined") {
    state.anchorMap[state.anchor] = result2;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!isWsOrEol(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        result2.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    result2.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === line || state.lineIndent > nodeIndent) && ch !== 0) {
      return throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = tag;
    state.anchor = anchor;
    state.kind = "sequence";
    state.result = result2;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  const tag = state.tag, anchor = state.anchor, result2 = {}, overridableKeys = {};
  let following, allowCompact = false, line, pos, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.anchor !== null && typeof state.anchor !== "undefined" && typeof state.anchorMap !== "undefined") {
    state.anchorMap[state.anchor] = result2;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    line = state.line;
    pos = state.position;
    if ((ch === 63 || /* ? */
    ch === 58) && /* : */
    isWsOrEol(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(
            state,
            result2,
            overridableKeys,
            keyTag,
            keyNode,
            null
          );
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        return throwError(
          state,
          "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"
        );
      }
      state.position += 1;
      ch = following;
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
      if (state.line === line) {
        ch = state.input.charCodeAt(state.position);
        while (isWhiteSpace(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!isWsOrEol(ch)) {
            return throwError(
              state,
              "a whitespace character is expected after the key-value separator within a block mapping"
            );
          }
          if (atExplicitKey) {
            storeMappingPair(
              state,
              result2,
              overridableKeys,
              keyTag,
              keyNode,
              null
            );
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          return throwError(
            state,
            "can not read an implicit mapping pair; a colon is missed"
          );
        } else {
          state.tag = tag;
          state.anchor = anchor;
          return true;
        }
      } else if (detected) {
        return throwError(
          state,
          "can not read a block mapping entry; a multiline key may not be an implicit key"
        );
      } else {
        state.tag = tag;
        state.anchor = anchor;
        return true;
      }
    } else {
      break;
    }
    if (state.line === line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(
          state,
          result2,
          overridableKeys,
          keyTag,
          keyNode,
          valueNode,
          line,
          pos
        );
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if (state.lineIndent > nodeIndent && ch !== 0) {
      return throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(
      state,
      result2,
      overridableKeys,
      keyTag,
      keyNode,
      null
    );
  }
  if (detected) {
    state.tag = tag;
    state.anchor = anchor;
    state.kind = "mapping";
    state.result = result2;
  }
  return detected;
}
function readTagProperty(state) {
  let position, isVerbatim = false, isNamed = false, tagHandle = "", tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    return throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      return throwError(
        state,
        "unexpected end of the stream within a verbatim tag"
      );
    }
  } else {
    while (ch !== 0 && !isWsOrEol(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            return throwError(
              state,
              "named tag handle cannot contain such characters"
            );
          }
          isNamed = true;
          position = state.position + 1;
        } else {
          return throwError(
            state,
            "tag suffix cannot contain exclamation marks"
          );
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      return throwError(
        state,
        "tag suffix cannot contain flow indicator characters"
      );
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    return throwError(
      state,
      `tag name cannot contain such characters: ${tagName}`
    );
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (typeof state.tagMap !== "undefined" && hasOwn3(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = `!${tagName}`;
  } else if (tagHandle === "!!") {
    state.tag = `tag:yaml.org,2002:${tagName}`;
  } else {
    return throwError(state, `undeclared tag handle "${tagHandle}"`);
  }
  return true;
}
function readAnchorProperty(state) {
  let ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    return throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  const position = state.position;
  while (ch !== 0 && !isWsOrEol(ch) && !isFlowIndicator(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === position) {
    return throwError(
      state,
      "name of an anchor node must contain at least one character"
    );
  }
  state.anchor = state.input.slice(position, state.position);
  return true;
}
function readAlias(state) {
  let ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  const _position = state.position;
  while (ch !== 0 && !isWsOrEol(ch) && !isFlowIndicator(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    return throwError(
      state,
      "name of an alias node must contain at least one character"
    );
  }
  const alias = state.input.slice(_position, state.position);
  if (typeof state.anchorMap !== "undefined" && !hasOwn3(state.anchorMap, alias)) {
    return throwError(state, `unidentified alias "${alias}"`);
  }
  if (typeof state.anchorMap !== "undefined") {
    state.result = state.anchorMap[alias];
  }
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  let allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, type, flowIndent, blockIndent;
  if (state.listener && state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  const allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    const cond = CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext;
    flowIndent = cond ? parentIndent : parentIndent + 1;
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            return throwError(
              state,
              "alias node should not have Any properties"
            );
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null && typeof state.anchorMap !== "undefined") {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag !== null && state.tag !== "!") {
    if (state.tag === "?") {
      for (let typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex++) {
        type = state.implicitTypes[typeIndex];
        if (type.resolve(state.result)) {
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null && typeof state.anchorMap !== "undefined") {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (hasOwn3(state.typeMap[state.kind || "fallback"], state.tag)) {
      type = state.typeMap[state.kind || "fallback"][state.tag];
      if (state.result !== null && type.kind !== state.kind) {
        return throwError(
          state,
          `unacceptable node kind for !<${state.tag}> tag; it should be "${type.kind}", not "${state.kind}"`
        );
      }
      if (!type.resolve(state.result)) {
        return throwError(
          state,
          `cannot resolve a node with !<${state.tag}> explicit tag`
        );
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null && typeof state.anchorMap !== "undefined") {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      return throwError(state, `unknown tag !<${state.tag}>`);
    }
  }
  if (state.listener && state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  const documentStart = state.position;
  let position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    position = state.position;
    while (ch !== 0 && !isWsOrEol(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      return throwError(
        state,
        "directive name must not be less than one character in length"
      );
    }
    while (ch !== 0) {
      while (isWhiteSpace(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !isEOL(ch));
        break;
      }
      if (isEOL(ch))
        break;
      position = state.position;
      while (ch !== 0 && !isWsOrEol(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (hasOwn3(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, ...directiveArgs);
    } else {
      throwWarning(state, `unknown document directive "${directiveName}"`);
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    return throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(
    state.input.slice(documentStart, state.position)
  )) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    return throwError(
      state,
      "end of the stream or a document separator is expected"
    );
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  const state = new LoaderState(input, options);
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function load(input, options) {
  const documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return;
  }
  if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLError(
    "expected a single document in the stream, but found more"
  );
}

// https://deno.land/std@0.168.0/encoding/_yaml/parse.ts
function parse12(content, options) {
  return load(content, options);
}

// https://deno.land/std@0.168.0/encoding/_yaml/dumper/dumper_state.ts
var { hasOwn: hasOwn4 } = Object;

// https://deno.land/std@0.168.0/encoding/_yaml/dumper/dumper.ts
var { hasOwn: hasOwn5 } = Object;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";

// subrepos/cliffy/ansi/ansi_escapes.ts
var ansi_escapes_exports = {};
__export(ansi_escapes_exports, {
  bel: () => bel,
  clearScreen: () => clearScreen,
  clearTerminal: () => clearTerminal,
  cursorBackward: () => cursorBackward,
  cursorDown: () => cursorDown,
  cursorForward: () => cursorForward,
  cursorHide: () => cursorHide,
  cursorLeft: () => cursorLeft,
  cursorMove: () => cursorMove,
  cursorNextLine: () => cursorNextLine,
  cursorPosition: () => cursorPosition,
  cursorPrevLine: () => cursorPrevLine,
  cursorRestore: () => cursorRestore,
  cursorSave: () => cursorSave,
  cursorShow: () => cursorShow,
  cursorTo: () => cursorTo,
  cursorUp: () => cursorUp,
  eraseDown: () => eraseDown,
  eraseLine: () => eraseLine,
  eraseLineEnd: () => eraseLineEnd,
  eraseLineStart: () => eraseLineStart,
  eraseLines: () => eraseLines,
  eraseScreen: () => eraseScreen,
  eraseUp: () => eraseUp,
  image: () => image,
  link: () => link,
  scrollDown: () => scrollDown,
  scrollUp: () => scrollUp
});

// https://deno.land/std@0.196.0/encoding/base64.ts
var base64abc = [
  "A",
  "B",
  "C",
  "D",
  "E",
  "F",
  "G",
  "H",
  "I",
  "J",
  "K",
  "L",
  "M",
  "N",
  "O",
  "P",
  "Q",
  "R",
  "S",
  "T",
  "U",
  "V",
  "W",
  "X",
  "Y",
  "Z",
  "a",
  "b",
  "c",
  "d",
  "e",
  "f",
  "g",
  "h",
  "i",
  "j",
  "k",
  "l",
  "m",
  "n",
  "o",
  "p",
  "q",
  "r",
  "s",
  "t",
  "u",
  "v",
  "w",
  "x",
  "y",
  "z",
  "0",
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "+",
  "/"
];
function encode(data) {
  const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
  let result2 = "", i2;
  const l2 = uint8.length;
  for (i2 = 2; i2 < l2; i2 += 3) {
    result2 += base64abc[uint8[i2 - 2] >> 2];
    result2 += base64abc[(uint8[i2 - 2] & 3) << 4 | uint8[i2 - 1] >> 4];
    result2 += base64abc[(uint8[i2 - 1] & 15) << 2 | uint8[i2] >> 6];
    result2 += base64abc[uint8[i2] & 63];
  }
  if (i2 === l2 + 1) {
    result2 += base64abc[uint8[i2 - 2] >> 2];
    result2 += base64abc[(uint8[i2 - 2] & 3) << 4];
    result2 += "==";
  }
  if (i2 === l2) {
    result2 += base64abc[uint8[i2 - 2] >> 2];
    result2 += base64abc[(uint8[i2 - 2] & 3) << 4 | uint8[i2 - 1] >> 4];
    result2 += base64abc[(uint8[i2 - 1] & 15) << 2];
    result2 += "=";
  }
  return result2;
}

// subrepos/cliffy/ansi/ansi_escapes.ts
var ESC = "\x1B";
var CSI = `${ESC}[`;
var OSC = `${ESC}]`;
var SEP5 = ";";
var bel = "\x07";
var cursorPosition = `${CSI}6n`;
function cursorTo(x, y) {
  if (typeof y !== "number") {
    return `${CSI}${x}G`;
  }
  return `${CSI}${y};${x}H`;
}
function cursorMove(x, y) {
  let ret = "";
  if (x < 0) {
    ret += `${CSI}${-x}D`;
  } else if (x > 0) {
    ret += `${CSI}${x}C`;
  }
  if (y < 0) {
    ret += `${CSI}${-y}A`;
  } else if (y > 0) {
    ret += `${CSI}${y}B`;
  }
  return ret;
}
function cursorUp(count4 = 1) {
  return `${CSI}${count4}A`;
}
function cursorDown(count4 = 1) {
  return `${CSI}${count4}B`;
}
function cursorForward(count4 = 1) {
  return `${CSI}${count4}C`;
}
function cursorBackward(count4 = 1) {
  return `${CSI}${count4}D`;
}
function cursorNextLine(count4 = 1) {
  return `${CSI}E`.repeat(count4);
}
function cursorPrevLine(count4 = 1) {
  return `${CSI}F`.repeat(count4);
}
var cursorLeft = `${CSI}G`;
var cursorHide = `${CSI}?25l`;
var cursorShow = `${CSI}?25h`;
var cursorSave = `${ESC}7`;
var cursorRestore = `${ESC}8`;
function scrollUp(count4 = 1) {
  return `${CSI}S`.repeat(count4);
}
function scrollDown(count4 = 1) {
  return `${CSI}T`.repeat(count4);
}
var eraseScreen = `${CSI}2J`;
function eraseUp(count4 = 1) {
  return `${CSI}1J`.repeat(count4);
}
function eraseDown(count4 = 1) {
  return `${CSI}0J`.repeat(count4);
}
var eraseLine = `${CSI}2K`;
var eraseLineEnd = `${CSI}0K`;
var eraseLineStart = `${CSI}1K`;
function eraseLines(count4) {
  let clear = "";
  for (let i2 = 0; i2 < count4; i2++) {
    clear += eraseLine + (i2 < count4 - 1 ? cursorUp() : "");
  }
  clear += cursorLeft;
  return clear;
}
var clearScreen = "\x1Bc";
var clearTerminal = Deno.build.os === "windows" ? `${eraseScreen}${CSI}0f` : `${eraseScreen}${CSI}3J${CSI}H`;
function link(text, url) {
  return [
    OSC,
    "8",
    SEP5,
    SEP5,
    url,
    bel,
    text,
    OSC,
    "8",
    SEP5,
    SEP5,
    bel
  ].join("");
}
function image(buffer, options) {
  let ret = `${OSC}1337;File=inline=1`;
  if (options?.width) {
    ret += `;width=${options.width}`;
  }
  if (options?.height) {
    ret += `;height=${options.height}`;
  }
  if (options?.preserveAspectRatio === false) {
    ret += ";preserveAspectRatio=0";
  }
  return ret + ":" + encode(buffer) + bel;
}

// subrepos/cliffy/ansi/cursor_position.ts
var encoder = new TextEncoder();
var decoder2 = new TextDecoder();
function getCursorPosition({
  reader = Deno.stdin,
  writer = Deno.stdout
} = {}) {
  const data = new Uint8Array(8);
  reader.setRaw(true);
  writer.writeSync(encoder.encode(cursorPosition));
  reader.readSync(data);
  reader.setRaw(false);
  const [y, x] = decoder2.decode(data).match(/\[(\d+);(\d+)R/)?.slice(1, 3).map(Number) ?? [0, 0];
  return { x, y };
}

// subrepos/cliffy/ansi/tty.ts
var tty = factory();
var encoder2 = new TextEncoder();
function factory(options) {
  let result2 = "";
  let stack = [];
  const writer = options?.writer ?? Deno.stdout;
  const reader = options?.reader ?? Deno.stdin;
  const tty2 = function(...args) {
    if (this) {
      update(args);
      writer.writeSync(encoder2.encode(result2));
      return this;
    }
    return factory(args[0] ?? options);
  };
  tty2.text = function(text) {
    stack.push([text, []]);
    update();
    writer.writeSync(encoder2.encode(result2));
    return this;
  };
  tty2.getCursorPosition = () => getCursorPosition({ writer, reader });
  const methodList = Object.entries(
    ansi_escapes_exports
  );
  for (const [name, method] of methodList) {
    if (name === "cursorPosition") {
      continue;
    }
    Object.defineProperty(tty2, name, {
      get() {
        stack.push([method, []]);
        return this;
      }
    });
  }
  return tty2;
  function update(args) {
    if (!stack.length) {
      return;
    }
    if (args) {
      stack[stack.length - 1][1] = args;
    }
    result2 = stack.reduce(
      (prev, [cur, args2]) => prev + (typeof cur === "string" ? cur : cur.call(tty2, ...args2)),
      ""
    );
    stack = [];
  }
}

// subrepos/cliffy/keycode/_key_codes.ts
var KeyMap = {
  /* xterm/gnome ESC [ letter (with modifier) */
  "[P": "f1",
  "[Q": "f2",
  "[R": "f3",
  "[S": "f4",
  /* xterm/gnome ESC O letter (without modifier) */
  "OP": "f1",
  "OQ": "f2",
  "OR": "f3",
  "OS": "f4",
  /* xterm/rxvt ESC [ number ~ */
  "[11~": "f1",
  "[12~": "f2",
  "[13~": "f3",
  "[14~": "f4",
  /* from Cygwin and used in libuv */
  "[[A": "f1",
  "[[B": "f2",
  "[[C": "f3",
  "[[D": "f4",
  "[[E": "f5",
  /* common */
  "[15~": "f5",
  "[17~": "f6",
  "[18~": "f7",
  "[19~": "f8",
  "[20~": "f9",
  "[21~": "f10",
  "[23~": "f11",
  "[24~": "f12",
  /* xterm ESC [ letter */
  "[A": "up",
  "[B": "down",
  "[C": "right",
  "[D": "left",
  "[E": "clear",
  "[F": "end",
  "[H": "home",
  /* xterm/gnome ESC O letter */
  "OA": "up",
  "OB": "down",
  "OC": "right",
  "OD": "left",
  "OE": "clear",
  "OF": "end",
  "OH": "home",
  /* xterm/rxvt ESC [ number ~ */
  "[1~": "home",
  "[2~": "insert",
  "[3~": "delete",
  "[4~": "end",
  "[5~": "pageup",
  "[6~": "pagedown",
  /* putty */
  "[[5~": "pageup",
  "[[6~": "pagedown",
  /* rxvt */
  "[7~": "home",
  "[8~": "end"
};
var KeyMapShift = {
  /* rxvt keys with modifiers */
  "[a": "up",
  "[b": "down",
  "[c": "right",
  "[d": "left",
  "[e": "clear",
  "[2$": "insert",
  "[3$": "delete",
  "[5$": "pageup",
  "[6$": "pagedown",
  "[7$": "home",
  "[8$": "end",
  "[Z": "tab"
};
var KeyMapCtrl = {
  /* rxvt keys with modifiers */
  "Oa": "up",
  "Ob": "down",
  "Oc": "right",
  "Od": "left",
  "Oe": "clear",
  "[2^": "insert",
  "[3^": "delete",
  "[5^": "pageup",
  "[6^": "pagedown",
  "[7^": "home",
  "[8^": "end"
};
var SpecialKeyMap = {
  "\r": "return",
  "\n": "enter",
  "	": "tab",
  "\b": "backspace",
  "\x7F": "backspace",
  "\x1B": "escape",
  " ": "space"
};

// subrepos/cliffy/keycode/key_code.ts
var kUTF16SurrogateThreshold = 65536;
var kEscape = "\x1B";
function parse13(data) {
  let index = -1;
  const keys = [];
  const input = data instanceof Uint8Array ? new TextDecoder().decode(data) : data;
  const hasNext = () => input.length - 1 >= index + 1;
  const next = () => input[++index];
  parseNext();
  return keys;
  function parseNext() {
    let ch = next();
    let s = ch;
    let escaped = false;
    const key = {
      name: void 0,
      char: void 0,
      sequence: void 0,
      code: void 0,
      ctrl: false,
      meta: false,
      shift: false
    };
    if (ch === kEscape && hasNext()) {
      escaped = true;
      s += ch = next();
      if (ch === kEscape) {
        s += ch = next();
      }
    }
    if (escaped && (ch === "O" || ch === "[")) {
      let code2 = ch;
      let modifier = 0;
      if (ch === "O") {
        s += ch = next();
        if (ch >= "0" && ch <= "9") {
          modifier = (Number(ch) >> 0) - 1;
          s += ch = next();
        }
        code2 += ch;
      } else if (ch === "[") {
        s += ch = next();
        if (ch === "[") {
          code2 += ch;
          s += ch = next();
        }
        const cmdStart = s.length - 1;
        if (ch >= "0" && ch <= "9") {
          s += ch = next();
          if (ch >= "0" && ch <= "9") {
            s += ch = next();
          }
        }
        if (ch === ";") {
          s += ch = next();
          if (ch >= "0" && ch <= "9") {
            s += next();
          }
        }
        const cmd = s.slice(cmdStart);
        let match;
        if (match = cmd.match(/^(\d\d?)(;(\d))?([~^$])$/)) {
          code2 += match[1] + match[4];
          modifier = (Number(match[3]) || 1) - 1;
        } else if (match = cmd.match(/^((\d;)?(\d))?([A-Za-z])$/)) {
          code2 += match[4];
          modifier = (Number(match[3]) || 1) - 1;
        } else {
          code2 += cmd;
        }
      }
      key.ctrl = !!(modifier & 4);
      key.meta = !!(modifier & 10);
      key.shift = !!(modifier & 1);
      key.code = code2;
      if (code2 in KeyMap) {
        key.name = KeyMap[code2];
      } else if (code2 in KeyMapShift) {
        key.name = KeyMapShift[code2];
        key.shift = true;
      } else if (code2 in KeyMapCtrl) {
        key.name = KeyMapCtrl[code2];
        key.ctrl = true;
      } else {
        key.name = "undefined";
      }
    } else if (ch in SpecialKeyMap) {
      key.name = SpecialKeyMap[ch];
      key.meta = escaped;
      if (key.name === "space") {
        key.char = ch;
      }
    } else if (!escaped && ch <= "") {
      key.name = String.fromCharCode(
        ch.charCodeAt(0) + "a".charCodeAt(0) - 1
      );
      key.ctrl = true;
      key.char = key.name;
    } else if (/^[0-9A-Za-z]$/.test(ch)) {
      key.name = ch.toLowerCase();
      key.shift = /^[A-Z]$/.test(ch);
      key.meta = escaped;
      key.char = ch;
    } else if (escaped) {
      key.name = ch.length ? void 0 : "escape";
      key.meta = true;
    } else {
      key.name = ch;
      key.char = ch;
    }
    key.sequence = s;
    if (s.length !== 0 && (key.name !== void 0 || escaped) || charLengthAt(s, 0) === s.length) {
      keys.push(key);
    } else {
      throw new Error("Unrecognized or broken escape sequence");
    }
    if (hasNext()) {
      parseNext();
    }
  }
}
function charLengthAt(str2, i2) {
  const pos = str2.codePointAt(i2);
  if (typeof pos === "undefined") {
    return 1;
  }
  return pos >= kUTF16SurrogateThreshold ? 2 : 1;
}

// https://deno.land/std@0.196.0/_util/os.ts
var osType5 = (() => {
  const { Deno: Deno4 } = globalThis;
  if (typeof Deno4?.build?.os === "string") {
    return Deno4.build.os;
  }
  const { navigator } = globalThis;
  if (navigator?.appVersion?.includes?.("Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows6 = osType5 === "windows";

// https://deno.land/std@0.196.0/path/win32.ts
var win32_exports5 = {};
__export(win32_exports5, {
  basename: () => basename12,
  delimiter: () => delimiter12,
  dirname: () => dirname12,
  extname: () => extname12,
  format: () => format12,
  fromFileUrl: () => fromFileUrl12,
  isAbsolute: () => isAbsolute12,
  join: () => join16,
  normalize: () => normalize16,
  parse: () => parse14,
  relative: () => relative12,
  resolve: () => resolve12,
  sep: () => sep12,
  toFileUrl: () => toFileUrl12,
  toNamespacedPath: () => toNamespacedPath12
});

// https://deno.land/std@0.196.0/path/_constants.ts
var CHAR_UPPERCASE_A5 = 65;
var CHAR_LOWERCASE_A5 = 97;
var CHAR_UPPERCASE_Z5 = 90;
var CHAR_LOWERCASE_Z5 = 122;
var CHAR_DOT5 = 46;
var CHAR_FORWARD_SLASH5 = 47;
var CHAR_BACKWARD_SLASH5 = 92;
var CHAR_COLON5 = 58;
var CHAR_QUESTION_MARK5 = 63;

// https://deno.land/std@0.196.0/path/_util.ts
function assertPath5(path10) {
  if (typeof path10 !== "string") {
    throw new TypeError(
      `Path must be a string. Received ${JSON.stringify(path10)}`
    );
  }
}
function isPosixPathSeparator5(code2) {
  return code2 === CHAR_FORWARD_SLASH5;
}
function isPathSeparator5(code2) {
  return isPosixPathSeparator5(code2) || code2 === CHAR_BACKWARD_SLASH5;
}
function isWindowsDeviceRoot5(code2) {
  return code2 >= CHAR_LOWERCASE_A5 && code2 <= CHAR_LOWERCASE_Z5 || code2 >= CHAR_UPPERCASE_A5 && code2 <= CHAR_UPPERCASE_Z5;
}
function normalizeString5(path10, allowAboveRoot, separator, isPathSeparator6) {
  let res = "";
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let code2;
  for (let i2 = 0, len = path10.length; i2 <= len; ++i2) {
    if (i2 < len)
      code2 = path10.charCodeAt(i2);
    else if (isPathSeparator6(code2))
      break;
    else
      code2 = CHAR_FORWARD_SLASH5;
    if (isPathSeparator6(code2)) {
      if (lastSlash === i2 - 1 || dots === 1) {
      } else if (lastSlash !== i2 - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT5 || res.charCodeAt(res.length - 2) !== CHAR_DOT5) {
          if (res.length > 2) {
            const lastSlashIndex = res.lastIndexOf(separator);
            if (lastSlashIndex === -1) {
              res = "";
              lastSegmentLength = 0;
            } else {
              res = res.slice(0, lastSlashIndex);
              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
            }
            lastSlash = i2;
            dots = 0;
            continue;
          } else if (res.length === 2 || res.length === 1) {
            res = "";
            lastSegmentLength = 0;
            lastSlash = i2;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += `${separator}..`;
          else
            res = "..";
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += separator + path10.slice(lastSlash + 1, i2);
        else
          res = path10.slice(lastSlash + 1, i2);
        lastSegmentLength = i2 - lastSlash - 1;
      }
      lastSlash = i2;
      dots = 0;
    } else if (code2 === CHAR_DOT5 && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format5(sep15, pathObject) {
  const dir = pathObject.dir || pathObject.root;
  const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
  if (!dir)
    return base;
  if (base === sep15)
    return dir;
  if (dir === pathObject.root)
    return dir + base;
  return dir + sep15 + base;
}
var WHITESPACE_ENCODINGS5 = {
  "	": "%09",
  "\n": "%0A",
  "\v": "%0B",
  "\f": "%0C",
  "\r": "%0D",
  " ": "%20"
};
function encodeWhitespace5(string2) {
  return string2.replaceAll(/[\s]/g, (c) => {
    return WHITESPACE_ENCODINGS5[c] ?? c;
  });
}
function lastPathSegment2(path10, isSep, start = 0) {
  let matchedNonSeparator = false;
  let end = path10.length;
  for (let i2 = path10.length - 1; i2 >= start; --i2) {
    if (isSep(path10.charCodeAt(i2))) {
      if (matchedNonSeparator) {
        start = i2 + 1;
        break;
      }
    } else if (!matchedNonSeparator) {
      matchedNonSeparator = true;
      end = i2 + 1;
    }
  }
  return path10.slice(start, end);
}
function stripTrailingSeparators2(segment, isSep) {
  if (segment.length <= 1) {
    return segment;
  }
  let end = segment.length;
  for (let i2 = segment.length - 1; i2 > 0; i2--) {
    if (isSep(segment.charCodeAt(i2))) {
      end = i2;
    } else {
      break;
    }
  }
  return segment.slice(0, end);
}
function stripSuffix2(name, suffix) {
  if (suffix.length >= name.length) {
    return name;
  }
  const lenDiff = name.length - suffix.length;
  for (let i2 = suffix.length - 1; i2 >= 0; --i2) {
    if (name.charCodeAt(lenDiff + i2) !== suffix.charCodeAt(i2)) {
      return name;
    }
  }
  return name.slice(0, -suffix.length);
}

// https://deno.land/std@0.196.0/path/win32.ts
var sep12 = "\\";
var delimiter12 = ";";
function resolve12(...pathSegments) {
  let resolvedDevice = "";
  let resolvedTail = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1; i2--) {
    let path10;
    const { Deno: Deno4 } = globalThis;
    if (i2 >= 0) {
      path10 = pathSegments[i2];
    } else if (!resolvedDevice) {
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a drive-letter-less path without a CWD.");
      }
      path10 = Deno4.cwd();
    } else {
      if (typeof Deno4?.env?.get !== "function" || typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path10 = Deno4.cwd();
      if (path10 === void 0 || path10.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
        path10 = `${resolvedDevice}\\`;
      }
    }
    assertPath5(path10);
    const len = path10.length;
    if (len === 0)
      continue;
    let rootEnd = 0;
    let device = "";
    let isAbsolute15 = false;
    const code2 = path10.charCodeAt(0);
    if (len > 1) {
      if (isPathSeparator5(code2)) {
        isAbsolute15 = true;
        if (isPathSeparator5(path10.charCodeAt(1))) {
          let j = 2;
          let last = j;
          for (; j < len; ++j) {
            if (isPathSeparator5(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            const firstPart = path10.slice(last, j);
            last = j;
            for (; j < len; ++j) {
              if (!isPathSeparator5(path10.charCodeAt(j)))
                break;
            }
            if (j < len && j !== last) {
              last = j;
              for (; j < len; ++j) {
                if (isPathSeparator5(path10.charCodeAt(j)))
                  break;
              }
              if (j === len) {
                device = `\\\\${firstPart}\\${path10.slice(last)}`;
                rootEnd = j;
              } else if (j !== last) {
                device = `\\\\${firstPart}\\${path10.slice(last, j)}`;
                rootEnd = j;
              }
            }
          }
        } else {
          rootEnd = 1;
        }
      } else if (isWindowsDeviceRoot5(code2)) {
        if (path10.charCodeAt(1) === CHAR_COLON5) {
          device = path10.slice(0, 2);
          rootEnd = 2;
          if (len > 2) {
            if (isPathSeparator5(path10.charCodeAt(2))) {
              isAbsolute15 = true;
              rootEnd = 3;
            }
          }
        }
      }
    } else if (isPathSeparator5(code2)) {
      rootEnd = 1;
      isAbsolute15 = true;
    }
    if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
      continue;
    }
    if (resolvedDevice.length === 0 && device.length > 0) {
      resolvedDevice = device;
    }
    if (!resolvedAbsolute) {
      resolvedTail = `${path10.slice(rootEnd)}\\${resolvedTail}`;
      resolvedAbsolute = isAbsolute15;
    }
    if (resolvedAbsolute && resolvedDevice.length > 0)
      break;
  }
  resolvedTail = normalizeString5(
    resolvedTail,
    !resolvedAbsolute,
    "\\",
    isPathSeparator5
  );
  return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize16(path10) {
  assertPath5(path10);
  const len = path10.length;
  if (len === 0)
    return ".";
  let rootEnd = 0;
  let device;
  let isAbsolute15 = false;
  const code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator5(code2)) {
      isAbsolute15 = true;
      if (isPathSeparator5(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator5(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          const firstPart = path10.slice(last, j);
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator5(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator5(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return `\\\\${firstPart}\\${path10.slice(last)}\\`;
            } else if (j !== last) {
              device = `\\\\${firstPart}\\${path10.slice(last, j)}`;
              rootEnd = j;
            }
          }
        }
      } else {
        rootEnd = 1;
      }
    } else if (isWindowsDeviceRoot5(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON5) {
        device = path10.slice(0, 2);
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator5(path10.charCodeAt(2))) {
            isAbsolute15 = true;
            rootEnd = 3;
          }
        }
      }
    }
  } else if (isPathSeparator5(code2)) {
    return "\\";
  }
  let tail;
  if (rootEnd < len) {
    tail = normalizeString5(
      path10.slice(rootEnd),
      !isAbsolute15,
      "\\",
      isPathSeparator5
    );
  } else {
    tail = "";
  }
  if (tail.length === 0 && !isAbsolute15)
    tail = ".";
  if (tail.length > 0 && isPathSeparator5(path10.charCodeAt(len - 1))) {
    tail += "\\";
  }
  if (device === void 0) {
    if (isAbsolute15) {
      if (tail.length > 0)
        return `\\${tail}`;
      else
        return "\\";
    } else if (tail.length > 0) {
      return tail;
    } else {
      return "";
    }
  } else if (isAbsolute15) {
    if (tail.length > 0)
      return `${device}\\${tail}`;
    else
      return `${device}\\`;
  } else if (tail.length > 0) {
    return device + tail;
  } else {
    return device;
  }
}
function isAbsolute12(path10) {
  assertPath5(path10);
  const len = path10.length;
  if (len === 0)
    return false;
  const code2 = path10.charCodeAt(0);
  if (isPathSeparator5(code2)) {
    return true;
  } else if (isWindowsDeviceRoot5(code2)) {
    if (len > 2 && path10.charCodeAt(1) === CHAR_COLON5) {
      if (isPathSeparator5(path10.charCodeAt(2)))
        return true;
    }
  }
  return false;
}
function join16(...paths) {
  const pathsCount = paths.length;
  if (pathsCount === 0)
    return ".";
  let joined;
  let firstPart = null;
  for (let i2 = 0; i2 < pathsCount; ++i2) {
    const path10 = paths[i2];
    assertPath5(path10);
    if (path10.length > 0) {
      if (joined === void 0)
        joined = firstPart = path10;
      else
        joined += `\\${path10}`;
    }
  }
  if (joined === void 0)
    return ".";
  let needsReplace = true;
  let slashCount = 0;
  assert(firstPart != null);
  if (isPathSeparator5(firstPart.charCodeAt(0))) {
    ++slashCount;
    const firstLen = firstPart.length;
    if (firstLen > 1) {
      if (isPathSeparator5(firstPart.charCodeAt(1))) {
        ++slashCount;
        if (firstLen > 2) {
          if (isPathSeparator5(firstPart.charCodeAt(2)))
            ++slashCount;
          else {
            needsReplace = false;
          }
        }
      }
    }
  }
  if (needsReplace) {
    for (; slashCount < joined.length; ++slashCount) {
      if (!isPathSeparator5(joined.charCodeAt(slashCount)))
        break;
    }
    if (slashCount >= 2)
      joined = `\\${joined.slice(slashCount)}`;
  }
  return normalize16(joined);
}
function relative12(from, to) {
  assertPath5(from);
  assertPath5(to);
  if (from === to)
    return "";
  const fromOrig = resolve12(from);
  const toOrig = resolve12(to);
  if (fromOrig === toOrig)
    return "";
  from = fromOrig.toLowerCase();
  to = toOrig.toLowerCase();
  if (from === to)
    return "";
  let fromStart = 0;
  let fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (from.charCodeAt(fromStart) !== CHAR_BACKWARD_SLASH5)
      break;
  }
  for (; fromEnd - 1 > fromStart; --fromEnd) {
    if (from.charCodeAt(fromEnd - 1) !== CHAR_BACKWARD_SLASH5)
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 0;
  let toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (to.charCodeAt(toStart) !== CHAR_BACKWARD_SLASH5)
      break;
  }
  for (; toEnd - 1 > toStart; --toEnd) {
    if (to.charCodeAt(toEnd - 1) !== CHAR_BACKWARD_SLASH5)
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length; ++i2) {
    if (i2 === length) {
      if (toLen > length) {
        if (to.charCodeAt(toStart + i2) === CHAR_BACKWARD_SLASH5) {
          return toOrig.slice(toStart + i2 + 1);
        } else if (i2 === 2) {
          return toOrig.slice(toStart + i2);
        }
      }
      if (fromLen > length) {
        if (from.charCodeAt(fromStart + i2) === CHAR_BACKWARD_SLASH5) {
          lastCommonSep = i2;
        } else if (i2 === 2) {
          lastCommonSep = 3;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode)
      break;
    else if (fromCode === CHAR_BACKWARD_SLASH5)
      lastCommonSep = i2;
  }
  if (i2 !== length && lastCommonSep === -1) {
    return toOrig;
  }
  let out = "";
  if (lastCommonSep === -1)
    lastCommonSep = 0;
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || from.charCodeAt(i2) === CHAR_BACKWARD_SLASH5) {
      if (out.length === 0)
        out += "..";
      else
        out += "\\..";
    }
  }
  if (out.length > 0) {
    return out + toOrig.slice(toStart + lastCommonSep, toEnd);
  } else {
    toStart += lastCommonSep;
    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH5)
      ++toStart;
    return toOrig.slice(toStart, toEnd);
  }
}
function toNamespacedPath12(path10) {
  if (typeof path10 !== "string")
    return path10;
  if (path10.length === 0)
    return "";
  const resolvedPath = resolve12(path10);
  if (resolvedPath.length >= 3) {
    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH5) {
      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH5) {
        const code2 = resolvedPath.charCodeAt(2);
        if (code2 !== CHAR_QUESTION_MARK5 && code2 !== CHAR_DOT5) {
          return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
        }
      }
    } else if (isWindowsDeviceRoot5(resolvedPath.charCodeAt(0))) {
      if (resolvedPath.charCodeAt(1) === CHAR_COLON5 && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH5) {
        return `\\\\?\\${resolvedPath}`;
      }
    }
  }
  return path10;
}
function dirname12(path10) {
  assertPath5(path10);
  const len = path10.length;
  if (len === 0)
    return ".";
  let rootEnd = -1;
  let end = -1;
  let matchedSlash = true;
  let offset = 0;
  const code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator5(code2)) {
      rootEnd = offset = 1;
      if (isPathSeparator5(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator5(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator5(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator5(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              return path10;
            }
            if (j !== last) {
              rootEnd = offset = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot5(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON5) {
        rootEnd = offset = 2;
        if (len > 2) {
          if (isPathSeparator5(path10.charCodeAt(2)))
            rootEnd = offset = 3;
        }
      }
    }
  } else if (isPathSeparator5(code2)) {
    return path10;
  }
  for (let i2 = len - 1; i2 >= offset; --i2) {
    if (isPathSeparator5(path10.charCodeAt(i2))) {
      if (!matchedSlash) {
        end = i2;
        break;
      }
    } else {
      matchedSlash = false;
    }
  }
  if (end === -1) {
    if (rootEnd === -1)
      return ".";
    else
      end = rootEnd;
  }
  return stripTrailingSeparators2(path10.slice(0, end), isPosixPathSeparator5);
}
function basename12(path10, suffix = "") {
  assertPath5(path10);
  if (path10.length === 0)
    return path10;
  if (typeof suffix !== "string") {
    throw new TypeError(
      `Suffix must be a string. Received ${JSON.stringify(suffix)}`
    );
  }
  let start = 0;
  if (path10.length >= 2) {
    const drive = path10.charCodeAt(0);
    if (isWindowsDeviceRoot5(drive)) {
      if (path10.charCodeAt(1) === CHAR_COLON5)
        start = 2;
    }
  }
  const lastSegment = lastPathSegment2(path10, isPathSeparator5, start);
  const strippedSegment = stripTrailingSeparators2(lastSegment, isPathSeparator5);
  return suffix ? stripSuffix2(strippedSegment, suffix) : strippedSegment;
}
function extname12(path10) {
  assertPath5(path10);
  let start = 0;
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  if (path10.length >= 2 && path10.charCodeAt(1) === CHAR_COLON5 && isWindowsDeviceRoot5(path10.charCodeAt(0))) {
    start = startPart = 2;
  }
  for (let i2 = path10.length - 1; i2 >= start; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (isPathSeparator5(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT5) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path10.slice(startDot, end);
}
function format12(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(
      `The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`
    );
  }
  return _format5("\\", pathObject);
}
function parse14(path10) {
  assertPath5(path10);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  const len = path10.length;
  if (len === 0)
    return ret;
  let rootEnd = 0;
  let code2 = path10.charCodeAt(0);
  if (len > 1) {
    if (isPathSeparator5(code2)) {
      rootEnd = 1;
      if (isPathSeparator5(path10.charCodeAt(1))) {
        let j = 2;
        let last = j;
        for (; j < len; ++j) {
          if (isPathSeparator5(path10.charCodeAt(j)))
            break;
        }
        if (j < len && j !== last) {
          last = j;
          for (; j < len; ++j) {
            if (!isPathSeparator5(path10.charCodeAt(j)))
              break;
          }
          if (j < len && j !== last) {
            last = j;
            for (; j < len; ++j) {
              if (isPathSeparator5(path10.charCodeAt(j)))
                break;
            }
            if (j === len) {
              rootEnd = j;
            } else if (j !== last) {
              rootEnd = j + 1;
            }
          }
        }
      }
    } else if (isWindowsDeviceRoot5(code2)) {
      if (path10.charCodeAt(1) === CHAR_COLON5) {
        rootEnd = 2;
        if (len > 2) {
          if (isPathSeparator5(path10.charCodeAt(2))) {
            if (len === 3) {
              ret.root = ret.dir = path10;
              ret.base = "\\";
              return ret;
            }
            rootEnd = 3;
          }
        } else {
          ret.root = ret.dir = path10;
          return ret;
        }
      }
    }
  } else if (isPathSeparator5(code2)) {
    ret.root = ret.dir = path10;
    ret.base = "\\";
    return ret;
  }
  if (rootEnd > 0)
    ret.root = path10.slice(0, rootEnd);
  let startDot = -1;
  let startPart = rootEnd;
  let end = -1;
  let matchedSlash = true;
  let i2 = path10.length - 1;
  let preDotState = 0;
  for (; i2 >= rootEnd; --i2) {
    code2 = path10.charCodeAt(i2);
    if (isPathSeparator5(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT5) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      ret.base = ret.name = path10.slice(startPart, end);
    }
  } else {
    ret.name = path10.slice(startPart, startDot);
    ret.base = path10.slice(startPart, end);
    ret.ext = path10.slice(startDot, end);
  }
  ret.base = ret.base || "\\";
  if (startPart > 0 && startPart !== rootEnd) {
    ret.dir = path10.slice(0, startPart - 1);
  } else
    ret.dir = ret.root;
  return ret;
}
function fromFileUrl12(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  let path10 = decodeURIComponent(
    url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  ).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
  if (url.hostname != "") {
    path10 = `\\\\${url.hostname}${path10}`;
  }
  return path10;
}
function toFileUrl12(path10) {
  if (!isAbsolute12(path10)) {
    throw new TypeError("Must be an absolute path.");
  }
  const [, hostname, pathname] = path10.match(
    /^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/
  );
  const url = new URL("file:///");
  url.pathname = encodeWhitespace5(pathname.replace(/%/g, "%25"));
  if (hostname != null && hostname != "localhost") {
    url.hostname = hostname;
    if (!url.hostname) {
      throw new TypeError("Invalid hostname.");
    }
  }
  return url;
}

// https://deno.land/std@0.196.0/path/posix.ts
var posix_exports5 = {};
__export(posix_exports5, {
  basename: () => basename13,
  delimiter: () => delimiter13,
  dirname: () => dirname13,
  extname: () => extname13,
  format: () => format13,
  fromFileUrl: () => fromFileUrl13,
  isAbsolute: () => isAbsolute13,
  join: () => join17,
  normalize: () => normalize17,
  parse: () => parse15,
  relative: () => relative13,
  resolve: () => resolve13,
  sep: () => sep13,
  toFileUrl: () => toFileUrl13,
  toNamespacedPath: () => toNamespacedPath13
});
var sep13 = "/";
var delimiter13 = ":";
function resolve13(...pathSegments) {
  let resolvedPath = "";
  let resolvedAbsolute = false;
  for (let i2 = pathSegments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
    let path10;
    if (i2 >= 0)
      path10 = pathSegments[i2];
    else {
      const { Deno: Deno4 } = globalThis;
      if (typeof Deno4?.cwd !== "function") {
        throw new TypeError("Resolved a relative path without a CWD.");
      }
      path10 = Deno4.cwd();
    }
    assertPath5(path10);
    if (path10.length === 0) {
      continue;
    }
    resolvedPath = `${path10}/${resolvedPath}`;
    resolvedAbsolute = isPosixPathSeparator5(path10.charCodeAt(0));
  }
  resolvedPath = normalizeString5(
    resolvedPath,
    !resolvedAbsolute,
    "/",
    isPosixPathSeparator5
  );
  if (resolvedAbsolute) {
    if (resolvedPath.length > 0)
      return `/${resolvedPath}`;
    else
      return "/";
  } else if (resolvedPath.length > 0)
    return resolvedPath;
  else
    return ".";
}
function normalize17(path10) {
  assertPath5(path10);
  if (path10.length === 0)
    return ".";
  const isAbsolute15 = isPosixPathSeparator5(path10.charCodeAt(0));
  const trailingSeparator = isPosixPathSeparator5(
    path10.charCodeAt(path10.length - 1)
  );
  path10 = normalizeString5(path10, !isAbsolute15, "/", isPosixPathSeparator5);
  if (path10.length === 0 && !isAbsolute15)
    path10 = ".";
  if (path10.length > 0 && trailingSeparator)
    path10 += "/";
  if (isAbsolute15)
    return `/${path10}`;
  return path10;
}
function isAbsolute13(path10) {
  assertPath5(path10);
  return path10.length > 0 && isPosixPathSeparator5(path10.charCodeAt(0));
}
function join17(...paths) {
  if (paths.length === 0)
    return ".";
  let joined;
  for (let i2 = 0, len = paths.length; i2 < len; ++i2) {
    const path10 = paths[i2];
    assertPath5(path10);
    if (path10.length > 0) {
      if (!joined)
        joined = path10;
      else
        joined += `/${path10}`;
    }
  }
  if (!joined)
    return ".";
  return normalize17(joined);
}
function relative13(from, to) {
  assertPath5(from);
  assertPath5(to);
  if (from === to)
    return "";
  from = resolve13(from);
  to = resolve13(to);
  if (from === to)
    return "";
  let fromStart = 1;
  const fromEnd = from.length;
  for (; fromStart < fromEnd; ++fromStart) {
    if (!isPosixPathSeparator5(from.charCodeAt(fromStart)))
      break;
  }
  const fromLen = fromEnd - fromStart;
  let toStart = 1;
  const toEnd = to.length;
  for (; toStart < toEnd; ++toStart) {
    if (!isPosixPathSeparator5(to.charCodeAt(toStart)))
      break;
  }
  const toLen = toEnd - toStart;
  const length = fromLen < toLen ? fromLen : toLen;
  let lastCommonSep = -1;
  let i2 = 0;
  for (; i2 <= length; ++i2) {
    if (i2 === length) {
      if (toLen > length) {
        if (isPosixPathSeparator5(to.charCodeAt(toStart + i2))) {
          return to.slice(toStart + i2 + 1);
        } else if (i2 === 0) {
          return to.slice(toStart + i2);
        }
      } else if (fromLen > length) {
        if (isPosixPathSeparator5(from.charCodeAt(fromStart + i2))) {
          lastCommonSep = i2;
        } else if (i2 === 0) {
          lastCommonSep = 0;
        }
      }
      break;
    }
    const fromCode = from.charCodeAt(fromStart + i2);
    const toCode = to.charCodeAt(toStart + i2);
    if (fromCode !== toCode)
      break;
    else if (isPosixPathSeparator5(fromCode))
      lastCommonSep = i2;
  }
  let out = "";
  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
    if (i2 === fromEnd || isPosixPathSeparator5(from.charCodeAt(i2))) {
      if (out.length === 0)
        out += "..";
      else
        out += "/..";
    }
  }
  if (out.length > 0)
    return out + to.slice(toStart + lastCommonSep);
  else {
    toStart += lastCommonSep;
    if (isPosixPathSeparator5(to.charCodeAt(toStart)))
      ++toStart;
    return to.slice(toStart);
  }
}
function toNamespacedPath13(path10) {
  return path10;
}
function dirname13(path10) {
  if (path10.length === 0)
    return ".";
  let end = -1;
  let matchedNonSeparator = false;
  for (let i2 = path10.length - 1; i2 >= 1; --i2) {
    if (isPosixPathSeparator5(path10.charCodeAt(i2))) {
      if (matchedNonSeparator) {
        end = i2;
        break;
      }
    } else {
      matchedNonSeparator = true;
    }
  }
  if (end === -1) {
    return isPosixPathSeparator5(path10.charCodeAt(0)) ? "/" : ".";
  }
  return stripTrailingSeparators2(
    path10.slice(0, end),
    isPosixPathSeparator5
  );
}
function basename13(path10, suffix = "") {
  assertPath5(path10);
  if (path10.length === 0)
    return path10;
  if (typeof suffix !== "string") {
    throw new TypeError(
      `Suffix must be a string. Received ${JSON.stringify(suffix)}`
    );
  }
  const lastSegment = lastPathSegment2(path10, isPosixPathSeparator5);
  const strippedSegment = stripTrailingSeparators2(
    lastSegment,
    isPosixPathSeparator5
  );
  return suffix ? stripSuffix2(strippedSegment, suffix) : strippedSegment;
}
function extname13(path10) {
  assertPath5(path10);
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let preDotState = 0;
  for (let i2 = path10.length - 1; i2 >= 0; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (isPosixPathSeparator5(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT5) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return "";
  }
  return path10.slice(startDot, end);
}
function format13(pathObject) {
  if (pathObject === null || typeof pathObject !== "object") {
    throw new TypeError(
      `The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`
    );
  }
  return _format5("/", pathObject);
}
function parse15(path10) {
  assertPath5(path10);
  const ret = { root: "", dir: "", base: "", ext: "", name: "" };
  if (path10.length === 0)
    return ret;
  const isAbsolute15 = isPosixPathSeparator5(path10.charCodeAt(0));
  let start;
  if (isAbsolute15) {
    ret.root = "/";
    start = 1;
  } else {
    start = 0;
  }
  let startDot = -1;
  let startPart = 0;
  let end = -1;
  let matchedSlash = true;
  let i2 = path10.length - 1;
  let preDotState = 0;
  for (; i2 >= start; --i2) {
    const code2 = path10.charCodeAt(i2);
    if (isPosixPathSeparator5(code2)) {
      if (!matchedSlash) {
        startPart = i2 + 1;
        break;
      }
      continue;
    }
    if (end === -1) {
      matchedSlash = false;
      end = i2 + 1;
    }
    if (code2 === CHAR_DOT5) {
      if (startDot === -1)
        startDot = i2;
      else if (preDotState !== 1)
        preDotState = 1;
    } else if (startDot !== -1) {
      preDotState = -1;
    }
  }
  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    if (end !== -1) {
      if (startPart === 0 && isAbsolute15) {
        ret.base = ret.name = path10.slice(1, end);
      } else {
        ret.base = ret.name = path10.slice(startPart, end);
      }
    }
    ret.base = ret.base || "/";
  } else {
    if (startPart === 0 && isAbsolute15) {
      ret.name = path10.slice(1, startDot);
      ret.base = path10.slice(1, end);
    } else {
      ret.name = path10.slice(startPart, startDot);
      ret.base = path10.slice(startPart, end);
    }
    ret.ext = path10.slice(startDot, end);
  }
  if (startPart > 0) {
    ret.dir = stripTrailingSeparators2(
      path10.slice(0, startPart - 1),
      isPosixPathSeparator5
    );
  } else if (isAbsolute15)
    ret.dir = "/";
  return ret;
}
function fromFileUrl13(url) {
  url = url instanceof URL ? url : new URL(url);
  if (url.protocol != "file:") {
    throw new TypeError("Must be a file URL.");
  }
  return decodeURIComponent(
    url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25")
  );
}
function toFileUrl13(path10) {
  if (!isAbsolute13(path10)) {
    throw new TypeError("Must be an absolute path.");
  }
  const url = new URL("file:///");
  url.pathname = encodeWhitespace5(
    path10.replace(/%/g, "%25").replace(/\\/g, "%5C")
  );
  return url;
}

// https://deno.land/std@0.196.0/path/glob.ts
var path8 = isWindows6 ? win32_exports5 : posix_exports5;
var { join: join18, normalize: normalize18 } = path8;

// https://deno.land/std@0.196.0/path/mod.ts
var path9 = isWindows6 ? win32_exports5 : posix_exports5;
var {
  basename: basename14,
  delimiter: delimiter14,
  dirname: dirname14,
  extname: extname14,
  format: format14,
  fromFileUrl: fromFileUrl14,
  isAbsolute: isAbsolute14,
  join: join19,
  normalize: normalize19,
  parse: parse16,
  relative: relative14,
  resolve: resolve14,
  toFileUrl: toFileUrl14,
  toNamespacedPath: toNamespacedPath14
} = path9;

// subrepos/cliffy/prompt/_figures.ts
var main = {
  ARROW_UP: "\u2191",
  ARROW_DOWN: "\u2193",
  ARROW_LEFT: "\u2190",
  ARROW_RIGHT: "\u2192",
  ARROW_UP_LEFT: "\u2196",
  ARROW_UP_RIGHT: "\u2197",
  ARROW_DOWN_RIGHT: "\u2198",
  ARROW_DOWN_LEFT: "\u2199",
  RADIO_ON: "\u25C9",
  RADIO_OFF: "\u25EF",
  TICK: "\u2714",
  CROSS: "\u2718",
  ELLIPSIS: "\u2026",
  POINTER_SMALL: "\u203A",
  POINTER_SMALL_LEFT: "\u2039",
  LINE: "\u2500",
  POINTER: "\u276F",
  POINTER_LEFT: "\u276E",
  INFO: "\u2139",
  TAB_LEFT: "\u21E4",
  TAB_RIGHT: "\u21E5",
  ESCAPE: "\u238B",
  BACKSPACE: "\u232B",
  PAGE_UP: "\u21DE",
  PAGE_DOWN: "\u21DF",
  ENTER: "\u21B5",
  SEARCH: "\u{1F50E}",
  FOLDER: "\u{1F4C1}",
  FOLDER_OPEN: "\u{1F4C2}"
};
var win = {
  ...main,
  RADIO_ON: "(*)",
  RADIO_OFF: "( )",
  TICK: "\u221A",
  CROSS: "\xD7",
  POINTER_SMALL: "\xBB"
};
var Figures = Deno.build.os === "windows" ? win : main;
var keyMap = {
  up: "ARROW_UP",
  down: "ARROW_DOWN",
  left: "ARROW_LEFT",
  right: "ARROW_RIGHT",
  pageup: "PAGE_UP",
  pagedown: "PAGE_DOWN",
  tab: "TAB_RIGHT",
  enter: "ENTER",
  return: "ENTER"
};
function getFiguresByKeys(keys) {
  const figures = [];
  for (const key of keys) {
    const figure = Figures[keyMap[key]] ?? key;
    if (!figures.includes(figure)) {
      figures.push(figure);
    }
  }
  return figures;
}

// subrepos/cliffy/prompt/_generic_prompt.ts
var GenericPrompt = class _GenericPrompt {
  static injectedValue;
  cursor = {
    x: 0,
    y: 0
  };
  #value;
  #lastError;
  #isFirstRun = true;
  #encoder = new TextEncoder();
  /**
   * Inject prompt value. If called, the prompt doesn't prompt for an input and
   * returns immediately the injected value. Can be used for unit tests or pre
   * selections.
   *
   * @param value Input value.
   */
  static inject(value) {
    _GenericPrompt.injectedValue = value;
  }
  getDefaultSettings(options) {
    return {
      ...options,
      tty: tty({
        // Stdin is only used by getCursorPosition which we don't need.
        reader: Deno.stdin,
        writer: options.writer ?? Deno.stdout
      }),
      cbreak: options.cbreak ?? false,
      reader: options.reader ?? Deno.stdin,
      writer: options.writer ?? Deno.stdout,
      pointer: options.pointer ?? brightBlue(Figures.POINTER_SMALL),
      prefix: options.prefix ?? yellow("? "),
      indent: options.indent ?? "",
      keys: {
        submit: ["enter", "return"],
        ...options.keys ?? {}
      }
    };
  }
  /** Execute the prompt. */
  async prompt() {
    try {
      return await this.#execute();
    } finally {
      this.settings.tty.cursorShow();
    }
  }
  /** Clear prompt output. */
  clear() {
    this.settings.tty.cursorLeft.eraseDown();
  }
  /** Execute the prompt. */
  #execute = async () => {
    if (typeof _GenericPrompt.injectedValue !== "undefined" && this.#lastError) {
      throw new Error(this.error());
    }
    await this.render();
    this.#lastError = void 0;
    if (!await this.read()) {
      return this.#execute();
    }
    if (typeof this.#value === "undefined") {
      throw new Error("internal error: failed to read value");
    }
    this.clear();
    const successMessage = this.success(this.#value);
    if (successMessage) {
      this.settings.writer.writeSync(
        this.#encoder.encode(successMessage + "\n")
      );
    }
    _GenericPrompt.injectedValue = void 0;
    this.settings.tty.cursorShow();
    return this.#value;
  };
  /** Render prompt. */
  async render() {
    const result2 = await Promise.all([
      this.message(),
      this.body?.(),
      this.footer()
    ]);
    const content = result2.filter(Boolean).join("\n");
    const lines = content.split("\n");
    const columns = getColumns();
    const linesCount = columns ? lines.reduce((prev, next) => {
      const length = stripColor(next).length;
      return prev + (length > columns ? Math.ceil(length / columns) : 1);
    }, 0) : content.split("\n").length;
    const y = linesCount - this.cursor.y - 1;
    if (!this.#isFirstRun || this.#lastError) {
      this.clear();
    }
    this.#isFirstRun = false;
    this.settings.writer.writeSync(this.#encoder.encode(content));
    if (y) {
      this.settings.tty.cursorUp(y);
    }
    this.settings.tty.cursorTo(this.cursor.x);
  }
  /** Read user input from stdin, handle events and validate user input. */
  async read() {
    if (typeof _GenericPrompt.injectedValue !== "undefined") {
      const value = _GenericPrompt.injectedValue;
      await this.#validateValue(value);
    } else {
      const events = await this.#readKey();
      if (!events.length) {
        return false;
      }
      for (const event of events) {
        await this.handleEvent(event);
      }
    }
    return typeof this.#value !== "undefined";
  }
  submit() {
    return this.#validateValue(this.getValue());
  }
  message() {
    return `${this.settings.indent}${this.settings.prefix}` + bold(this.settings.message) + this.defaults();
  }
  defaults() {
    let defaultMessage = "";
    if (typeof this.settings.default !== "undefined" && !this.settings.hideDefault) {
      defaultMessage += dim(` (${this.format(this.settings.default)})`);
    }
    return defaultMessage;
  }
  /** Get prompt success message. */
  success(value) {
    return `${this.settings.indent}${this.settings.prefix}` + bold(this.settings.message) + this.defaults() + " " + this.settings.pointer + " " + green(this.format(value));
  }
  footer() {
    return this.error() ?? this.hint();
  }
  error() {
    return this.#lastError ? this.settings.indent + red(bold(`${Figures.CROSS} `) + this.#lastError) : void 0;
  }
  hint() {
    return this.settings.hint ? this.settings.indent + italic(brightBlue(dim(`${Figures.POINTER} `) + this.settings.hint)) : void 0;
  }
  setErrorMessage(message) {
    this.#lastError = message;
  }
  /**
   * Handle user input event.
   * @param event Key event.
   */
  async handleEvent(event) {
    switch (true) {
      case (event.name === "c" && event.ctrl):
        this.clear();
        this.settings.tty.cursorShow();
        Deno.exit(130);
        return;
      case this.isKey(this.settings.keys, "submit", event):
        await this.submit();
        break;
    }
  }
  /** Read user input from stdin and pars ansi codes. */
  #readKey = async () => {
    const data = await this.#readChar();
    return data.length ? parse13(data) : [];
  };
  /** Read user input from stdin. */
  #readChar = async () => {
    const buffer = new Uint8Array(8);
    const isTty = Deno.isatty(this.settings.reader.rid);
    if (isTty) {
      this.settings.reader.setRaw(
        true,
        { cbreak: this.settings.cbreak }
      );
    }
    const nread = await this.settings.reader.read(buffer);
    if (isTty) {
      this.settings.reader.setRaw(false);
    }
    if (nread === null) {
      return buffer;
    }
    return buffer.subarray(0, nread);
  };
  /**
   * Map input value to output value. If a custom transform handler ist set, the
   * custom handler will be executed, otherwise the default transform handler
   * from the prompt will be executed.
   * @param value The value to transform.
   */
  #transformValue = (value) => {
    return this.settings.transform ? this.settings.transform(value) : this.transform(value);
  };
  /**
   * Validate input value. Set error message if validation fails and transform
   * output value on success.
   * If a default value is set, the default will be used as value without any
   * validation.
   * If a custom validation handler ist set, the custom handler will
   * be executed, otherwise a prompt specific default validation handler will be
   * executed.
   * @param value The value to validate.
   */
  #validateValue = async (value) => {
    if (!value && typeof this.settings.default !== "undefined") {
      this.#value = this.settings.default;
      return;
    }
    this.#value = void 0;
    this.#lastError = void 0;
    const validation = await (this.settings.validate ? this.settings.validate(value) : this.validate(value));
    if (validation === false) {
      this.#lastError = `Invalid answer.`;
    } else if (typeof validation === "string") {
      this.#lastError = validation;
    } else {
      this.#value = this.#transformValue(value);
    }
  };
  /**
   * Check if key event has given name or sequence.
   * @param keys  Key map.
   * @param name  Key name.
   * @param event Key event.
   */
  isKey(keys, name, event) {
    const keyNames = keys?.[name];
    return typeof keyNames !== "undefined" && (typeof event.name !== "undefined" && keyNames.indexOf(event.name) !== -1 || typeof event.sequence !== "undefined" && keyNames.indexOf(event.sequence) !== -1);
  }
};
function getColumns() {
  try {
    return Deno.consoleSize().columns ?? null;
  } catch (_error) {
    return null;
  }
}

// subrepos/cliffy/prompt/_generic_input.ts
var GenericInput = class extends GenericPrompt {
  inputValue = "";
  inputIndex = 0;
  getDefaultSettings(options) {
    const settings = super.getDefaultSettings(options);
    return {
      ...settings,
      keys: {
        moveCursorLeft: ["left"],
        moveCursorRight: ["right"],
        deleteCharLeft: ["backspace"],
        deleteCharRight: ["delete"],
        ...settings.keys ?? {}
      }
    };
  }
  getCurrentInputValue() {
    return this.inputValue;
  }
  message() {
    const message = super.message() + " " + this.settings.pointer + " ";
    this.cursor.x = stripColor(message).length + this.inputIndex + 1;
    return message + this.input();
  }
  input() {
    return underline(this.inputValue);
  }
  highlight(value, color1 = dim, color2 = brightBlue) {
    value = value.toString();
    const inputLowerCase = this.getCurrentInputValue().toLowerCase();
    const valueLowerCase = value.toLowerCase();
    const index = valueLowerCase.indexOf(inputLowerCase);
    const matched = value.slice(index, index + inputLowerCase.length);
    return index >= 0 ? color1(value.slice(0, index)) + color2(matched) + color1(value.slice(index + inputLowerCase.length)) : value;
  }
  /**
   * Handle user input event.
   * @param event Key event.
   */
  async handleEvent(event) {
    switch (true) {
      case this.isKey(this.settings.keys, "moveCursorLeft", event):
        this.moveCursorLeft();
        break;
      case this.isKey(this.settings.keys, "moveCursorRight", event):
        this.moveCursorRight();
        break;
      case this.isKey(this.settings.keys, "deleteCharRight", event):
        this.deleteCharRight();
        break;
      case this.isKey(this.settings.keys, "deleteCharLeft", event):
        this.deleteChar();
        break;
      case (event.char && !event.meta && !event.ctrl):
        this.addChar(event.char);
        break;
      default:
        await super.handleEvent(event);
    }
  }
  /** Add character to current input. */
  addChar(char) {
    this.inputValue = this.inputValue.slice(0, this.inputIndex) + char + this.inputValue.slice(this.inputIndex);
    this.inputIndex++;
  }
  /** Move prompt cursor left. */
  moveCursorLeft() {
    if (this.inputIndex > 0) {
      this.inputIndex--;
    }
  }
  /** Move prompt cursor right. */
  moveCursorRight() {
    if (this.inputIndex < this.inputValue.length) {
      this.inputIndex++;
    }
  }
  /** Delete char left. */
  deleteChar() {
    if (this.inputIndex > 0) {
      this.inputIndex--;
      this.deleteCharRight();
    }
  }
  /** Delete char right. */
  deleteCharRight() {
    if (this.inputIndex < this.inputValue.length) {
      this.inputValue = this.inputValue.slice(0, this.inputIndex) + this.inputValue.slice(this.inputIndex + 1);
    }
  }
};

// subrepos/cliffy/_utils/distance.ts
function distance2(a, b) {
  let aFlakeIndex = a.indexOf("\u2744\uFE0F");
  if (aFlakeIndex != -1) {
    a = a.slice(0, aFlakeIndex - 1);
  }
  let bFlakeIndex = b.indexOf("\u2744\uFE0F");
  if (bFlakeIndex != -1) {
    b = b.slice(0, bFlakeIndex - 1);
  }
  if (a.length == 0) {
    return b.length;
  }
  if (b.length == 0) {
    return a.length;
  }
  const matrix = [];
  for (let i2 = 0; i2 <= b.length; i2++) {
    matrix[i2] = [i2];
  }
  for (let j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }
  for (let i2 = 1; i2 <= b.length; i2++) {
    for (let j = 1; j <= a.length; j++) {
      if (b.charAt(i2 - 1) == a.charAt(j - 1)) {
        matrix[i2][j] = matrix[i2 - 1][j - 1];
      } else {
        matrix[i2][j] = Math.min(
          matrix[i2 - 1][j - 1] + 1,
          Math.min(matrix[i2][j - 1] + 1, matrix[i2 - 1][j] + 1)
        );
      }
    }
  }
  return matrix[b.length][a.length];
}

// subrepos/cliffy/prompt/_generic_suggestions.ts
var sep14 = Deno.build.os === "windows" ? "\\" : "/";
var GenericSuggestions = class extends GenericInput {
  suggestionsIndex = -1;
  suggestionsOffset = 0;
  suggestions = [];
  suggestionDescriptions = [];
  #hasReadPermissions;
  getDefaultSettings(options) {
    const settings = super.getDefaultSettings(options);
    return {
      completeOnSubmit: false,
      ...settings,
      listPointer: options.listPointer ?? brightBlue(Figures.POINTER),
      maxRows: options.maxRows ?? 8,
      keys: {
        submit: ["enter", "return"],
        complete: ["tab"],
        next: ["up"],
        previous: ["down"],
        nextPage: ["pageup"],
        previousPage: ["pagedown"],
        ...settings.keys ?? {}
      }
    };
  }
  get localStorage() {
    if (this.settings.id && "localStorage" in window) {
      try {
        return window.localStorage;
      } catch (_) {
      }
    }
    return null;
  }
  loadSuggestions() {
    if (this.settings.id) {
      const json2 = this.localStorage?.getItem(this.settings.id);
      const suggestions = json2 ? JSON.parse(json2) : [];
      if (!Array.isArray(suggestions)) {
        return [];
      }
      return suggestions;
    }
    return [];
  }
  saveSuggestions(...suggestions) {
    if (this.settings.id) {
      this.localStorage?.setItem(
        this.settings.id,
        JSON.stringify([
          ...suggestions,
          ...this.loadSuggestions()
        ].filter(uniqueSuggestions))
      );
    }
  }
  async render() {
    if (this.settings.files && this.#hasReadPermissions === void 0) {
      const status = await Deno.permissions.request({ name: "read" });
      this.#hasReadPermissions = status.state === "granted";
    }
    await this.match();
    return super.render();
  }
  async match() {
    this.suggestions = await this.getSuggestions();
    this.suggestionsIndex = Math.max(
      this.getCurrentInputValue().trim().length === 0 ? -1 : 0,
      Math.min(this.suggestions.length - 1, this.suggestionsIndex)
    );
    this.suggestionsOffset = Math.max(
      0,
      Math.min(
        this.suggestions.length - this.getListHeight(),
        this.suggestionsOffset
      )
    );
  }
  input() {
    return super.input() + dim(this.getSuggestion());
  }
  getSuggestion() {
    return this.suggestions[this.suggestionsIndex]?.toString().substr(
      this.getCurrentInputValue().length
    ) ?? "";
  }
  async getUserSuggestions(input) {
    return typeof this.settings.suggestions === "function" ? await this.settings.suggestions(input) : this.settings.suggestions ?? [];
  }
  #isFileModeEnabled() {
    return !!this.settings.files && this.#hasReadPermissions === true;
  }
  async getFileSuggestions(input) {
    if (!this.#isFileModeEnabled()) {
      return [];
    }
    const path10 = await Deno.stat(input).then((file) => file.isDirectory ? input : dirname14(input)).catch(() => dirname14(input));
    return await listDir(path10, this.settings.files);
  }
  async getSuggestions() {
    const input = this.getCurrentInputValue();
    const suggestions = [
      ...this.loadSuggestions(),
      ...await this.getUserSuggestions(input),
      ...await this.getFileSuggestions(input)
    ].filter(uniqueSuggestions);
    if (!input.length) {
      return suggestions;
    }
    return suggestions.filter(
      (value) => stripColor(value.toString()).toLowerCase().startsWith(input.toLowerCase())
    ).sort(
      (a, b) => distance2((a || a).toString(), input) - distance2((b || b).toString(), input)
    );
  }
  body() {
    return this.getList() + this.getInfo();
  }
  getInfo() {
    if (!this.settings.info) {
      return "";
    }
    const selected = this.suggestionsIndex + 1;
    const matched = this.suggestions.length;
    const actions = [];
    if (this.suggestions.length) {
      if (this.settings.list) {
        actions.push(
          ["Next", getFiguresByKeys(this.settings.keys?.next ?? [])],
          ["Previous", getFiguresByKeys(this.settings.keys?.previous ?? [])],
          ["Next Page", getFiguresByKeys(this.settings.keys?.nextPage ?? [])],
          [
            "Previous Page",
            getFiguresByKeys(this.settings.keys?.previousPage ?? [])
          ]
        );
      } else {
        actions.push(
          ["Next", getFiguresByKeys(this.settings.keys?.next ?? [])],
          ["Previous", getFiguresByKeys(this.settings.keys?.previous ?? [])]
        );
      }
      actions.push(
        ["Complete", getFiguresByKeys(this.settings.keys?.complete ?? [])]
      );
    }
    actions.push(
      ["Submit", getFiguresByKeys(this.settings.keys?.submit ?? [])]
    );
    let info = this.settings.indent;
    if (this.suggestions.length) {
      info += brightBlue(Figures.INFO) + bold(` ${selected}/${matched} `);
    }
    info += actions.map((cur) => `${cur[0]}: ${bold(cur[1].join(" "))}`).join(", ");
    return info;
  }
  getList() {
    if (!this.suggestions.length || !this.settings.list) {
      return "";
    }
    const suggestionToDescription = Object.fromEntries(zip2(this.settings.suggestions || [], this.settings.suggestionDescriptions || []));
    const list = [];
    const height = this.getListHeight();
    for (let i2 = this.suggestionsOffset; i2 < this.suggestionsOffset + height; i2++) {
      list.push(
        this.getListItem(
          `${this.suggestions[i2]}`.replace(/(.+)/, reset(cyan("\u2744\uFE0F")) + dim(green("$1"))),
          this.suggestionsIndex === i2,
          suggestionToDescription[this.suggestions[i2]]
        )
      );
    }
    if (list.length && this.settings.info) {
      list.push("");
    }
    return list.join("\n");
  }
  /**
   * Render option.
   * @param value        Option.
   * @param isSelected  Set to true if option is selected.
   */
  getListItem(value, isSelected, description) {
    let line = this.settings.indent ?? "";
    line += isSelected ? `${this.settings.listPointer} ` : "  ";
    if (isSelected) {
      line += underline(this.highlight(value));
    } else {
      line += this.highlight(value);
    }
    if (description) {
      line += dim(`${description}`);
    }
    return line;
  }
  /** Get suggestions row height. */
  getListHeight(suggestions = this.suggestions) {
    return Math.min(
      suggestions.length,
      this.settings.maxRows || suggestions.length
    );
  }
  /**
   * Handle user input event.
   * @param event Key event.
   */
  async handleEvent(event) {
    switch (true) {
      case this.isKey(this.settings.keys, "next", event):
        if (this.settings.list) {
          this.selectPreviousSuggestion();
        } else {
          this.selectNextSuggestion();
        }
        break;
      case this.isKey(this.settings.keys, "previous", event):
        if (this.settings.list) {
          this.selectNextSuggestion();
        } else {
          this.selectPreviousSuggestion();
        }
        break;
      case this.isKey(this.settings.keys, "nextPage", event):
        if (this.settings.list) {
          this.selectPreviousSuggestionsPage();
        } else {
          this.selectNextSuggestionsPage();
        }
        break;
      case this.isKey(this.settings.keys, "previousPage", event):
        if (this.settings.list) {
          this.selectNextSuggestionsPage();
        } else {
          this.selectPreviousSuggestionsPage();
        }
        break;
      case this.isKey(this.settings.keys, "complete", event):
        await this.#completeValue();
        break;
      case this.isKey(this.settings.keys, "moveCursorRight", event):
        if (this.inputIndex < this.inputValue.length) {
          this.moveCursorRight();
        } else {
          await this.#completeValue();
        }
        break;
      case this.isKey(this.settings.keys, "submit", event):
        if (this.settings.completeOnSubmit || this.getCurrentInputValue().trim().length == 0 && this.suggestionsIndex != -1) {
          await this.#completeValue();
        }
        await this.submit();
        break;
      default:
        await super.handleEvent(event);
    }
  }
  /** Delete char right. */
  deleteCharRight() {
    if (this.inputIndex < this.inputValue.length) {
      super.deleteCharRight();
      if (!this.getCurrentInputValue().length) {
        this.suggestionsIndex = -1;
        this.suggestionsOffset = 0;
      }
    }
  }
  async #completeValue() {
    this.inputValue = await this.complete();
    this.inputIndex = this.inputValue.length;
    this.suggestionsIndex = 0;
    this.suggestionsOffset = 0;
  }
  async complete() {
    let input = this.getCurrentInputValue();
    const suggestion = this.suggestions[this.suggestionsIndex]?.toString();
    if (this.settings.complete) {
      input = await this.settings.complete(input, suggestion);
    } else if (this.#isFileModeEnabled() && input.at(-1) !== sep14 && await isDirectory(input) && (this.getCurrentInputValue().at(-1) !== "." || this.getCurrentInputValue().endsWith(".."))) {
      input += sep14;
    } else if (suggestion) {
      input = suggestion;
    }
    return this.#isFileModeEnabled() ? normalize19(input) : input;
  }
  /** Select previous suggestion. */
  selectPreviousSuggestion() {
    if (this.suggestions.length) {
      if (this.suggestionsIndex > -1) {
        this.suggestionsIndex--;
        if (this.suggestionsIndex < this.suggestionsOffset) {
          this.suggestionsOffset--;
        }
      }
    }
  }
  /** Select next suggestion. */
  selectNextSuggestion() {
    if (this.suggestions.length) {
      if (this.suggestionsIndex < this.suggestions.length - 1) {
        this.suggestionsIndex++;
        if (this.suggestionsIndex >= this.suggestionsOffset + this.getListHeight()) {
          this.suggestionsOffset++;
        }
      }
    }
  }
  /** Select previous suggestions page. */
  selectPreviousSuggestionsPage() {
    if (this.suggestions.length) {
      const height = this.getListHeight();
      if (this.suggestionsOffset >= height) {
        this.suggestionsIndex -= height;
        this.suggestionsOffset -= height;
      } else if (this.suggestionsOffset > 0) {
        this.suggestionsIndex -= this.suggestionsOffset;
        this.suggestionsOffset = 0;
      }
    }
  }
  /** Select next suggestions page. */
  selectNextSuggestionsPage() {
    if (this.suggestions.length) {
      const height = this.getListHeight();
      if (this.suggestionsOffset + height + height < this.suggestions.length) {
        this.suggestionsIndex += height;
        this.suggestionsOffset += height;
      } else if (this.suggestionsOffset + height < this.suggestions.length) {
        const offset = this.suggestions.length - height;
        this.suggestionsIndex += offset - this.suggestionsOffset;
        this.suggestionsOffset = offset;
      }
    }
  }
};
function uniqueSuggestions(value, index, self) {
  return typeof value !== "undefined" && value !== "" && self.indexOf(value) === index;
}
function isDirectory(path10) {
  return Deno.stat(path10).then((file) => file.isDirectory).catch(() => false);
}
async function listDir(path10, mode) {
  const fileNames = [];
  for await (const file of Deno.readDir(path10 || ".")) {
    if (mode === true && (file.name.startsWith(".") || file.name.endsWith("~"))) {
      continue;
    }
    const filePath = join19(path10, file.name);
    if (mode instanceof RegExp && !mode.test(filePath)) {
      continue;
    }
    fileNames.push(filePath);
  }
  return fileNames.sort(function(a, b) {
    return a.toLowerCase().localeCompare(b.toLowerCase());
  });
}

// subrepos/cliffy/prompt/input.ts
var Input = class extends GenericSuggestions {
  settings;
  /** Execute the prompt with provided options. */
  static prompt(options) {
    return new this(options).prompt();
  }
  /**
   * Inject prompt value. If called, the prompt doesn't prompt for an input and
   * returns immediately the injected value. Can be used for unit tests or pre
   * selections.
   *
   * @param value Input value.
   */
  static inject(value) {
    GenericPrompt.inject(value);
  }
  constructor(options) {
    super();
    if (typeof options === "string") {
      options = { message: options };
    }
    this.settings = this.getDefaultSettings(options);
  }
  getDefaultSettings(options) {
    return {
      ...super.getDefaultSettings(options),
      minLength: options.minLength ?? 0,
      maxLength: options.maxLength ?? Infinity
    };
  }
  success(value) {
    this.saveSuggestions(value);
    return super.success(value);
  }
  /** Get input value. */
  getValue() {
    return this.settings.files ? normalize19(this.inputValue) : this.inputValue;
  }
  /**
   * Validate input value.
   * @param value User input value.
   * @return True on success, false or error message on error.
   */
  validate(value) {
    if (typeof value !== "string") {
      return false;
    }
    if (value.length < this.settings.minLength) {
      return `Value must be longer than ${this.settings.minLength} but has a length of ${value.length}.`;
    }
    if (value.length > this.settings.maxLength) {
      return `Value can't be longer than ${this.settings.maxLength} but has a length of ${value.length}.`;
    }
    return true;
  }
  /**
   * Map input value to output value.
   * @param value Input value.
   * @return Output value.
   */
  transform(value) {
    return value.trim();
  }
  /**
   * Format output value.
   * @param value Output value.
   */
  format(value) {
    return value;
  }
};

// tools/input_tools.js
function selectOne({ message, showList, showInfo, options, optionDescriptions, autocompleteOnSubmit = true }) {
  let optionStrings;
  if (options instanceof Array) {
    optionStrings = options;
    options = Object.fromEntries(optionStrings.map((each2) => [each2, each2]));
  } else {
    optionStrings = Object.keys(options);
  }
  const { rows, columns } = Deno.consoleSize();
  const maxOptionWidth = columns - 3;
  const longest2 = Math.max(...optionStrings.map((each2) => each2.length));
  const operations = {};
  const suggestions = optionStrings;
  const suggestionDescriptions = [];
  if (optionDescriptions) {
    for (let [suggestion, description] of zip2(suggestions, optionDescriptions)) {
      let offset = 2;
      if (suggestion.indexOf("\u2744\uFE0F") != -1) {
        offset = 3;
      }
      suggestionDescriptions.push(
        stripColor(suggestion.padEnd(longest2 + offset, " ") + ": " + description).slice(0, maxOptionWidth).slice(suggestion.length + 2)
      );
    }
  }
  return Input.prompt({
    message,
    list: showList,
    info: showInfo,
    suggestions,
    suggestionDescriptions,
    completeOnSubmit: autocompleteOnSubmit
  }).then((answer) => {
    if (!autocompleteOnSubmit) {
      return answer;
    }
    if (optionStrings.includes(answer)) {
      return options[answer];
    } else {
      optionStrings = optionStrings.filter(
        (value) => stripColor(value.toString()).toLowerCase().startsWith(answer)
      ).sort(
        (a, b) => distance2((a || a).toString(), answer) - distance2((b || b).toString(), answer)
      );
      return options[optionStrings[0]];
    }
  });
}

// https://deno.land/x/deno_dom@v0.1.43/build/deno-wasm/deno-wasm.js
var wasm;
var WASM_VECTOR_LEN = 0;
var cachegetUint8Memory0 = null;
function getUint8Memory0() {
  if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
    cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachegetUint8Memory0;
}
var cachedTextEncoder = new TextEncoder("utf-8");
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length);
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code2 = arg.charCodeAt(offset);
    if (code2 > 127)
      break;
    mem[ptr + offset] = code2;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3);
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
var cachegetInt32Memory0 = null;
function getInt32Memory0() {
  if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
    cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachegetInt32Memory0;
}
var cachedTextDecoder = new TextDecoder("utf-8", {
  ignoreBOM: true,
  fatal: true
});
cachedTextDecoder.decode();
function getStringFromWasm0(ptr, len) {
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
function parse17(html) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    var ptr0 = passStringToWasm0(
      html,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    var len0 = WASM_VECTOR_LEN;
    wasm.parse(retptr, ptr0, len0);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(r0, r1);
  }
}
function parse_frag(html, context_local_name) {
  try {
    const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
    var ptr0 = passStringToWasm0(
      html,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    var len0 = WASM_VECTOR_LEN;
    var ptr1 = passStringToWasm0(
      context_local_name,
      wasm.__wbindgen_malloc,
      wasm.__wbindgen_realloc
    );
    var len1 = WASM_VECTOR_LEN;
    wasm.parse_frag(retptr, ptr0, len0, ptr1, len1);
    var r0 = getInt32Memory0()[retptr / 4 + 0];
    var r1 = getInt32Memory0()[retptr / 4 + 1];
    return getStringFromWasm0(r0, r1);
  } finally {
    wasm.__wbindgen_add_to_stack_pointer(16);
    wasm.__wbindgen_free(r0, r1);
  }
}
async function load2(module2, imports) {
  if (typeof Response === "function" && module2 instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module2, imports);
      } catch (e) {
        if (module2.headers.get("Content-Type") != "application/wasm") {
          console.warn(
            "`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",
            e
          );
        } else {
          throw e;
        }
      }
    }
    const bytes = await module2.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module2, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module2 };
    } else {
      return instance;
    }
  }
}
async function init(input) {
  if (typeof input === "undefined") {
    input = new URL("deno-wasm_bg.wasm", import.meta.url);
  }
  const imports = {};
  imports.env = { now() {
  } };
  input = Uint8Array.from(
    atob(
      "AGFzbQEAAAABpoKAgAAlYAAAYAABf2AAAXxgAX8AYAF/AX9gAX8BfmACf38AYAJ/fwF/YAJ/fwF+YAN/f38AYAN/f38Bf2AEf39/fwBgBH9/f38Bf2AFf39/f38AYAV/f39/fwF/YAZ/f39/f38Bf2AHf39/f39/fwBgB39/f39/f38Bf2ALf39/f39/f39/f38Bf2APf39/f39/f39/f39/f39/AX9gE39/f39/f39/f39/f39/f39/f38Bf2AJf39/f39/fn5+AGAFf39/f34AYAZ/f39/fn8AYAR/f39+AGADf39+AGADf39+AX9gBX9/fn5/AX9gAn9+AGACf34Bf2ADf35/AGADf35/AX9gBH9+f38Bf2AFf35/fn8AYAJ/fABgBH98f38Bf2ADfn9/AX8Ci4CAgAABA2VudgNub3cAAgOLhYCAAIkFCwkYBgsDDRwECRcLCgkKCQMMCQwFBgcKDQofCQkJGwkGAwoHBwMGDQkKBwoGGQYMAwcHIwMNCg0PCwkJCh4DBwkHCSMKAwoLBAYHBAMGCQYJBgMGBgMDGgYHBgsJBgYJCgYJAwQGGhoYBwggHwYGHAcGBhAJCRwHCgkVBwcKBxYQAwMDCQoMEQcHBwQJDg4DBwMGBwcJBgcGHQoLJA0EBwcLBwQGBgMDBwcKBwYHBwQHBgEJBwcGBwYDDQcYCQsDBwYGBgMHAwcEBwMHBwcHCQkDBiIJCQkJCQkHBwkGBgYGBgYGBwMGBgYJCQkJFAYGBgYGEQMHAwYNBwMKDgsTAwMDAx0JBwcKBwcJBwQSBiEJAwsLCwsLCwcDAwYHAwkDAwMJBgMJBAcHBwMDAwcDBwcDBwcKBwcHAwoDBgcDAw0LBwcDAwMEBwYJCQkJCQcGBgQLBwcHCQYGCQsGBwcHBwcHBw0GCQYHBwcHBwcJBwYHBwcKBgMHBwcKBgcHBwYJBgMGBAYDAwYBAwcECQoHBwcDCgMKCgoKCgoHCgcDBgAHBgcGBAkOBwYHBwcHAwMHAAYEBBoHBwcHBgQGBAcECwMHBwcDBwYECQsGCQYECQMHCgkHBwcHBwYLAwMEBwMDBwYEBAMDBwYHBwQHBgQGBAQHBwcMBgQHBwoHBw0HBwcHBwcDBwMHBwcHBgMEAwQHBwQECQcDBAMfAwYDBAQGBAcHCQkJBwcKCgcEBgcHBwcHBwcHBwcEBAQEBwYGCgcHCgoKCgMHAwEHAwcHBwQEAAkEBAQEBAUHAQEBAAUCBQUFAAcBAQQODAoHBAQFAwMDAwMDAwMDAwMDAwMDAwYDAwMDAwMAAwADAwSHgICAAAFwAa8BrwEFg4CAgAABABUGiYCAgAABfwFBgIDAAAsHgoGAgAAHBm1lbW9yeQIABXBhcnNlANABCnBhcnNlX2ZyYWcAngEfX193YmluZGdlbl9hZGRfdG9fc3RhY2tfcG9pbnRlcgCrBBFfX3diaW5kZ2VuX21hbGxvYwCzAxJfX3diaW5kZ2VuX3JlYWxsb2MA0gMPX193YmluZGdlbl9mcmVlAPYDCd+CgIAAAQBBAQuuAe4EtgPvBPkD+APwBOkD8QSTA6wB3QLXBPcC1gOvBIAErQSBBKoCqgGJAvIEtQEyjwOqBKgDmwOVBPME/wLiA64E2wOhA4YDyQS7AswB9ASHA5YDrgHpArEC1gLCAqYEggTcA5wDmAHqAvUE+wP2BJcDlAHeAvcEtwP4BLEEgwSzBPkEigGuAqUCkAP6BLAE5wPFAooCxgTPAvsE3gPyA9UDyAL8BNcD8gL9BNgE/gT/BIAFiwGyBIUEtgK3AoEFhwK4Ar8CkQPGAowCggWGAoQBiwODBYED6AOEBd0E1AOKBIgEf9kChgWYA5UB3wK1ArUE4AKVA7YE4QK0BNgDhwTGA98DiQSKA7oCkQHrApkDrwHsAuAE3wTQA/gB3AKkA4sE4QTqA4gFmgOhBOICuQO7BOAD7QKiBPwDkASRBNQCfIkF7QTABH7GAe8CvwSpBMEB4wKjAcoBCqy1kIAAiQXukAICBX8CfiMAQdAHayIEJAAgBCACOgCrBwJAQQAoAsiOUkEESQ0AQQRB2JrAAEEXEPQCRQ0AQQAoAsiOUkEESQ0AIAQgAzYCrAcgBEGwB2pBDGoiBUEBNgIAIARBxAdqIgZBATYCACAEQcyGwAA2ArgHIARBADYCsAcgBEEPNgKEByAEIARBgAdqNgLAByAEIARBrAdqNgKAByAEQZAEaiAEQbAHahBiIARBg4DEADYCyAcgBEGDgMQANgK8ByAEIAQoApQEIgc2ArQHIAQgByAEKAKYBGo2ArAHIARBoARqIARBsAdqEG8CQCAEKAKQBCIIRQ0AIAcgCEEBEJQECyAEQYAHakEMakEONgIAIAVBAjYCACAGQQI2AgAgBEEQNgKEByAEQZCbwAA2ArgHIARBADYCsAcgBCAEQasHajYCiAcgBCAEQaAEajYCgAcgBCAEQYAHajYCwAcgBEGwB2pBBEGMnMAAEIsCIAQoAqAEIgdFDQAgBCgCpAQgB0EBEJQECwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAkH/AXEOFwABAgMEBQYHCAk+Cjc2NQswDA0ODxARAAtBASECIAMtABRBfmpB/wFxIgdBAWpBACAHQQRJG0F/ag4CYmNkC0EBIQIgAy0AFCIHQX5qIgZB/wFxIgVBAWpBACAFQQRJGw4DXV5fcQtBASECIAMtABQiB0F+aiIGQf8BcSIFQQFqQQAgBUEESRsOA1hZWnULQQEhAiADLQAUIgVBfmoiBkH/AXEiB0EBakEAIAdBBEkbDgNWVFV5CyADLQAUIgJBfmpB/wFxIgdBAWpBACAHQQRJGw4DUlBRfQtBASECIAMtABQiBUF+aiIGQf8BcSIHQQFqQQAgB0EESRsOA05MTYABC0EBIQIgAy0AFCIFQX5qQf8BcSIHQQFqQQAgB0EESRsOBUdERsQBRUcLQQAhAiADLQAUIgVBfmpB/wFxIgdBAWpBACAHQQRJG0F+ag4DPkA/QAtBASECIAMtABQiBUF+akH/AXEiB0EBakEAIAdBBEkbDgU8ODk6OzwLQQAhAiADLQAUQX5qQf8BcSIHQQFqQQAgB0EESRtBfmoOAjXiATYLQQEhByADLQAUIgVBfmpB/wFxIgJBAWpBACACQQRJGw4FMi0u0QEv0QELQQEhAiADLQAUIgVBfmpB/wFxIgdBAWpBACAHQQRJGw4FKCUmvwEnKAsgAy0AFCIHQX5qQf8BcSICQQFqQQAgAkEESRsOBSEeHyIgIgtBASEHIAMtABQiBUF+akH/AXEiAkEBakEAIAJBBEkbDgUcFxj9ARn9AQtBASECIAMtABQiBUF+akH/AXEiB0EBakEAIAdBBEkbDgUVEBH/ARL/AQtBASEHIAMtABQiBUF+akH/AXEiAkEBakEAIAJBBEkbDgUOCQqGAguGAgtBASEHIAMtABQiBUF+akH/AXEiAkEBakEAIAJBBEkbDgUBAgOIAgSIAgtBASEHAkACQAJAAkACQCADLQAUIgVBfmpB/wFxIgJBAWpBACACQQRJGw4FAFkBjQICjQILIAVB/wFxRQ0DDIwCCyADLQAMDgIBQIsCCyAAQQA6AAAM3wELIABBAjoAACAAIAMpAgA3AgQgAEEMaiADQQhqKAIANgIAQQAhAgyDAgsCQCADKQMAIglCgoCAgNDLAFENACAJQoKAgICg5gBSDYkCIARBsAdqQRBqIANBEGopAwA3AwAgBEGwB2pBCGogA0EIaikDADcDACAEIAMpAwA3A7AHIAAgAUEGIARBsAdqEAEMigILIARBsAdqQRBqIANBEGopAwA3AwAgBEGwB2pBCGogA0EIaikDADcDACAEIAMpAwA3A7AHIAAgAUEDIARBsAdqEAEMiQILIAVB/wFxRQ0FDIYCCyAEQfAGakEIaiADQQhqKAIANgIAIAQgAykCADcD8AYgACABIARB8AZqEKYCDNsBCyADLQAMDgIBAoQCCyAAQQA6AAAM2QELIABBAjoAACAAIAMpAgA3AgQgAEEMaiADQQhqKAIANgIAQQAhAgz9AQsgBEGwB2pBEGogA0EQaikDADcDACAEQbAHakEIaiADQQhqKQMANwMAIAQgAykDADcDsAcgACABQQYgBEGwB2oQAQyDAgsgAykDAEKCgICAoOYAUg2AAiAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBBiAEQbAHahABDIICCyAEQeAGakEIaiADQQhqKAIANgIAIAQgAykCADcD4AYgACABIARB4AZqEJ8CDNUBCyADLQAMDgIBAvsBCyAAQQA6AAAM0wELIABBAjoAACAAIAMpAgA3AgQgAEEMaiADQQhqKAIANgIAQQAhAgz3AQsgBEHQBmpBCGogA0EIaigCADYCACAEIAMpAgA3A9AGIAAgASAEQdAGahCAA0EAIQIM9gELIAMpAwAhCSAFQf8BcUUN9gEgCUKCgICAoOYAUg33ASAAQQA6AAAgAUEWOgBjDNABCyAEQcAGakEIaiADQQhqKAIANgIAIAQgAykCADcDwAYgACABIARBwAZqEJ8CQQEhBwz0AQsgAy0ADA4CAQLtAQsCQCABQThqKAIAQQFGDQAgBEGwB2ogASADEHUgBEGwB2oQ9QELIABBADoAAEEBIQcMzQELIABBAjoAACAAIAMpAgA3AgQgAEEMaiADQQhqKAIANgIADPABCyAEQbAGakEIaiADQQhqKAIANgIAIAQgAykCADcDsAYgACABIARBsAZqEIADDO8BCyADKQMAIQkgBUH/AXFFDegBIAlCgoCAgNDSAFIN6QECQAJAIAFBOGooAgBBAUcNACAEQbAHaiABIAMQdSAEQbAHahD1AQwBCyAEIAEQpQM2ArAHIARBsAdqEPsBIAFBEGooAgANACABQTRqKAIAIAFBOGooAgBCgoCAgNDSABC1Aw0AIAFBFDoAYwsgAEEAOgAAQQEhBwzKAQsgBEGgBmpBCGogA0EIaigCADYCACAEIAMpAgA3A6AGIAAgASAEQaAGahCFAgzJAQsgAy0ADA4CAQLkAQsgAEEAOgAADMcBCyAAQQI6AAAgACADKQIANwIEIABBDGogA0EIaigCADYCAEEAIQIM6wELIARBsAdqQRBqIANBEGopAwA3AwAgBEGwB2pBCGogA0EIaikDADcDACAEIAMpAwA3A7AHIAAgAUEGIARBsAdqEAEM8QELIAMpAwAhCSAFQf8BcUUN3wEgCUKCgICAoOYAUg3gAQJAAkAgAUEQaigCAA0AIAFBFToAYwwBCyAEQbAHaiABIAMQdSAEQbAHahD1AQsgAEEAOgAADMQBCyAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBBiAEQbAHahABDO8BCyAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBBiAEQbAHahABDO4BCwJAIAFBNGooAgAgAUE4aigCABDVAkUNACAEQbAHaiABIAMQdSAEQbAHahD1ASABQoKAgIDgBxCaARogARCSAQJAIAFBHGooAgAiAkUNACABIAJBf2o2AhwLIAEgARBJQf8BcToAYyABEEkhAiAAQQM6AAAgAEEYaiADQRBqKQMANwMAIABBEGogA0EIaikDADcDACAAIAMpAwA3AwggACACQf8BcToAAQzuAQsgAEEAOgAAQQEhBwzBAQsgAykDACEJIAdB/wFxRQ3VASAJQoKAgIDgB1IN1AEM1gELIAdB/wFxDdMBDNgBCyADLQAUIgJBAk8N0QEgAykDACEJIAJFDdABAkACQCAJQoGAgICA0gBVDQACQCAJQoGAgICAN1UNACAJQoKAgIDQBVENAiAJQoKAgIDwMVIN1AEMAgsgCUKCgICAgDdRDQEgCUKCgICAkM0AUg3TAQwBCwJAIAlCgYCAgNDyAFUNACAJQoKAgICA0gBRDQEgCUKCgICA0NsAUg3TAQwBCyAJQoKAgIDQ8gBRDQAgCUKCgICAwPUAUg3SAQsgBEGAB2pBEGogA0EQaikDADcDACAEQYAHakEIaiADQQhqKQMANwMAIAQgAykDADcDgAcgBEGwB2ogASAEQYAHahB2IARBsAdqEPUBIAQpA4AHIglCA4NQDTYMzgELIARBwAVqQQhqIANBCGooAgA2AgAgBCADKQIANwPABSAAIAEgBEHABWoQnwJBASEHDOIBCyAEQbAFakEIaiADQQhqKAIANgIAIAQgAykCADcDsAUgACABIARBsAVqEIADQQEhB0EAIQIM4QELIARBsAdqQRBqIANBEGopAwA3AwAgBEGwB2pBCGog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IAAgAykCADcCBCAAQQxqIANBCGooAgA2AgAMwAELIARBgAFqQQhqIANBCGooAgA2AgAgBCADKQIANwOAASAAIAEgBEGAAWoQgAMMvwELIAMpAwAhCSAFQf8BcUUNMCAJQoKAgIDgB1INMiAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBAyAEQbAHahABDMYBCyAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBAyAEQbAHahABDMUBCwJAAkAgAy0ADA4CAAEtCyAAQQI6AAAgACADKQIANwIEIABBDGogA0EIaigCADYCAAy9AQsgBEGwB2pBEGogA0EQaikDADcDACAEQbAHakEIaiADQQhqKQMANwMAIAQgAykDADcDsAcgACABQQMgBEGwB2oQAQzEAQsgAykDACEJIAJB/wFxRQ0pIAlCgoCAgLDFAFINKiAEIAEQpQM2ArAHIARBsAdqEPsBIABBADoAACABQQM6AGMMHwsgBEHAAGpBCGogA0EIaigCADYCACAEIAMpAgA3A0AgACABIARBwABqEJ8CQQEhBwy7AQsCQAJAIAMtAAwOAgABJQsgAEECOgAAIAAgAykCADcCBCAAQQxqIANBCGooAgA2AgAMugELIARBMGpBCGogA0EIaigCADYCACAEIAMpAgA3AzAgACABIARBMGoQgAMMuQELIAMpAwAhCSAFQf8BcUUNIQJAIAlCgoCAgOAHUQ0AIAlCgoCAgPAGUg0kIAQgARClAzYCsAcgBEGwB2oQ+wEgAEEAOgAAIAFBBToAY0EBIQcMugELIARBgAdqQRBqIANBEGopAwA3AwAgBEGAB2pBCGogA0EIaikDADcDACAEIAMpAwA3A4AHAkACQCABQTRqKAIAIAFBOGooAgAQ1QJFDQAgARCaAiABQoKAgIDgBxB3IAEQkgECQCABQRxqKAIAIgdFDQAgASAHQX9qNgIcCyABIAEQSUH/AXE6AGMMAQsgBEGwB2ogASAEQYAHahB2IARBsAdqEPUBC0EAIQcgAEEAOgAAIARBgAdqEOYBDLkBCyAHQf8BcUUNAgwcCyAEQSBqQQhqIANBCGooAgA2AgAgBCADKQIANwMgIAAgASAEQSBqEJ8CQQEhBwy3AQsCQAJAIAMtAAwOAgABHAsgAEECOgAAIAAgAykCADcCBCAAQQxqIANBCGooAgA2AgAMtgELIABBADoAAAwZCwJAIAMpAwAiCUKCgICA8AZRDQACQCAJQoKAgICg5gBRDQAgA0EVaiEFIANBCGohAgwcCyAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBBiAEQbAHahABDL0BCyAEQbAHakEIaiADQRBqKAIANgIAIAQgAykDCDcDsAdBACEHIAFBAEKCgICA8ABCgoCAgPAGIARBsAdqEB8hBQJAIAEoAghFDQAgAUEIahD7AQsgAUEDOgBjIAEgBTYCCCAAQQA6AAAMtQELIAdB/wFxRQ0CDBMLIARBEGpBCGogA0EIaigCADYCACAEIAMpAgA3AxAgACABIARBEGoQpgJBASEHDLMBCwJAAkAgAy0ADA4CAAETCyAAQQI6AAAgACADKQIANwIEIABBDGogA0EIaigCADYCAAyyAQsgAEEAOgAADBULAkAgAykDACIJQoKAgICg5gBRDQAgA0EVaiEFIANBCGohAgwSCyAEQbAHakEQaiADQRBqKQMAIgk3AwAgBEGwB2pBCGogA0EIaikDACIKNwMAIAQgAykDADcDsAcgBEGAB2pBCGogCT4CACAEIAo3A4AHIAEgBEGAB2oQjwIgAEEAOgAAIAFBAjoAYyAEQbAHahDEAkEAIQcMsQELIARBCGogA0EIaigCADYCACAEIAMpAgA3AwAgACABIAQQpgJBASEHDLABCwJAAkAgAy0ADA4CAAECCyAAQQI6AAAgACADKQIANwIEIABBDGogA0EIaigCADYCAAyvAQsgAEEAOgAADBILIARBgAdqQRBqIgIgA0EQaikDADcDACAEQYAHakEIaiIHIANBCGopAwA3AwAgBCADKQMANwOAByABQd8Aai0AAA0MIARBsAdqIAEgBEGAB2oQdSAEQbAHahD1ASABQdgAakEAOgAAIAFBADoAZAwMCyAEQZgHakEIaiADQQhqKAIANgIAIAQgAykCADcDmAcgACABIARBmAdqEKYCDIgBCyAJpyICIAIoAgxBAWo2AgwgBCkDgAchCQyXAQsgBSAHQeSpwAAQywIACyAEIAEQpQM2ArAH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DHoLIARBuAdqIANBEGooAgA2AgAgBCADKQMINwOwByABEIACQQEhAiAEIAFBAUKCgICA8ABCgoCAgIDnACAEQbAHahAfNgKAByAEQYAHahD7ASAAQQE6AAAgAUEAOgBlQQAhBwx5CyAEQZgCakEQaiADQRBqKQMANwMAIARBmAJqQQhqIANBCGopAwA3AwAgBCADKQMANwOYAiABEIACIAEQMSABQQA6AGUgACABIARBmAJqQQMQ0wJBACEHDHgLIAFBADoAZSAEQbACakEQaiADQRBqKQMANwMAIARBsAJqQQhqIANBCGopAwA3AwAgBCADKQMANwOwAiAAIAEgBEGwAmpBAxDTAkEAIQcMdwsgBEHIAmpBEGogA0EQaikDADcDACAEQcgCakEIaiADQQhqKQMANwMAIAQgAykDADcDyAIgACABIARByAJqQQMQ0wJBACEHDHYLIARB4AJqQRBqIANBEGopAwA3AwAgBEHgAmpBCGogA0EIaikDADcDACAEIAMpAwA3A+ACIAAgASAEQeACakKCgICA4AAQvQFBACEHDHULIARB+AJqQRBqIANBEGopAwA3AwAgBEH4AmpBCGogA0EIaikDADcDACAEIAMpAwA3A/gCIAAgASAEQfgCakKCgICAIBC9AUEAIQcMdAsgAUKCgICAoAQQcAwkCyABEJsCDCELIARBgAdqQQhqIgcgA0EQaigCADYCACAEIAMpAwg3A4AHIAFBNGooAgAgAUE4aigCAEKCgICAwO4AELUDRQ0aIAQgARClAzYCsAcgBEGwB2oQ+wEMGgsgBEG4B2ogA0EQaigCADYCACAEIAMpAwg3A7AHQQEhAiAEIAFBAUKCgICA8AAgCSAEQbAHahAfNgKAByAEQYAHahD7AQxuCyADKAIIIQUgAygCDCIHIAMoAhAiAhBCQQFzIQYMIgsgBEHwAWpBCGoiByADQRBqKAIANgIAIAQgAykDCDcD8AEgAS0AZEUNFiABEIACDBYLIARBuAdqIANBEGooAgA2AgAgBCADKQMINwOwByABEDFBACEHIAQgAUEAQoKAgIDwACAJIARBsAdqEB82AoAHIARBgAdqEPsBQQEhAiAEQQE2ArAHIAFBPGogBEGwB2oQ0QIMIgsgBEHYAWpBEGogA0EQaikDADcDACAEQdgBakEIaiADQQhqKQMANwMAIAQgAykDADcD2AEgARAxIAFBNGooAgAgAUE4aigCAEKCgICA0AcQWEUNEyAEQbAHakEIakENNgIAIARBvK3AADYCtAcgBEEANgKwByABQcgAaiAEQbAHahDwAiABQoKAgIDQBxAIIAEQMQwTCyAEQbAHakEIakEONgIAIARBya3AADYCtAcgBEEANgKwByABQcgAaiAEQbAHahDwAiABEJsCIAFCgoCAgIA2EJoBGgwfC0EBIQYLIAFBADoAZSAEQbgHaiADQRBqKQMANwMAIAQgAykDCDcDsAcgBEIANwOQBCABQThqKAIAIQcgAUE0aigCACEFIAYNCyAHQQJ0IQcgBUF8aiEIA0AgB0UNECAIIAdqKAIAIgVBGGotAABBBEcNCCAFQShqIgYgBUEwaiIFEMQDDQ0gB0F8aiEHIAYgBRCjA0UNAAwQCwsgBEGwB2pBEGoiByADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwBwJAAkAgASgCDEUNACABQTRqKAIAIAFBOGooAgAQ1QJFDQELIAEQgAIgBCkDsAchCSAEQYAHakEIaiAHKAIANgIAIAQgBCkDuAc3A4AHIAQgAUEAQoKAgIDwACAJIARBgAdqEB8iBzYCkAQgAUE0aigCACABQThqKAIAENUCDQgCQCABQQxqIgEoAgBFDQAgARD7AQsgASAHNgIADAoLIARBiAdqQQw2AgAgBEHXrcAANgKEByAEQQA2AoAHIAFByABqIARBgAdqEPACIABBADoAACAEQbAHahDmAUEAIQcMaAsgBEGAB2pBEGogA0EQaikDADcDACAEQYAHakEIaiADQQhqKQMANwMAIAQgAykDADcDgAcgBEGwB2ogASAEQYAHahB2IARBsAdqEPUBAkACQAJAIAEtAGVFDQACQCABQThqKAIAQQJJDQAgAUE0aigCACIHKAIEQoKAgIDw9wAQhAINAwsgAEEAOgAADAELIABBADoAAAsgBEGAB2oQ5gEMbwtBASECIAcoAgQiByAHKAIAQQFqIgU2AgAgBUUNBCAEIAc2AqAEIARBoARqELoBIAFBMGpBARCIAyAEKQOAByEJIARBuAdqIARBkAdqKAIANgIAIAQgBCkDiAc3A7AHIAQgAUEAQoKAgIDwACAJIARBsAdqEB82ApAEIARBkARq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AgALIAlCgoCAgNDLAFENAiAJQoKAgICg5gBRDQELIARBsAdqQRBqIANBEGopAwA3AwAgBEGwB2pBCGogA0EIaikDADcDACAEIAMpAwA3A7AHIAAgASAEQbAHahB1IARBsAdqEFYMBAsgBEGwB2pBEGogA0EQaikDADcDACAEQbAHakEIaiADQQhqKQMANwMAIAQgAykDADcDsAcgACABQQYgBEGwB2oQAQwDCyAEQbAHakEQaiADQRBqKQMANwMAIARBsAdqQQhqIANBCGopAwA3AwAgBCADKQMANwOwByAAIAFBAyAEQbAHahABDAILIARBgAdqQRBqIgIgA0EQaikDADcDACAEQYAHakEIaiIHIANBCGopAwA3AwAgBCADKQMANwOAByAEQbAHaiABIARBgAdqEHUgBEGwB2oQ9QEgAEEYaiACKQMANwMAIABBEGogBykDADcDACAAIAQpA4AHNwMIIABBgww7AQAMAQsgBEGwB2pBEGogA0EQaikDADcDACAEQbAHakEIaiADQQhqKQMANwMAIAQgAykDADcDsAcgACABIARBsAdqEHUgBEGwB2oQVgsgBEHQB2okAAu6kwECDX8BfiMAQcACayIDJAACQAJAAkACQAJAIAEoAoABIgRFDQAgAUEANgKAAUEBIQUCQAJAAkAgBCABIAIQDUH/AXEOAwIBAAILIANB2AFqIARBxAAQxAQaIANBsAJqIANB2AFqEPEBIAEgAykDsAIgAy0AuAIQPiAEQcQAQQQQlARBACEFDAYLQQAhBQsCQCABKAKAASICRQ0AAkAgAigCAEUNAAJAIAIoAgQiBkEQSQ0AIAZBfnEhBwJAAkAgBkEBcQ0AIAJBDGooAgAiBkEIaiICIAZPDQFBACgCoLZRQQAoAqS2UUGossAAEO4CAAsgByAHKAEAIgJBf2o2AQAgAkEBRw0BIAcoAgQiBkEIaiICIAZJDQULIAcgAkF/akF4cUEIakEEEJQECyABKAKAASECCyACQcQAQQQQlAQLIAEgBDYCgAEMAwtBACgCyI5SQQNNDQEgA0HkAWpBATYCACADQewBakEBNgIAIANB9LvAADYC4AEgA0EANgLYASADQRg2ArQCIAMgAUGkAmo2ArACIAMgA0GwAmo2AugBIANB2AFqQQRB/LvAABCLAgwBC0EAKAKgtlFBACgCpLZRQaiywAAQ7gIACyABQaQCaiEGAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAEtAKQCDisxACsqKSgBJwIlJCMDIiEgHx4dHBsaGRgXFhUUExIREA8OBAUGDQwKCQgHMQsgA0HIAWogASACQoHIABBpIAMoAsgBIgRBAkYNKyABQewBaiEIIANB2AFqQQRyIQcDQCADKALMASEFAkACQAJAAkACQCAEDQAgBQ0DIAEtAOYBDQFBACEFQcC2wAAhBEENIQkMAgsgAyADKQPQATcD4AEgAyAFNgLcASADQQM2AtgBIAEgA0HYAWoQ5wEMAwsgA0ECNgLkASADQbC2wAA2AuABIANBAjYC7AEgA0EANgLYASADQRg2ArwCIAMgBjYCuAIgA0EXNgK0AiADIAg2ArACIAMgA0GwAmo2AugBIANBuAFqIANB2AFqEGIgAygCuAEhBCADKAK8ASEJIAMoAsABIQpBASEFCyADIAo2AugBIAMgCTYC5AEgAyAENgLgASADIAU2AtwBIANBBjYC2AEgASADQdgBahDnASADQgA3ArQCIANBDzYCsAIgA0Hv//YFNgK4ASADQbACaiADQbgBakEDEBwgB0EIaiADQbACakEIaigCADYCACAHIAMpA7ACNwIAIANBAzYC2AEgASADQdgBahDnAQwBCyABIAUQpQELIANByAFqIAEgAkKByAAQaSADKALIASIEQQJHDQAMLAsLAkACQCABQaUCai0AACIFQQJJDQACQAJAAkAgASACELADIgJBX2oODwIEBAQEBAQEBAQEBAQEAQALIAJBgIDEAEYNKAwDCyABELICIAEgBToApQIgAUEHOgCkAkEAIQUMNQsgBUEERw0BIAFBPBClASABQSEQpQEgAUEJOwGkAkEAIQUMNAsgASACELADIQICQCAFRQ0AIAJBgIDEAEYNJgJAIAJBL0cNACABELICIAFBLxClASABQQ06AKQCQQAhBQw1CyABQYUCOwGkAiABQQE6AKcCQQAhBQw0CwJAAkACQCACQS9GDQAgAkGAgMQARg0oIAIQzgMiBUGAgMQARw0BIAFBPBClASABQQE6AKcC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aiICEGQgAUGgAmogA0GIAmooAgA2AgAgAUGYAmogA0GAAmopAwA3AgAgAUGQAmogA0HYAWpBIGopAwA3AgAgAUGIAmogA0HwAWopAwA3AgAgAUGAAmogA0HoAWopAwA3AgAgAUH4AWogA0HgAWopAwA3AgAgASADKQPYATcC8AEgAiAGQSBzIAYgBkG/f2pBGkkbEFkgAUEfOgCkAkEAIQUMIwsgARDSASADQdgBahDmAyABQfABaiICEGQgAUGgAmogA0GIAmooAgA2AgAgAUGYAmogA0GAAmopAwA3AgAgAUGQAmogA0H4AWopAwA3AgAgAUGIAmogA0HwAWopAwA3AgAgAUGAAmogA0HoAWopAwA3AgAgAUH4AWogA0HgAWopAwA3AgAgASADKQPYATcC8AEgAkH9/wMQWSABQR86AKQCQQAhBQwjCyABENIBIANB2AFqEOYDIAFB8AFqEGQgAUGgAmoiAiADQYgCaigCADYCACABQZgCaiADQYACaikDADcCACABQZACaiADQfgBaikDADcCACABQYgCaiADQfABaikDADcCACABQYACaiADQegBaikDADcCACABQfgBaiADQeABaikDADcCACABIAMpA9gBNwLwASACQQE6AAAgARDLASABQQA6AKQCQQAhBQwiCwJAIAEgAhCwAyIFQXdqIgJBF0sNAEEBIAJ0QYuAgARxRQ0AIAZBHjoAAEEAIQUMIgsgBUGAgMQARg0ZIAEQ0gEgAUEeOgCkAiABQQE6AKcCQQAhBQwhCwJAAkACQAJAAkAgASACELADIgJBU2oOEgIBAQEBAQEBAQEBAQEBAQEBAwALIAJFDQMgAkGAgMQARg0cCyABQagBaiIEQaS8wABBAxAcQQAhBSADQQA2AtgBIANBsAFqIAIgA0HYAWoQ1QEgBCADKAKwASADKAK0ARAcIAFBGToApAIMIgsgAUGoAWpBpLzAAEEDEBwgAUEaOgCkAkEAIQUMIgsgASkCqAEhECABQQ82AqgBIANB5AFqIAFBsAFqKAIANgIAIAFBrAFqQgA3AgAgA0ECNgLYASADIBA3AtwBIAEgA0HYAWoQ5wEgAUEAOgCkAkEAIQUMIQsgARDSASABQagBakGnvMAAQQYQHCABQRk6AKQCQQAhBQwgCyABQagBaiEKIAFB7AFqIQgDQAJAAkAgAS0ApwINACACEKQBIgVBgIDEAEYNGiABIAUgAhB5IQcMAQsgAUEAOgCnAiABKALsASEHCwJAIAdBLUYNAAJAAkACQAJAIAdBPUoNACAHRQ0DIAdBIUcNASABENIBIAFBHDoApAJBACEFDCULIAdBPkYNAUEBIQUgB0GAgMQARg0kCyABENIBIApBrbzAAEECEBxBACEFIANBADYC2AEgA0GoAWogByADQdgBahDVASAKIAMoAqgBIAMoAqwBEBwgAUEZOgCkAgwiCyADQeQBaiAKQQhqKAIANgIAIAopAgAhECABQawBakIANwIAIAFBDzYCqAEgA0ECNgLYASADIBA3AtwBIAEgA0HYAWoQ5wEgAUEAOgCkAkEAIQUMIgsgARDSASAKQa+8wABBBRAcIAFBGToApAJBACEFDCELAkACQCABLQDmAQ0AQQAhBUHAtsAAIQRBDSEHDAELIANBAjYC5AEgA0GwtsAANgLgASADQQI2AuwBIANBADYC2AEgA0EYNgK8AiADIAY2ArgCIANBFzYCtAIgAyAINgKwAiADIANBsAJqNgLoASADQcgBaiADQdgBahBiIAMoAsgBIQQgAygCzAEhByADKALQASEJQQEhBQsgAyAJNgLoASADIAc2AuQBIAMgBDYC4AEgAyAFNgLcASADQQY2AtgBIAEgA0HYAWoQ5wEgA0EtNgLYASAKIANB2AFqQQEQHAwACwsCQCABIAIQsAMiAkUNAAJAIAJBLUYNACACQYCAxABGDRggA0EtNgLYASABQagBaiIFIANB2AFqQQEQHCADQQA2AtgBIANBoAFqIAIgA0HYAWoQ1QEgBSADKAKgASADKAKkARAcIAFBGToApAJBACEFDCALIAZBGzoAAEEAIQUMHwsgARDSASABQagBakG0vMAAQQQQHCABQRk6AKQCQQAhBQweCyABQagBaiEEIAFB7AFqIQgDQAJAAkAgAS0ApwINACACEKQBIgVBgIDEAEYNGCABIAUgAhB5IQUMAQsgAUEAOgCnAiABKALsASEFCwJAIAVFDQACQCAFQS1GDQAgBUGAgMQARg0YIANBADYC2AECQAJAIAVBgAFJDQACQCAFQYAQSQ0AAkAgBUGAgARJDQAgAyAFQT9xQYABcjoA2wEgAyAFQRJ2QfABcjoA2AEgAyAFQQZ2QT9xQYABcjoA2gEgAyAF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AEIAIRAMAQsgCEF/akH/////AHEiAEEBaiICQQdxIQMCQAJAIABBB08NAEIAIRAgBSEADAELIAVB+ABqIQAgAkH4////AXEhAkIAIRADQCAAKQMAIABBcGopAwAgAEFgaikDACAAQVBqKQMAIABBQGopAwAgAEGwf2opAwAgAEGgf2opAwAgAEGQf2opAwAgEHx8fHx8fHx8IRAgAEGAAWohACACQXhqIgINAAsgAEGIf2ohAAsgA0UNACAAQQhqIQADQCAAKQMAIBB8IRAgAEEQaiEAIANBf2oiAw0ACwsgASAQNwOAAiABQbgCakEMakEBNgIAIAFBuAJqQRRqQQA2AgAgAUHstMAANgLAAiABQcyxwAA2AsgCIAFBADYCuAIgAUG4AmoQqAEgAUG4AWpBDGoiAEECNgIAIAFBuAFqQRRqIgNBATYCACABQRo2AqQCIAEgBDYCoAIgAUGUtcAANgLAASABQQE2ArwBIAFBAzoA1AIgAUKAgICAgAQ3AswCIAFCgICAgMABNwLEAiABQoCAgIAgNwO4AiABIAFBoAJqNgLIASABIAFBuAJqNgK4ASABQbgBahCoASAAQQI2AgAgA0EBNgIAIAFBGjYCpAIgAUHAtcAANgLAASABQQE2ArwBIAEgAUGAAmo2AqACIAFBAzoA1AIgAUKAgICAgAQ3AswCIAFCgICAgMABNwLEAiABQoCAgIAgNwO4AiABIAFBoAJqNgLIASABIAFBuAJqNgK4ASABQbgBahCoASABKALwASEKAkAgCEUNACAFIAhBBHRqIQggBSEAA0AgAC0AACIDQStGDQEgAC0AASECIAEgACkDCCIQNwOQAiABIAI6AIkCIAEgAzoAiAIgASAQukQAAAAAAABZQKIgASkDgAK6ozkDmAIgAUEYNgLMASABQRs2AsQBIAFBGjYCvAEgASABQYgCajYCyAEgASABQZgCajYCwAEgASABQZACajYCuAEgAUEDOgCUAyABQoCAgICABDcCjAMgAUECNgKEAyABQoKAgIAgNwP4AiABQQM6APQCIAFBIDYC8AIgAUIENwPoAiABQgE3A+ACIAFCATcD2AIgAUEDOgDUAiABQoCAgICABDcCzAIgAUKAgICAwAE3AsQCIAFCgICAgCA3A7gCIAFBBDYCrAIgAUHYtcAANgKoAiABQQM2ArQCIAFB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IgMkAAJAAkACQAJAIAFBOGooAgAiBEUNACABQTRqKAIAIgVFDQAgBEECdCAFakF8aigCACIEQRhqLQAAQQRHDQECQAJAAkAgBEEoaiAEQTBqEP4CDQAgAUHdAGotAAANAUEAIQVBqKfAACEGQR4hBwwCCyABQShqKAIADQQgAEGDEjsBACABIAEtAGM6AGIgACACKQMANwMIIABBEGogAkEIaikDADcDACAAQRhqIAJBEGopAwA3AwAMBQsgAyACNgI8IANBzABqIgVBATYCACADQdQAaiIGQQE2AgAgA0HMhsAANgJIIANBADYCQCADQQ82AhQgAyADQRBqNgJQIAMgA0E8ajYCECADQSBqIANBwABqEGIgA0GDgMQANgJYIANBg4DEADYCTCADIAMoAiQiBDYCRCADIAQgAygCKGo2AkAgA0EQaiADQcAAahBvAkAgAygCICIHRQ0AIAQgB0EBEJQECyAFQQI2AgAgBkEBNgIAIANBEDYCDCADQZinwAA2AkggA0EANgJAIAMgA0EQajYCCCADIANBCGo2AlAgA0EgaiADQcAAahBiAkAgAygCECIERQ0AIAMoAhQgBEEBEJQECyADKAIgIQYgAygCJCEHIAMoAighCEEBIQULAkAgAUHUAGooAgAiBCABQcwAaiIJKAIARw0AIAkgBBDfASABKAJUIQQLIAFB0ABqKAIAIARBBHRqIgQgCDYCDCAEIAc2AgggBCAGNgIEIAQgBTYCACABIAEoAlRBAWo2AlQgA0EgakEQaiACQRBqKQMANwMAIANBIGpBCGogAkEIaikDADcDACADIAIpAwA3AyACQEEAKALIjlJBAkkNACADQcwAakEBNgIAIANB1ABqQQA2AgAgA0GYpcAANgJIIANBxJfAADYCUCADQQA2AkAgA0HAAGpBAkGgpcAAEIsCCyABQQE6AGcgACABQQYgA0EgahABIAFBADoAZwwDC0GsmcAAQRJBoJ3AABDuAgALQYSMwABBD0GUjMAAEMwDAAtBs6bAAEE0QeimwAAQjQMACyADQeAAaiQAC8EFAgZ/AX4jAEEgayICJAAgAUEobCEBIABBcGohA0EAIQQCQANAIAFFDQEgAiAAQRBqNgIEIAIgAEEIajYCACACQoKAgIAQNwMQIAJCgoCAgJA+NwMYIAIgAkEYajYCDCACIAJBEGo2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QQA6AAAgASABKAJUQQFqNgJUIANB0ABqJAAL0gMBBn8jAEHQAGsiAyQAAkACQCABQd0Aai0AAA0AQQAhBEHMnMAAIQVBECEGDAELIAMgAjYCHCADQTBqQQxqIgRBATYCACADQcQAaiIFQQE2AgAgA0HMhsAANgI4IANBADYCMCADQRE2AgQgAyADNgJAIAMgA0EcajYCACADQSBqIANBMGoQYiADQYOAxAA2AkggA0GDgMQANgI8IAMgAygCJCICNgI0IAMgAiADKAIoajYCMCADQRBqIANBMGoQbgJAIAMoAiAiBkUNACACIAZBARCUBAsgA0EMakEONgIAIARBAjYCACAFQQI2AgAgA0EQNgIEIANBvJzAADYCOCADQQA2AjAgAyABQeMAajYCCCADIANBEGo2AgAgAyADNgJAIANBIGogA0EwahBiAkAgAygCECICRQ0AIAMoAhQgAkEBEJQECyADKAIgIQUgAygCJCEGIAMoAighB0EBIQQLAkAgAUHUAGooAgAiAiABQcwAaiIIKAIARw0AIAggAhDfASABKAJUIQILIAFB0ABqKAIAIAJBBHRqIgIgBzYCDCACIAY2AgggAiAFNgIEIAIgBDYCACAAQQA6AAAgASABKAJUQQFqNgJUIANB0ABqJAALwAMBB38jAEHAAGsiAiQAIAIgATcDCAJAIAFCA4NQRQ0AIAGnIgMgAygCDEEBajYCDCACKQMIIQELAkAgACABEJoBQQFGDQACQAJAIABB3QBqLQAADQBBACEEQbCkwAAhBUEXIQYMAQtBASEEIAJBLGpBATYCACACQTRqQQE2AgAgAkGopMAANgIoIAJBADYCICACQRU2AjwgAiACQThqNgIwIAIgAkEIajYCOCACQRBqIAJBIGoQYiACKAIQIQUgAigCFCEGIAIoAhghBwsCQCAAQdQAaigCACIDIABBzABqIggoAgBHDQAgCCADEN8BIAAoAlQhAwsgAEHQAGooAgAgA0EEdGoiAyAHNgIMIAMgBjYCCCADIAU2AgQgAyAENgIAIAAgACgCVEEBajYCVCACKQMIIQELAkAgAUIDg0IAUg0AIAGnIgAgACgCDCIAQX9qNgIMIABBAUcNAEHMsNEAEIwDIgAgAC0AACIDQQEgAxs6AAACQCADRQ0AIAAgAUGAlOvcAxAbGgsgAEEEaiACKAII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NgJYIAIgAikDODcDUCACQTBqIAAgARACIAIoAjQhBCACKAIwIQUgAkEgaiACQdAAahCfAyACKQMgQoCU69wDfiACNQIofCAHIAApAwh9fCEHAkACQCAAKALEASIGRQ0AIAJB0ABqIAMoAgAgBiACQcgAahA6IAIoAlANACACKAJYIgZFDQAgBiACKAJcQQN0aiIGIAYpAwAgB3w3AwAMAQsgAkEQaiADIAItAEggAi0ASSAHEIABCyAFRQ0ACyAFQX9qDgIBAgELA0AgAkEIaiAAIAEQAiACKAIIIgVFDQALAkAgBUF/ag4CAQABCyACKAIMIQQMAQtBACEECyACQeAAaiQAIAQL0gICA38BfiMAQTBrIgIkAAJAAkACQAJAAkAgACgCACkDACIFpyIDQQNxDgMCAAECCyADQQR2QQ9xIgNBCEkNAyADQQdB3KzRABCkBAALAkAgBUIgiKciA0EHSw0AIANBA3RB/NPCAGohAwwCCyADQQhBzKzRABDLAgALIANBBGohAwsgAygCACEDCyAAQQRqIQQCQAJAIAMNACACQRRqQQE2AgAgAkEcakEBNgIAIAJBgK3RADYCECACQQA2AgggAkHeADYCJCACIAQ2AiAgAiACQSBqNgIYIAEgAkEIahDoAiEADAELIAJBIGpBDGpB3gA2AgAgAkEIakEMakECNgIAIAJBHGpBAjYCACACQfCs0QA2AhAgAkEANgIIIAIgBDYCKCACQeIANgIkIAIgADYCICACIAJBIGo2AhggASACQQhqEOgCIQALIAJBMGokACAAC+cCAgV/An4jAEHAAGsiAyQAAkACQCAALQAIRQ0AIAAoAgAhBEEBIQUMAQsgACgCACEEAkAgAEEEaigCACIGKAIYIgdBBHENAEEBIQUgBigCAEG179EAQb/v0QAgBBtBAkEBIAQbIAYoAgQoAgwRCgANASABIAYgAigCDBEHACEFDAELAkAgBA0AAkAgBigCAEG979EAQQIgBigCBCgCDBEKAEUNAEEBIQVBACEEDAILIAYoAhghBwtBASEFIANBAToAFyADQZTv0QA2AhwgAyAGKQIANwMIIAMgA0EXajYCECAGKQIIIQggBikCECEJIAMgBi0AIDoAOCADIAYoAhw2AjQgAyAHNgIwIAMgCTcDKCADIAg3AyAgAyADQQhqNgIYIAEgA0EY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IAJqIgIgAUkNACAAKAIAIgFBAXQiBCACIAQgAksbIgJBCCACQQhLGyICQX9zQR92IQQCQAJAIAFFDQAgA0EBNgIYIAMgATYCFCADIABBBGooAgA2AhAMAQsgA0EANgIYCyADIAIgBCADQRBqEJQCIAMoAgQhAQJAIAMoAgANACAAIAI2AgAgACABNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAEgABC8BAALEKADAAsgA0EgaiQAC9ABAQJ/IwBBIGsiAyQAAkACQCABIAJqIgIgAUkNACAAKAIAIgFBAXQiBCACIAQgAksbIgJBCCACQQhLGyICQX9zQR92IQQCQAJAIAFFDQAgA0EBNgIYIAMgATYCFCADIABBBGooAgA2AhAMAQsgA0EANgIYCyADIAIgBCADQRBqEJgCIAMoAgQhAQJAIAMoAgANACAAIAI2AgAgACABNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAEgABC8BAALEKADAAsgA0EgaiQAC9ABAQJ/IwBBIGsiAyQAAkACQCABIAJqIgIgAUkNACAAKAIAIgFBAXQiBCACIAQgAksbIgJBCCACQQhLGyICQX9zQR92IQQCQAJAIAFFDQAgA0EBNgIYIAMgATYCFCADIABBBGooAgA2AhAMAQsgA0EANgIYCyADIAIgBCADQRBqEP4BIAMoAgQhAQJAIAMoAgANACAAIAI2AgAgACABNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAEgABC8BAALEKADAAsgA0EgaiQAC+cBAQF/IwBBEGsiEyQAIAAoAgAgASACIAAoAgQoAgwRCgAhAiATQQA6AA0gEyACOgAMIBMgADYCCCATQQhqIAMgBCAFIAYQjgEgByAIIAkgChCOASALIAwgDSAOEI4BIA8gECARIBIQjgEhASATLQAMIQICQAJAIBMtAA0NACACQf8BcUEARyEADAELQQEhACACQf8BcQ0AAkAgASgCACIALQAYQQRxDQAgACgCAEG779EAQQIgACgCBCgCDBEKACEADAELIAAoAgBBuu/RAEEBIAAoAgQoAgwRCgAhAAsgE0EQaiQAIAALzgEBA38jAEEgayICJAACQAJAIAFBAWoiAUUNACAAKAIAIgNBAXQiBCABIAQgAUsbIgFBCCABQQhL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fHEiAmohAwJAIAJBAUgNACABQf8BcUGBgoQIbCECA0AgBSACNgIAIAVBBGoiBSADSQ0ACwsgBEEDcSECCwJAIAJFDQAgAyACaiEFA0AgAyABOgAAIANBAWoiAyAFSQ0ACwsgAAvTAQECfyMAQcAAayICJAACQAJAAkACQAJAIAAoAgBBA3EOAwABAgALIAJBg5jAADYCCEEHIQMMAwsgAkH9l8AANgIIDAELIAJB95fAADYCCAtBBiEDCyACIAM2AgwgAkEQakEMakEDNgIAIAJBJGpBAjYCACACQShqQQxqQRI2AgAgAkGYmMAANgIYIAJBADYCECACQRM2AiwgAiAANgI8IAIgAkEoajYCICACIAJBCGo2AjAgAiACQTxqNgIoIAEgAkEQahDoAiEAIAJBwABqJAAgAAvVAQECfyMAQcAAayICJAACQAJAAkACQAJAIAAoAgBBA3EOAwABAgALIAJBnIDBADYCCEEHIQMMAwsgAkGWgMEANgIIDAELIAJBkIDBADYCCAtBBiEDCyACIAM2AgwgAkEQakEMakEDNgIAIAJBJGpBAjYCACACQShqQQxqQcAANgIAIAJBtIDBADYCGCACQQA2AhAgAkHEADYCLCACIAA2AjwgAiACQShqNgIgIAIgAkEIajYCMCACIAJBPGo2AiggASACQRBqEOgCIQAgAkHAAGokACAAC9YBAgV/A34jAEHQAGsiAyQAQQAoAriOUiEEQQAoArSOUiEFQQAoAsSOUiEGIAIpAgAhCCACKAIYIQcgAikCCCEJIAIpAhAhCiADQTBqIAE2AgAgA0HEAGogCjcCACADQThqIAk3AwAgA0EkaiAHNgIAIAMgCDcDKCADQQA2AkAgA0EANgI0IANBATYCICADIAApAhA3AxggAyAAKQIINwMQIAMgACkCADcDCCAFQfCRwQAgBkECRiICGyADQQhqIARB/JHBACACGygCFBEGACADQdAAaiQAC9UBAQJ/IwBBwABrIgIkAAJAAkACQAJAAkAgACgCAEEDcQ4DAAECAAsgAkG8q9EANgIIQQchAwwDCyACQbar0QA2AggMAQsgAkGwq9EANgIIC0EGIQMLIAIgAzYCDCACQRBqQQxqQQM2AgAgAkEkakECNgIAIAJBKGpBDGpB3QA2AgAgAkHUq9EANgIYIAJBADYCECACQeIANgIsIAIgADYCPCACIAJBKGo2AiAgAiACQQhqNgIwIAIgAkE8ajYCKCABIAJBEGoQ6AIhACACQcAAaiQAIAAL2gEBA39BgIDEACEBAkACQAJAAkACQCAAKAIEIgJBgIC8f2oiA0EDIANBA0kbDgQDAAECAwsgAEGAgMQANgIEIAAoAgAPCyAAQYGAxAA2AgRB3AAPCwJAAkACQAJAAkAgAC0ACA4GBQAEAQIDBQsgAEEAOgAIQf0ADwsgAEECOgAIQfsADwsgAEEDOgAIQfUADwsgAEEEOgAIQdwADwtBMEHXACACIAAoAgAiA0ECdHZBD3EiAUEKSRsgAWohASADRQ0BIAAgA0F/ajYCAAsgAQ8LIABBAToACCABC9EBAQF/IwBBEGsiCyQAIAAoAgAgASACIAAoAgQoAgwRCgAhAiALQQA6AA0gCyACOgAMIAsgADYCCCALQQhqIAMgBCAFIAYQjgEgByAIIAkgChCOASEBIAstAAwhAgJAAkAgCy0ADQ0AIAJB/wFxQQBHIQAMAQtBASEAIAJB/wFxDQACQCABKAIAIgAtABhBBHENACAAKAIAQbvv0QBBAiAAKAIEKAIMEQoAIQAMAQsgACgCAEG679EAQQEgACgCBCgCDBEKACEACyALQRBqJAAgAAvAAQEDfyMAQSBrIgIkACACQoKAgICg5gA3AxggAkKCgICA8AA3AxAgAkIANwMIIABByABqIgMgAkEIaiABEBoiASABKAIAQQFqIgQ2AgACQCAERQ0AAkAgAEE4aigCACIEIAAoAjBHDQAgAEEwaiAEEN4BIAAoAjghBAsgAEE0aigCACAEQQJ0aiABNgIAIAAgACgCOEEBajYCOCACQQA2AgggAiABNgIMIAMgAEEsaiACQQhqEF0gAkEgaiQADwsAC8sBAQF/IwBBIGsiBSQAAkACQCABIAN8IgMgAVQNACAEIAJqIgRB/5Pr3ANNDQEgA0IBfCIDUA0AIARBgOyUo3xqIQQMAQtBzPnRAEEeQez50QAQ7gIACwJAIAMgBEGAlOvcA24iAq18IgEgA1oNACAFQRRqQQE2AgAgBUEcakEANgIAIAVBnPnRADYCECAFQaDs0QA2AhggBUEANgIIIAVBCGpBvPnRABCyAwALIAAgATcDACAAIAQgAkGAlOvcA2xrNgIIIAVBIGokAAvAAQEBfyMAQRBrIgMkAAJAAkACQAJAIAEoAgAOAwABAgALIAMgASgCBDYCDCAAQcgAaiADQQxqIAIQXSADQQxqEPsBDAILIAMgASgCBDYCDCAAQcgAaiADQQxqIAIQKSADQQxqEPsBDAELIAMgASgCBCIANgIIIAMgASgCCDYCDAJAAkAgAEHIAGooAgANACADIANBDGogAhBdDAELIAMgA0EIaiACECkLIANBDGoQ+wEgA0EIahD7AQsgA0EQaiQAC7YBAQR/IwBBEGsiASQAAkACQCAAQThqKAIAIgJFDQAgAEE0aigCACIDRQ0AIAJBf2ohBCACQQJ0IANqQXxqIQIDQCACKAIAIgNBGGotAABBBEcNAiADQShqIANBMGoQnQJFDQEgACAENgI4IAEgAigCADYCDCACQXxqIQIgAUEMahD7ASAEQX9qIgRBf0cNAAsLIABCgoCAgKDYABB3IAFBEGokAA8LQYSMwABBD0GUjMAAEMwDAAu9AQEBfwJAAkAgAkUNAAJAAkACQAJAAkAgAUF/TA0AIAMoAghFDQIgAygCBCIEDQEgAQ0DIAIhAwwECyAAQQhqQQA2AgAMBQsgAygCACAEIAIgARD1AyEDDAILIAENACACIQMMAQsgASACEP4DIQMLAkAgA0UNACAAIAM2AgQgAEEIaiABNgIAIABBADYCAA8LIAAgATYCBCAAQQhqIAI2AgAMAQsgACABNgIEIABBCGpBADYCAAsgAEEBNgIAC70BAQF/AkACQCACRQ0AAkACQAJAAkACQCABQX9MDQAgAygCCEUNAiADKAIEIgQNASABDQMgAiEDDAQLIABBCGpBADYCAAwFCyADKAIAIAQgAiABEPUDIQMMAgsgAQ0AIAIhAwwBCyABIAIQ/gMhAwsCQCADRQ0AIAAgAzYCBCAAQQhqIAE2AgAgAEEANgIADwsgACABNgIEIABBCGogAjYCAAwBCyAAIAE2AgQgAEEIakEANgIACyAAQQE2AgALvQEBAX8CQAJAIAJFDQACQAJAAkACQAJAIAFBf0wNACADKAIIRQ0CIAMoAgQiBA0BIAENAyACIQMMBAsgAEEIakEANgIADAULIAMoAgAgBCACIAEQ9QMhAwwCCyABDQAgAiEDDAELIAEgAhD+AyEDCwJAIANFDQAgACADNgIEIABBCGogATYCACAAQQA2AgAPCyAAIAE2AgQgAEEIaiACNgIADAELIAAgATYCBCAAQQhqQQA2AgALIABBATYCAAu9AQEBfwJAAkAgAkUNAAJAAkACQAJAAkAgAUF/TA0AIAMoAghFDQIgAygCBCIEDQEgAQ0DIAIhAwwECyAAQQhqQQA2AgAMBQsgAygCACAEIAIgARD1AyEDDAILIAENACACIQMMAQsgASACEP4DIQMLAkAgA0UNACAAIAM2AgQgAEEIaiABNgIAIABBADYCAA8LIAAgATYCBCAAQQhqIAI2AgAMAQsgACABNgIEIABBCGpBADYCAAsgAEEBNgIAC70BAQF/AkACQCACRQ0AAkACQAJAAkACQCABQX9MDQAgAygCCEUNAiADKAIEIgQNASABDQMgAiEDDAQLIABBCGpBADYCAAwFCyADKAIAIAQgAiABEPUDIQMMAgsgAQ0AIAIhAwwBCyABIAIQ/gMhAwsCQCADRQ0AIAAgAzYCBCAAQQhqIAE2AgAgAEEANgIADwsgACABNgIEIABBCGogAjYCAAwBCyAAIAE2AgQgAEEIakEANgIACyAAQQE2AgALvQEBAX8CQAJAIAJFDQACQAJAAkACQAJAIAFBf0wNACADKAIIRQ0CIAMoAgQiBA0BIAENAyACIQMMBAsgAEEIakEANgIADAULIAMoAgAgBCACIAEQ9QMhAwwCCyABDQAgAiEDDAELIAEgAhD+AyEDCwJAIANFDQAgACADNgIEIABBCGogATYCACAAQQA2AgAPCyAAIAE2AgQgAEEIaiACNgIADAELIAAgATYCBCAAQQhqQQA2AgALIABBATYCAAvUAQECfyMAQRBrIgIkAAJAAkACQAJAAkACQCAALQAUQX5qQf8BcSIDQQFqQQAgA0EESRsOBQABAgMEAAsgAiAANgIEIAFBiJDBAEEIIAJBBGpBkJDBABD9ASEADAQLIAIgADYCCCABQfyPwQBBDCACQQhqQeyPwQAQ/QEhAAwDCyACIAA2AgwgAUHKj8EAQQ8gAEEMakHcj8EAIAJBDGpB7I/BABD0ASEADAILIAFBuI/BAEESEPoDIQAMAQsgAUGwj8EAQQgQ+gMhAAsgAkEQaiQAIAALqgEBBH8jAEEQayIBJAACQAJAIABBOGooAgAiAkUNACAAQTRqKAIAIgNFDQAgAkF/aiEEIAJBAnQgA2pBfGohAgNAIAIoAgAiA0EYai0AAEEERw0CIANBKGogA0EwahC8AUUNASAAIAQ2AjggASACKAIANgIMIAJBfGohAiABQQxqEPsBIARBf2oiBEF/Rw0ACwsgAUEQaiQADwtBhIzAAEEPQZSMwAAQzAMAC6oBAQR/IwBBEGsiASQAAkACQCAAQThqKAIAIgJFDQAgAEE0aigCACIDRQ0AIAJBf2ohBCACQQJ0IANqQXxqIQIDQCACKAIAIgNBGGotAABBBEcNAiADQShqIANBMGoQtAJFDQEgACAENgI4IAEgAigCADYCDCACQXxqIQIgAUEMahD7ASAEQX9qIgRBf0cNAAsLIAFBEGokAA8LQYSMwABBD0GUjMAAEMwDAAuuAQIDfwF+IwBBEGsiAiQAIAIgACkDACIFQgBSNgIIIAEgAkEIahBmAkAgBVANAAJAAkACQAJAAkAgBaciAEEDcQ4DAgABAgsgBUIgiCAFhachAAwDCxDaBCIDQRxqKAIAIgQgBUIgiKciAEsNASAAIARBnJXAABDLAgALIAAoAgghAAwBCyADKAIYIABBAnRqKAIAIQALIAIgADYCDCABIAJBDGoQZgsgAkEQaiQAC/gBAgF/An5BACECAkAgACkDACIDQoKAgIDwAFEgASkDACIEQoKAgICg2ABRcQ0AIANCgoCAgPAAUg0AAkACQCAEQoGAgICg2ABVDQACQCAEQoGAgIDgPFUNACAEQoKAgICgBFENAiAEQoKAgIDQFFENAgwDCyAEQoKAgIDgPFENASAEQoKAgIDQyABRDQEgBEKCgICA0NUAUQ0BDAILAkAgBEKBgICAgOwAVQ0AIARCgoCAgKDYAFENASAEQoKAgIDw2QBRDQEMAgsgBEKCgICAgOwAUQ0AIARCgoCAgMDuAFENACAEQoKAgICg9ABSDQELQQEhAgsgAgukAQEEfyMAQRBrIgEkAAJAAkAgAEE4aigCACICRQ0AIAJBAnQgAEE0aigCAGpBfGohAyACQX9qIQIDQCAAIAIiBDYCOCABIAMoAgAiAjYCDCACQRhqLQAAQQRHDQIgAkEoaiACQTBqEPECIQIgAUEMahD7ASACDQEgA0F8aiEDIARBf2ohAiAEDQALCyABQRBqJAAPC0GEjMAAQQ9BlIzAABDMAwALswEBAX8jAEEgayIDJAAgA0ELaiACQQhqKAAANgAAIAMgAikAADcAAwJAQdAAQQgQ/gMiAg0AQdAAQQgQvAQACyACQQM6ABggAkIENwMQIAJCADcDCCACQoGAgIAQNwMAIAIgAykAADcAGSACQQA2AkggAkEgaiADQQdqKQAANwAAIANBADYCACADIAI2AgQgA0EQaiABQQAQOyABIANBEGogAxCRAiAAQQA6AAAgA0EgaiQAC5gBAQV/IAAgACgCACIBEOABAkAgACgCCCICIAEgACgCDCIDa00NACAAKAIAIQQCQAJAIAEgAmsiBSADIAVrIgNNDQAgBCABayADTw0BCyAAQQRqKAIAIgEgBCAFayIDQRhsaiABIAJBGGxqIAVBGGwQwQQaIAAgAzYCCA8LIABBBGooAgAiACABQRhsaiAAIANBGGwQxAQaCwuYAQEFfyAAIAAoAgAiARDjAQJAIAAoAggiAiABIAAoAgwiA2tNDQAgACgCACEEAkACQCABIAJrIgUgAyAFayIDTQ0AIAQgAWsgA08NAQsgAEEEaigCACIBIAQgBWsiA0EMbGogASACQQxsaiAFQQxsEMEEGiAAIAM2AggPCyAAQQRqKAIAIgAgAUEMbGogACADQQxsEMQEGgsLnAEBBX8jAEEQayIBJABBACECAkADQCAAKAIAIQMDQAJAIANBAXFFDQAgA0EDSw0DIAJBCk8NAyACQQNJIQMgAkEBaiIEIQIgAw0CEIcFIAQhAgwCCyAAIANBAXIgACgCACIEIAQgA0YbNgIAIAQgA0chBSAEIQMgBQ0ACwsgAUEQaiQADwsgAUIANwMIIAFCATcDACABQQRyEJYEAAufAQECfwJAIAAoAggiAyAAKAIARw0AIAAgA0EBENkBCyAAKAIEIAFBBXRqIQQCQAJAIAMgAUsNACADIAFGDQEgASADEMkCAAsgBEEgaiAEIAMgAWtBBXQQwQQaCyAEIAIpAwA3AwAgACADQQFqNgIIIARBGGogAkEYaikDADcDACAEQRBqIAJBEGopAwA3AwAgBEEIaiACQQhqKQMANwMAC5UBAQd/IwBBEGsiAiQAIABBNGooAgAgAEE4aigCACIDQQJ0IgRqIQVBACEGQQAgBGshByADIQQCQANAIAcgBkYNASAEQX9qIQQgBkF8aiIGIAVqIggoAgAgAUcNAAsgCCgCACEEIAggCEEEakF8IAZrEMEEGiAAIANBf2o2AjggAiAENgIMIAJBDGoQ+wELIAJBEGokAAuqAQECfwJAIAAoAgBFDQAgACgCBCIBQRBJDQAgAUF+cSECAkACQCABQQFxDQAgAEEMaigCACIBQQhqIgAgAU8NAUEAKAKgtlFBACgCpLZRQaiBwQAQ7gIACyACIAIoAQAiAEF/ajYBACAAQQFHDQEgAigCBCIBQQhqIgAgAU8NAEEAKAKgtlFBACgCpLZRQaiBwQAQ7gIACyACIABBf2pBeHFBCGpBBBCUBAsLqwEBAX8jAEEQayIDJAAgA0ELaiACQQhqKAAANgAAIAMgAikAADcAAwJAQdAAQQgQ/gMiAg0AQdAAQQgQvAQACyACQQM6ABggAkIENwMQIAJCADcDCCACQoGAgIAQNwMAIAIgAykAADcAGSACQQA2AkggAkEgaiADQQdqKQAANwAAIANBADYCACADIAI2AgQgAUHIAGogAUEsaiADEF0gAEEAOgAAIANBEGokAAuuAQEDfyAALQAIIQECQCAAKAIAIgINACABQf8BcUEARw8LQQEhAwJAAkAgAUH/AXENAAJAAkAgAkEBRw0AIAAtAAlB/wFxDQELIAAoAgQhAQwCCyAAQQRqKAIAIgEtABhBBHENAUEBIQMgASgCAEHA79EAQQEgASgCBCgCDBEKAEUNAQsgACADOgAIIAMPCyAAIAEoAgBB3OzRAEEBIAEoAgQoAgwRCgAiAToACCABC5sBAQN/IwBBgAFrIgIkACAALQAAIQNBACEAA0AgAiAAakH/AGpBMEE3IANBD3EiBEEKSRsgBGo6AAAgAEF/aiEAIANB/wFxIgRBBHYhAyAEQQ9LDQALAkAgAEGAAWoiA0GBAUkNACADQYABQfDv0QAQowQACyABQQFBgPDRAEECIAIgAGpBgAFqQQAgAGsQOSEAIAJBgAFqJAAgAAucAQEDfyMAQYABayICJAAgAC0AACEDQQAhAANAIAIgAGpB/wBqQTBB1wAgA0EPcSIEQQpJGyAEajoAACAAQX9qIQAgA0H/AXEiBEEEdiEDIARBD0sNAAsCQCAAQYABaiIDQYEBSQ0AIANBgAFB8O/RABCjBAALIAFBAUGA8NEAQQIgAiAAakGAAWpBACAAaxA5IQAgAkGAAWokACAAC6YBAgJ/AX4CQAJAAkACQCAAKAIAIgIpAwAiBKciAEEDcQ4DAgABAgsgAEEEdkEPcSIAQQhPDQIgAkEBaiAAIAEQvgQPCwJAENkEIgJBFGooAgAiAyAEQiCIpyIATQ0AIAIoAhAgAEEDdGoiACgCACAAKAIEIAEQvgQPCyAAIANBxJXAABDLAgALIAAoAgAgACgCBCABEL4EDwsgAEEHQdSVwAAQpAQAC6YBAQJ/AkACQCAAKAIAIgFBEEkNACABQX5xIQICQAJAIAFBAXENACAAQQhqKAIAIgFBCGoiACABTw0BQQAoAqC2UUEAKAKktlFBnJnAABDuAgALIAIgAigBACIAQX9qNgEAIABBAUcNASACKAIEIgFBCGoiACABSQ0CCyACIABBf2pBeHFBCGpBBBCUBAsPC0EAKAKgtlFBACgCpLZRQZyZwAAQ7gIAC6YBAQJ/AkACQCAAKAIAIgFBEEkNACABQX5xIQICQAJAIAFBAXENACAAQQhqKAIAIgFBCGoiACABTw0BQQAoAqC2UUEAKAKktlFB8MrAABDuAgALIAIgAigBACIAQX9qNgEAIABBAUcNASACKAIEIgFBCGoiACABSQ0CCyACIABBf2pBeHFBCGpBBBCUBAsPC0EAKAKgtlFBACgCpLZRQfDKwAAQ7gIAC6YBAQJ/AkACQCAAKAIAIgFBEEkNACABQX5xIQICQAJAIAFBAXENACAAQQhqKAIAIgFBCGoiACABTw0BQQAoAqC2UUEAKAKktlFB+NbAABDuAgALIAIgAigBACIAQX9qNgEAIABBAUcNASACKAIEIgFBCGoiACABSQ0CCyACIABBf2pBeHFBCGpBBBCUBAsPC0EAKAKgtlFBACgCpLZRQfjWwAAQ7gIAC6YBAgJ/AX4CQAJAAkACQCAAKAIAIgIpAwAiBKciAEEDcQ4DAgABAgsgAEEEdkEPcSIAQQhPDQIgAkEBaiAAIAEQvgQPCwJAENkEIgJBFGooAgAiAyAEQiCIpyIATQ0AIAIoAhAgAEEDdGoiACgCACAAKAIEIAEQvgQPCyAAIANB2IrBABDLAgALIAAoAgAgACgCBCABEL4EDwsgAEEHQeiKwQAQpAQAC7cBAQN/IwBBEGsiASQAIAAoAgAiAkEUaigCACEDAkACQAJAAkAgAkEMaigCAA4CAAEDCyADDQJB8LbRACECQQAhAwwBCyADDQEgAigCCCICKAIEIQMgAigCACECCyABIAM2AgQgASACNgIAIAFBwMPRACAAKAIEIgIQ1AQgACgCCCACENYEEPkBAAsgAUEANgIEIAEgAjYCDCABQazD0QAgACgCBCICENQEIAAoAgggAhDWBBD5AQALmgEBA38jAEGAAWsiAiQAIAAoAgAhAEEAIQMDQCACIANqQf8AakEwQdcAIABBD3EiBEEKSRsgBGo6AAAgA0F/aiEDIABBD0shBCAAQQR2IQAgBA0ACwJAIANBgAFqIgBBgQFJDQAgAEGAAUHw79EAEKMEAAsgAUEBQYDw0QBBAiACIANqQYABakEAIANrEDkhACACQYABaiQAIAALmQEBA38jAEGAAWsiAiQAIAAoAgAhAEEAIQMDQCACIANqQf8AakEwQTcgAEEPcSIEQQpJGyAEajoAACADQX9qIQMgAEEPSyEEIABBBHYhACAEDQALAkAgA0GAAWoiAEGBAUkNACAAQYABQfDv0QAQowQACyABQQFBgPDRAEECIAIgA2pBgAFqQQAgA2sQOSEAIAJBgAFqJAAgAAuiAQEDfwJAAkAgACgCtAEiAUEQSQ0AAkAgAUEBcQ0AIABBuAFqQQA2AgAPCyABQX5xIgEgASgBACICQX9qNgEAAkAgAkEBRw0AIAEoAgQiAkEIaiIDIAJJDQIgASADQX9qQXhxQQhqQQQQlAQLIABBDzYCtAEgAEG4AWpCADcDAA8LIABBDzYCtAEPC0EAKAKgtlFBACgCpLZRQaiywAAQ7gIAC+ABAgF/An5BACECAkAgACkDACIDQoKAgIDwAFEgASkDACIEQoKAgIDwhQFRcQ0AIANCgoCAgPAAUg0AAkACQCAEQoGAgIDw4ABVDQACQCAEQoGAgIDgzQBVDQAgBEKCgICA4AhRDQIgBEKCgICAgDZRDQIMAwsgBEKCgICA4M0AUQ0BIARCgoCAgPDdAFENAQwCCwJAIARCgYCAgPCFAVUNACAEQoKAgIDw4ABRDQEgBEKCgICA0PYAUQ0BDAILIARCgoCAgPCFAVENACAEQoKAgIDwiQFSDQELQQEhAgsgAgveAQIBfwF+QQAhAgJAIAApAwBCgoCAgPAAUg0AAkACQCABKQMAIgNCgYCAgKDYAFUNAAJAIANCgYCAgOA8VQ0AIANCgoCAgKAEUQ0CIANCgoCAgNAUUQ0CDAMLIANCgoCAgOA8UQ0BIANCgoCAgNDIAFENASADQoKAgIDQ1QBRDQEMAgsCQCADQoGAgICA7ABVDQAgA0KCgICAoNgAUQ0BIANCgoCAgPDZAFENAQwCCyADQoKAgICA7ABRDQAgA0KCgICAwO4AUQ0AIANCgoCAgKD0AFINAQtBASECCyACC58BAgN/AX4jAEEQayIDJAAgA0EIaiAAKAIAIgAoAgggASACEFwCQCADLQAIIgJBBEYNACADKQMIIQYCQCAALQAAQQNHDQAgACgCBCIBKAIAIAEoAgQoAgARAwACQCABKAIEIgRBBGooAgAiBUUNACABKAIAIAUgBEEIaigCABCUBAsgAUEMQQQQlAQLIAAgBjcCAAsgA0EQaiQAIAJBBEcLowECAX8BfgJAAkACQAJAIAAoAgAiAikDACIDpyIAQQNxDgMCAAECCyAAQQR2QQ9xIgBBCE8NAiACQQFqIAAgARC+BA8LAkAgA0IgiKciAEHUCEsNACAAQQN0IgBB8OjBAGooAgAgAEH06MEAaigCACABEL4EDwsgAEHVCEH4qtEAEMsCAAsgACgCACAAKAIEIAEQvgQPCyAAQQdBiKvRABCkBAALoQECAX8BfgJAAkACQAJAIAAoAgAiAikDACIDpyIAQQNxDgMCAAECCyAAQQR2QQ9xIgBBCE8NAiACQQFqIAAgARC+BA8LAkAgA0IgiKciAEEHSw0AIABBA3QiAEGs0cIAaigCACAAQbDRwgBqKAIAIAEQvgQPCyAAQQhB+KrRABDLAgALIAAoAgAgACgCBCABEL4EDwsgAEEHQYir0QAQpAQAC6EBAgF/AX4CQAJAAkACQCAAKAIAIgIpAwAiA6ciAEEDcQ4DAgABAgsgAEEEdkEPcSIAQQhPDQIgAkEBaiAAIAEQvgQPCwJAIANCIIinIgBBB0sNACAAQQN0IgBB+NPCAGooAgAgAEH808IAaigCACABEL4EDwsgAEEIQfiq0QAQywIACyAAKAIAIAAoAgQgARC+BA8LIABBB0GIq9EAEKQEAAuXAQEDfwJAAkAgACgCACIBQRBJDQAgAUEBcQ0BIABBADYCBA8LIABBDzYCAA8LIAFBfnEiASABKAEAIgJBf2o2AQACQAJAIAJBAUcNACABKAIEIgJBCGoiAyACSQ0BIAEgA0F/akF4cUEIakEEEJQECyAAQgA3AgQgAEEPNgIADwtBACgCoLZRQQAoAqS2UUGossAAEO4CAAuaAQIDfwF+IwBBEGsiAyQAIANBCGogACgCCCABIAIQXAJAIAMtAAgiAkEERg0AIAMpAwghBgJAIAAtAABBA0cNACAAKAIEIgEoAgAgASgCBCgCABEDAAJAIAEoAgQiBEEEaigCACIFRQ0AIAEoAgAgBSAEQQhqKAIAEJQECyABQQxBBBCUBAsgACAGNwIACyADQRBqJAAgAkEERwueAQEEfwJAAkACQCAAKAIAIgEoAggOAgABAgsgAUEQaigCACICRQ0BIAFBDGooAgAgAkEBEJQEDAELIAFBDGotAABBA0cNACABQRBqKAIAIgIoAgAgAigCBCgCABEDAAJAIAIoAgQiA0EEaigCACIERQ0AIAIoAgAgBCADQQhqKAIAEJQECyABKAIQQQxBBBCUBAsgACgCAEEUQQQQlAQLmQEBAX8CQAJAIABBEEkNACAAQX5xIQICQAJAIABBAXENACABQQhqIgAgAU8NAUEAKAKgtlFBACgCpLZRQezMwAAQ7gIACyACIAIoAQAiAEF/ajYBACAAQQFHDQEgAigCBCIBQQhqIgAgAUkNAgsgAiAAQX9qQXhxQQhqQQQQlAQLDwtBACgCoLZRQQAoAqS2UUHszMAAEO4CAAvRAQIBfwF+QQAhAgJAIAApAwBCgoCAgPAAUg0AAkACQCABKQMAIgNCgYCAgODNAFUNAAJAIANCgYCAgIA3VQ0AIANCgoCAgOAHUQ0CIANCgoCAgPAxUQ0CDAMLIANCgoCAgIA3UQ0BIANCgoCAgMDJAFENAQwCCwJAIANCgYCAgKDmAFUNACADQoKAgIDgzQBRDQEgA0KCgICA0NsAUQ0BDAILIANCgoCAgKDmAFENACADQoKAgIDA9QBRDQAgA0KCgICA4IQBUg0BC0EBIQILIAILkAECAn8BfgJAIAApAwAiA1ANACADQgODUEUNACADpyIBIAEoAgwiAUF/ajYCDCABQQFHDQBBzLDRABCMAyIBIAEtAAAiAkEBIAIbOgAAAkAgAkUNACABIANBgJTr3AMQGxoLIAFBBGogACgCABDQAiABQQAgAS0AACIAIABBAUYiABs6AAAgAA0AIAFBABBKCwuQAQICfwF+AkAgACkDACIDUA0AIANCA4NQRQ0AIAOnIgEgASgCDCIBQX9qNgIMIAFBAUcNAEHMsNEAEIwDIgEgAS0AACICQQEgAhs6AAACQCACRQ0AIAEgA0GAlOvcAxAbGgsgAUEEaiAAKAIAENACIAFBACABLQAAIgAgAEEBRiIAGzoAACAADQAgAUEAEEoLC5EBAQF/IwBBwABrIgUkACAFIAE2AgwgBSAANgIIIAUgAzYCFCAFIAI2AhAgBUEYakEMakECNgIAIAVBLGpBAjYCACAFQTBqQQxqQZ4BNgIAIAVBhO/RADYCICAFQQA2AhggBUGfATYCNCAFIAVBMGo2AiggBSAFQRBqNgI4IAUgBUEIajYCMCAFQRhqIAQQsgMAC4MBAQF/AkAgASgCCCIEIAJNDQAgACABKAIEIAJBBXRqIgMpAwA3AwAgAEEIaiADQQhqKQMANwMAIABBEGogA0EQaikDADcDACAAQRhqIANBGGopAwA3AwAgAyADQSBqIAQgAkF/c2pBBXQQwQQaIAEgBEF/ajYCCA8LIAIgBCADEMoCAAurAQEBfyMAQRBrIgIkAAJAAkACQAJAAkACQAJAIAAoAgAOBgABAgMEBQALIAFBhuPAAEEFEPoDIQAMBQsgAUH84sAAQQoQ+gMhAAwECyACIABBBGo2AgwgAUHi4sAAQQcgAkEMakHs4sAAEP0BIQAMAwsgAUHS4sAAQRAQ+gMhAAwCCyABQc3iwABBBRD6AyEADAELIAFBxOLAAEEJEPoDIQALIAJBEGokACAAC8YBAgF/AX5BACECAkAgACkDAEKCgICA8ABSDQACQAJAIAEpAwAiA0KBgICA8OAAVQ0AAkAgA0KBgICA4M0AVQ0AIANCgoCAgOAIUQ0CIANCgoCAgIA2UQ0CDAMLIANCgoCAgODNAFENASADQoKAgIDw3QBRDQEMAgsCQCADQoGAgIDwhQFVDQAgA0KCgICA8OAAUQ0BIANCgoCAgND2AFENAQwCCyADQoKAgIDwhQFRDQAgA0KCgICA8IkBUg0BC0EBIQILIAILjAECAn8BfgJAIAApAwAiA0IDg0IAUg0AIAOnIgEgASgCDCIBQX9qNgIMIAFBAUcNAEHMsNEAEIwDIgEgAS0AACICQQEgAhs6AAACQCACRQ0AIAEgA0GAlOvcAxAbGgsgAUEEaiAAKAIAENACIAFBACABLQAAIgAgAEEBRiIAGzoAACAADQAgAUEAEEoLC4wBAgJ/AX4CQCAAKQMAIgNCA4NCAFINACADpyIBIAEoAgwiAUF/ajYCDCABQQFHDQBBzLDRABCMAyIBIAEtAAAiAkEBIAIbOgAAAkAgAkUNACABIANBgJTr3AMQGxoLIAFBBGogACgCABDQAiABQQAgAS0AACIAIABBAUYiABs6AAAgAA0AIAFBABBKCwuMAQICfwF+AkAgACkDACIDQgODQgBSDQAgA6ciASABKAIMIgFBf2o2AgwgAUEBRw0AQcyw0QAQjAMiASABLQAAIgJBASACGzoAAAJAIAJFDQAgASADQYCU69wDEBsaCyABQQRqIAAoAgAQ0AIgAUEAIAEtAAAiACAAQQFGIgAbOgAAIAANACABQQAQSgsLjQEBAn8CQCAAQThqKAIAIgENAEEADwsCQAJAAkACQCABQQFHDQAgACgCECICDQELIABBNGooAgAiAEUNASABQQJ0IABqQXxqKAIAIQILIAJBGGotAABBBEcNASACQShqKQMAQoKAgIDwAFIPC0GsmcAAQRJBoJ3AABDuAgALQYSMwABBD0GUjMAAEMwDAAuWAQECfyMAQRBrIgIkAAJAAkACQAJAAkAgACgCACIDLQAAQX5qQf8BcSIAQQMgAEEDSRsOBAABAgMACyABQcWDwQBBBhD6AyEADAMLIAFBvoPBAEEHEPoDIQAMAgsgAUG0g8EAQQoQ+gMhAAwBCyACIAM2AgwgAUGQg8EAQREgAkEMakGkg8EAEP0BIQALIAJBEGokACAAC4ABAQF/IwBBMGsiAiQAIAIgATYCBCACIAA2AgAgAkEIakEMakEDNgIAIAJBHGpBAjYCACACQSBqQQxqQTA2AgAgAkGk09EANgIQIAJBADYCCCACQTA2AiQgAiACQSBqNgIYIAIgAkEEajYCKCACIAI2AiAgAkEIakG809EAELIDAAt9AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EIakEMakEDNgIAIANBHGpBAjYCACADQSBqQQxqQTA2AgAgA0Hg09EANgIQIANBADYCCCADQTA2AiQgAyADQSBqNgIYIAMgA0EEajYCKCADIAM2AiAgA0EIaiACELIDAAt9AQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EIakEMakECNgIAIANBHGpBAjYCACADQSBqQQxqQTA2AgAgA0HU7dEANgIQIANBADYCCCAD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ADYCECADQcSXwAA2AhggA0EANgIIIANBCGpBAkGgpcAAEIsCCyABQQE6AGcgACABQQYgAhABIAFBADoAZyADQSBqJAALbgECfyABKAIAIQQCQCABKAIIIgVFDQAgBCAFayADTw0AQQAhBSABQQA2AgggAUEAOgAMCwJAIAQgA00NACABKAIEIAVqIAIgAxDEBBogAEEEOgAAIAEgBSADajYCCA8LIABCBDcCACABQQA6AAwLegEDfyMAQRBrIgIkAAJAIAEoAgQNACABKAIMIQMgAkEIaiIEQQA2AgAgAkKAgICAEDcDACACIAI2AgwgAkEMakGottEAIAMQRxogAUEIaiAEKAIANgIAIAEgAikDADcCAAsgAEGMw9EANgIEIAAgATYCACACQRBqJAALZwEBfyMAQSBrIgIkACAAKAIAIQAgAkEIakEQaiABQRBqKQIANwMAIAJBCGpBCGogAUEIaikCADcDACACIAEpAgA3AwggAiAANgIEIAJBBGpBrJXAACACQQhqEEchASACQSBqJAAgAQtnAQF/IwBBIGsiAiQAIAAoAgAhACACQQhqQRBqIAFBEGopAgA3AwAgAkEIakEIaiABQQhqKQIANwMAIAIgASkCADcDCCACIAA2AgQgAkEEakHY3sAAIAJBCGoQRyEBIAJBIGokACABC2cBAX8jAEEgayICJAAgACgCACEAIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAIgADYCBCACQQRqQai20QAgAkEIahBHIQEgAkEgaiQAIAELZwEBfyMAQSBrIgIkACAAKAIAIQAgAkEIakEQaiABQRBqKQIANwMAIAJBCGpBCGogAUEIaikCADcDACACIAEpAgA3AwggAiAANgIEIAJBBGpBwLbRACACQQhqEEchASACQSBqJAAgAQtnAQF/IwBBIGsiAiQAIAAoAgAhACACQQhqQRBqIAFBEGopAgA3AwAgAkEIakEIaiABQQhqKQIANwMAIAIgASkCADcDCCACIAA2AgQgAkEEakHYttEAIAJBCGoQRyEBIAJBIGokACABC2cBAX8jAEEgayICJAAgACgCACEAIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAIgADYCBCACQQRqQejQ0QAgAkEIahBHIQEgAkEgaiQAIAELZwEBfyMAQSBrIgIkACAAKAIAIQAgAkEIakEQaiABQRBqKQIANwMAIAJBCGpBCGogAUEIaikCADcDACACIAEpAgA3AwggAiAANgIEIAJBBGpBzPHRACACQQhqEEchASACQSBqJAAgAQtoAQF/IwBBIGsiBSQAIAUgAjYCBCAFIAE2AgAgBUEIakEQaiADQRBqKQIANwMAIAVBCGpBCGogA0EIaikCADcDACAFIAMpAgA3AwggACAFQbyGwAAgBUEEakG8hsAAIAVBCGogBBB0AAtuAQF/IwBBIGsiAiQAIAJB8LbRADYCBCACIAA2AgAgAkEIakEQaiABQRBqKQIANwMAIAJBCGpBCGogAUEIaikCADcDACACIAEpAgA3AwhBACACQZS30QAgAkEEakGUt9EAIAJBCGpBgMrRABB0AAtrAQF/IwBBIGsiAyQAIAMgATYCBCADIAA2AgAgA0EIakEQaiACQRBqKQIANwMAIANBCGpBCGogAkEIaikCADcDACADIAIpAgA3AwhBACADQeTt0QAgA0EEakHk7dEAIANBCGpBhNXRABB0AAtjAQF/IAEgASgCAEEBaiICNgIAAkAgAkUNAAJAIABBOGooAgAiAiAAKAIwRw0AIABBMGogAhDeASAAKAI4IQILIABBNGooAgAgAkECdGogATYCACAAIAAoAjhBAWo2AjgPCwALYQECfyMAQSBrIgIkACAAKAIEIQMgACgCACEAIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAAgAyACQQhqEEchASACQSBqJAAgAQtgAQF/IwBBIGsiAiQAIAIgADYCBCACQQhqQRBqIAFBEGopAgA3AwAgAkEIakEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQayVwAAgAkEIahBHIQEgAkEgaiQAIAELYAEBfyMAQSBrIgIkACACIAA2AgQgAkEIakEQaiABQRBqKQIANwMAIAJBCGpBCGogAUEIaikCADcDACACIAEpAgA3AwggAkEEakHY3sAAIAJBCGoQRyEBIAJBIGokACABC2ABAX8jAEEgayICJAAgAiAANgIEIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBwLbRACACQQhqEEchASACQSBqJAAgAQtgAQF/IwBBIGsiAiQAIAIgADYCBCACQQhqQRBqIAFBEGopAgA3AwAgAkEIakEIaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQdi20QAgAkEIahBHIQEgAkEgaiQAIAELZAECfyMAQRBrIgIkACAAKAIIIQMgACgCBCEAIAIgARDLAwJAIANFDQADQCACIAA2AgwgAiACQQxqQYDR0QAQqAQaIABBAWohACADQX9qIgMNAAsLIAIQvwMhACACQRBqJAAgAAtnAQF/IwBBMGsiAyQAIAMgATYCDCADIAA2AgggA0EcakEBNgIAIANBJGpBATYCACADQYTt0QA2AhggA0EANgIQIANBnwE2AiwgAyADQShqNgIgIAMgA0EIajYCKCADQRBqIAIQsgMAC2ABAX8jAEEgayICJAAgAiAANgIEIAJBCGpBEGogAUEQaikCADcDACACQQhqQQhqIAFBCGopAgA3AwAgAiABKQIANwMIIAJBBGpBzPHRACACQQhqEEchASACQSBqJAAgAQtfAQF/AkAgAEEMaigCACICIAAoAgRHDQAgAEEEaiACEN8BIAAoAgwhAgsgAEEIaigCACACQQR0aiICIAEpAgA3AgAgAkEIaiABQQhqKQIANwIAIAAgACgCDEEBajYCDAuHAQIBfwF+QQAhAgJAIAApAwBCgoCAgPAAUg0AAkACQCABKQMAIgNCgYCAgMDPAFUNACADQoKAgICwFVENASADQoKAgIDQKFENASADQoKAgICQKVENAQwCCyADQoKAgICAhwFRDQAgA0KCgICAgIQBUQ0AIANCgoCAgMDPAFINAQtBASECCyACC3QBAX8jAEEQayICJAAgAiAAKAIAIgBBCGo2AgwgAUGSgsEAQQNBlYLBAEEEIABBFGpBnILBAEG/gcEAQQQgAEGsgsEAQbyCwQBBDCAAQRVqQciCwQBB2ILBAEEFIAJBDGpB4ILBABDuASEAIAJBEGokACAAC2kBAX8jAEEQayICJAACQAJAIAAoAgANACACIABBBGo2AgggAUHEqdEAQQcgAkEIakHMqdEAEP0BIQAMAQsgAiAAQQRqNgIMIAFBqKnRAEEKIAJBDGpBtKnRABD9ASEACyACQRBqJAAgAAtpAQR/IwBBEGsiAyQAQQAoAriOUiEEQQAoArSOUiEFQQAoAsSOUiEGIAMgAjYCBCADIAE2AgAgAyAANgIIIAVB8JHBACAGQQJGIgIbIAMgBEH8kcEAIAIbKAIQEQcAIQIgA0EQaiQAIAILXwECf0EAIQJBBCEDAkAgAUEFSQ0AIAEhAwJAAkAgAUF7ag4CAgEACyABQXlqIQFBASECQQYhAwwBC0EAIQFBASECQQUhAwsgACACNgIEIAAgAzYCACAAQQhqIAE2AgALZAICfwF+Qcyw0QAQjAMiASABLQAAIgJBASACGzoAAAJAIAJFDQAgASADQYCU69wDEBsaCyABQQRqIAAoAgAQ0AIgAUEAIAEtAAAiAiACQQFGIgIbOgAAAkAgAg0AIAFBABBKCwtvAQF/IwBBEGsiAiQAIAIgAEEwajYCDCABQbiBwQBBB0G/gcEAQQQgAEHEgcEAQdSBwQBBCSAAQRBqQcSBwQBB3YHBAEEJIABBIGpBxIHBAEHmgcEAQQwgAkEMakH0gcEAEO4BIQAgAkEQaiQAIAALbwEBfyMAQRBrIgIkACACIABBCGo2AgwgAUGSgsEAQQNBlYLBAEEEIABBFGpBnILBAEG/gcEAQQQgAEGsgsEAQbyCwQBBDCAAQRVqQciCwQBB2ILBAEEFIAJBDGpB4ILBABDuASEAIAJBEGokACAAC1sAAkACQCABRQ0AIABFDQAgAUECdCAAakF8aigCACIBQRhqLQAAQQRHDQEgAUEoaiABQTBqEPECDwtBrJnAAEESQaCdwAAQ7gIAC0GEjMAAQQ9BlIzAABDMAwALUgECfwJAIAAoAggiAyABTQ0AIAAoAgQgAUECdGoiAigCACEEIAIgAkEEaiADIAFBf3NqQQJ0EMEEGiAAIANBf2o2AgggBA8LIAEgAyACEMoCAAtgAQF/IwBBIGsiAiQAAkAgAQ0AIABBADYCBCACQSBqJAAPCyACQRRqQQE2AgAgAkEcakEANgIAIAJB/M/RADYCECACQeDP0QA2AhggAkEANgIIIAJBCGpB2NDRABCyAwALeAIBfwF+QQAhAgJAIAApAwBCgoCAgOAAUg0AAkACQCABKQMAIgNCgYCAgJA2VQ0AIANCgoCAgPACUQ0BIANCgoCAgIAYUQ0BDAILIANCgoCAgJA2UQ0AIANCgoCAgODJAFENACADQoKAgIDQO1INAQtBASECCyACC3sCAX8BfkEAIQICQCAAKQMAQoKAgIDwAFINAAJAAkAgASkDACIDQoGAgICQzQBVDQAgA0KCgICA0AVRDQEgA0KCgICA4AdRDQEMAgsgA0KCgICAkM0AUQ0AIANCgoCAgKDmAFENACADQoKAgIDQ8gBSDQELQQEhAgsgAgt7AgF/AX5BACECAkAgACkDAEKCgICA8ABSDQACQAJAIAEpAwAiA0KBgICAkM0AVQ0AIANCgoCAgNAFUQ0BIANCgoCAgIA3UQ0BDAILIANCgoCAgJDNAFENACADQoKAgICA0gBRDQAgA0KCgICA0PIAUg0BC0EBIQILIAILXAECfyABKAIAIQIgAUEANgIAAkACQCACRQ0AIAEoAgQhA0EIQQQQ/gMiAUUNASABIAM2AgQgASACNgIAIABB5JXAADYCBCAAIAE2AgAPCxDiBAALQQhBBBC8BAALUwEBfyMAQSBrIgMkACADQQxqIAJBCGooAgA2AgAgA0EBNgIAIAMgAikCADcCBCADQRBqIAFBABA7IAEgA0EQaiADEJECIABBADoAACADQSBqJAALXAECfyABKAIAIQIgAUEANgIAAkACQCACRQ0AIAEoAgQhA0EIQQQQ/gMiAUUNASABIAM2AgQgASACNgIAIABB5LLRADYCBCAAIAE2AgAPCxDiBAALQQhBBBC8BAALYgEDfyMAQRBrIgEkAAJAAkAgABDVBCICRQ0AIAAQ1AQiA0UNASABIAI2AgggASAANgIEIAEgAzYCACABEMoEAAtBpLfRAEErQfzC0QAQjQMAC0Gkt9EAQStB7MLRABCNAwALVgEBfwJAIAAoAggiAiAAKAIARw0AIAAgAhDfASAAKAIIIQILIAAoAgQgAkEEdGoiAiABKQIANwIAIAJBCGogAUEIaikCADcCACAAIAAoAghBAWo2AggLWgEEfwJAAkAgACgCBCIBIAAoAgAiAkYNAANAIAAgAUEQaiIDNgIEQQEhBAJAAkAgAS0AAA4DAAEEAAsgAUEEahCfAQ0DCyADIQEgAyACRw0ACwtBACEECyAEC1oBAn8jAEEQayICJAAgACgCACEDIABBADYCAAJAIAMNAEGI4sAAQStBtOLAABCNAwALIAJBCGogAEEMaigCADYCACACIAApAgQ3AwAgASACELIBIAJB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NAAgACgCACEAAkAgARCSBA0AAkAgARCTBA0AIAAgARCmBA8LIAAgARCxAg8LIAAgARCwAgs0ACAAKAIAIQACQCABEJIEDQACQCABEJMEDQAgACABEKYEDwsgACABELECDwsgACABELACCzQAAkAgACABEHgiAUUNAAJAQYSQ0gAQ6wRFDQAgARDPBBCeBA0BCyABQQAgABDDBBoLIAELNAAgACgCACEAAkAgARCSBA0AAkAgARCTBA0AIAAgARCnBA8LIAAgARCoAg8LIAAgARCpAgs5ACAAQYCAxAA2AiQgACABNgIgIABBADYCECAAQQA7AUAgAEKAgMQANwIwIABBADYCACAAQgA3AhgLKgEBfyAAIAAoAhAiAUENdCABcyIBQRF2IAFzIgFBBXQgAXMiATYCECABCzMBAX8CQAJAIAAtAKcCDQAgARCkASICQYCAxABGDQEgACACIAEQeRoPCyAAQQA6AKcCCws5AAJAAkAgAEGAgMQARg0AIABBgLADc0GAgLx/akH/j7x/Sw0BC0HM4cAAQStB+OHAABDuAgALIAALMwEBf0EAIQICQCAAKAIAKQMAIAEoAgApAwBSDQAgACgCBCkDACABKAIEKQMAUSECCyACCzUBAX9BASEBAkAgAC0ABA0AIAAoAgAiACgCAEHU79EAQQEgAEEEaigCACgCDBEKACEBCyABCzEAIAAgASgCACACIAMgASgCBCgCDBEKADoACCAAIAE2AgQgACADRToACSAAQQA2AgALLgEBfyMAQRBrIgEkACABIAApAgA3AwggAUEIakGovsAAQQAgACgCCEEBEPkBAAs8AgF/AX5BASECAkAgACkDAEKCgICA8ABSDQAgASkDACIDQoKAgIDw2QBSIANCgoCAgMDuAFJxIQILIAILOwIBfwF+QQAhAgJAIAApAwBCgoCAgPAAUg0AIAEpAwAiA0KCgICA8DFRIANCgoCAgMD1AFFyIQILIAILPAIBfwF+QQAhAgJAIAApAwBCgoCAgPAAUg0AIAEpAwAiA0KCgICAoPQAUSADQoKAgIDQyABRciECCyACCy4BAX8jAEEQayIBJAAgASAAKQIANwMIIAFBCGpB0LLRAEEAIAAoAghBARD5AQALLQACQAJAIAEQkgQNACABEJMEDQEgACABENQDDwsgACABELACDwsgACABELECCycAIAAgACgCBEEBcSABckECcjYCBCAAIAFqIgAgACgCBEEBcjYCBAsoACAAKAIAIAAtAAhqIAAoAgRBgIC8f2oiAEEDIABBA0kbIABBAksbCzEAIABBAzoAICAAQoCAgICABDcCGCAAQQA2AhAgAEEANgIIIAAgAjYCBCAAIAE2AgALLQAgASgCACACIAMgASgCBCgCDBEKACEDIABBADoABSAAIAM6AAQgACABNgIACzIBAX8gASgCAEGM7dEAQQEgASgCBCgCDBEKACECIABBADoABSAAIAI6AAQgACABNgIACygBAX8jAEEQayIDJAAgAyACNgIIIAMgATYCBCADIAA2AgAgAxDFBAALJQEBfyMAQRBrIgIkACACIABBABA7IAAgAiABEJECIAJBEGokAAsiACAAIABBIGpBgIDEACAAQb9/akEaSRsgAEGff2pBGkkbCygBAX8jAEEQayIDJAAgAyACNgIIIAMgATYCBCADIAA2AgAgAxDHBAALJwEBfwJAIABBBGooAgAiAUUNACAAKAIAIgBFDQAgASAAQQEQlAQLCyYBAn9BACECAkAgACgCACIDIAFLDQAgAyAAKAIEaiABSyECCyACCygAAkACQCABQfz///8HSw0AIAAgAUEEIAIQ9QMiAQ0BCxDQBAALIAELIwAgAiACKAIEQX5xNgIEIAAgAUEBcjYCBCAAIAFqIAE2AgALHwAgACgCACIArUIAIACsfSAAQX9KIgAbIAAgARCdAQsoACABIAAoAgAtAABBAnQiAEHsicEAaigCACAAQeCJwQBqKAIAEPoDCyUAIAEgAC0AAEECdCIAQfyQwQBqKAIAIABBoJDBAGooAgAQ+gMLJQAgASAALQAAQQJ0IgBB5JHBAGooAgAgAEHYkcEAaigCABD6AwslACABIAAtAABBAnQiAEG8ztEAaigCACAAQZjN0QBqKAIAEPoDCx4AIAAgAUEDcjYCBCAAIAFqIgEgASgCBEEBcjYCBAsgAAJAIAENACAAIAM2AgQgACACNgIADwsgAiADELwEAAsgAQF/AkAgACgCCCIBRQ0AIABBDGooAgAgAUEBEJQECwsgAQF/AkAgACgCACIBRQ0AIABBBGooAgAgAUEBEJQECwsXACAAQVBqQQpJIABBX3FBv39qQRpJcgsjACABQfCCwQBB/YLBACAAKAIA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dC5sZW4oKbwAEABbAAAAHAcAAAUAAAC8ABAAWwAAAJwEAAAWAAAAvAAQAFsAAADcBAAAFgAAAGFzc2VydGlvbiBmYWlsZWQ6IGVkZ2UuaGVpZ2h0ID09IHNlbGYubm9kZS5oZWlnaHQgLSAxAAAAvAAQAFsAAADdAwAACQAAAC9ydXN0Yy85MGM1NDE4MDZmMjNhMTI3MDAyZGU1YjQwMzhiZTczMWJhMTQ1OGNhL2xpYnJhcnkvYWxsb2Mvc3JjL2NvbGxlY3Rpb25zL2J0cmVlL25hdmlnYXRlLnJzAAgCEABfAAAAWQIAADAAAAAIAhAAXwAAABcCAAAvAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvcGhmX3NoYXJlZC0wLjguMC9zcmMvbGliLnJzAAAAAAAAAAAAAABhdHRlbXB0IHRvIGNhbGN1bGF0ZSB0aGUgcmVtYWluZGVyIHdpdGggYSBkaXZpc29yIG9mIHplcm8AAACIAhAAXQAAADoAAAAFAAAAAQAAAAQAAAAEAAAAAgAAADwDEAAAAAAAAAAAAP//////////L2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvdGVuZHJpbC0wLjQuMi9zcmMvYnVmMzIucnNgAxAAXAAAAB0AAAAuAAAAYAMQAFwAAABWAAAAOwAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL3RlbmRyaWwucnMAANwDEABeAAAArgMAAD0AAABjaGlsZCBwYXNzZWQgdG8gYXBwZW5kIGNhbm5vdCBoYXZlIGV4aXN0aW5nIHBhcmVudC9ob21lL2ItZnVzZS9Qcm9qZWN0cy9naXQvZGVuby1kb20vaHRtbC1wYXJzZXIvY29yZS9zcmMvcmNkb20ucnMAAH4EEABAAAAAkgAAAAUAAABhbHJlYWR5IGJvcnJvd2VkAwAAAAAAAAABAAAABAAAAH4EEABAAAAAlwAAABkAAABkYW5nbGluZyB3ZWFrIHBvaW50ZXIgdG8gcGFyZW50YWxyZWFkeSBtdXRhYmx5IGJvcnJvd2VkAAMAAAAAAAAAAQAAAAUAAAB+BBAAQAAAAKEAAAAKAAAAaGF2ZSBwYXJlbnQgYnV0IGNvdWxkbid0IGZpbmQgaW4gcGFyZW50J3MgY2hpbGRyZW4hAH4EEABAAAAApwAAABEAAAB+BBAAQAAAAJ0AAAAhAAAAfgQQAEAAAACvAAAAFgAAAH4EEABAAAAAuAAAABkAAAB+BBAAQAAAALgAAAAmAAAAbm90IGEgdGVtcGxhdGUgZWxlbWVudCEAfgQQAEAAAADhAAAADQAAAG5vdCBhbiBlbGVtZW50IQB+BBAAQAAAAPAAAAASAAAAfgQQAEAAAAAUAQAALgAAAGFwcGVuZF9iZWZvcmVfc2libGluZyBjYWxsZWQgb24gbm9kZSB3aXRob3V0IHBhcmVudAB+BBAAQAAAADIBAAAwAAAAfgQQAEAAAAAzAQAAHQAAAH4EEABAAAAARgEAABkAAAB+BBAAQAAAACgBAAAOAAAAbm90IGFuIGVsZW1lbnQAAH4EEABAAAAAbgEAAA0AAAB+BBAAQAAAAGwBAAATAAAAfgQQAEAAAACBAQAAKgAAAH4EEABAAAAAggEAADQAAABkYW5nbGluZyB3ZWFrYXNzZXJ0aW9uIGZhaWxlZDogUmM6OnB0cl9lcSgmbm9kZSwgJnByZXZpb3VzX3BhcmVudC51bndyYXAoKS51cGdyYWRlKCkuZXhwZWN0KFwiZGFuZ2xpbmcgd2Vha1wiKSkAfgQQAEAAAACFAQAADQAAAH4EEABAAAAAhwEAADUAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAH4EEABAAAAAhwEAACIAAAB+BBAAQAAAAJUBAAANAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvbWFya3VwNWV2ZXItMC4xMC4xL3V0aWwvYnVmZmVyX3F1ZXVlLnJzAAAA1AcQAGkAAADVAAAAFQAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUABgAAAAEAAAABAAAABwAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL3RlbmRyaWwucnMAAIwIEABeAAAAXQMAAB8AAAAAAAAA1AcQAGkAAADmAAAAFQAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL2J1ZjMyLnJzEAkQAFwAAAAdAAAALgAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3BoZl9zaGFyZWQtMC44LjAvc3JjL2xpYi5ycwAAAHwJEABdAAAAOQAAABoAAAAAAAAAYXR0ZW1wdCB0byBjYWxjdWxhdGUgdGhlIHJlbWFpbmRlciB3aXRoIGEgZGl2aXNvciBvZiB6ZXJvAAAAfAkQAF0AAAA6AAAABQAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3N0cmluZ19jYWNoZS0wLjguMi9zcmMvYXRvbS5yczwKEABgAAAAjwAAABsAAAAIAAAABAAAAAQAAAAJAAAACgAAAAsAAAA8ChAAYAAAAAcBAAAfAAAAPAoQAGAAAAAFAQAALwAAAAgAAAAIAAAABAAAAAwAAABjYWxsZWQgYFJlc3VsdDo6dW53cmFwKClgIG9uIGFuIGBFcnJgIHZhbHVlABYAAAABAAAAAQAAAAcAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi90ZW5kcmlsLTAuNC4yL3NyYy90ZW5kcmlsLnJzAAAwCxAAXgAAAF0DAAAfAAAAQmFkIERPQ1RZUEU6IAAAAKALEAANAAAAQmFkIERPQ1RZUEUARE9DVFlQRSBpbiBpbnNlcnRpb24gbW9kZSAAAMQLEAAaAAAARE9DVFlQRSBpbiBib2R5c3RhdGljaW5saW5lZHluYW1pY0F0b20oJycgdHlwZT0pCgwQAAYAAAAQDBAABwAAABcMEAABAAAAMAsQAF4AAABXAAAANQAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL2J1ZjMyLnJzQAwQAFwAAAAdAAAALgAAAG5vIGN1cnJlbnQgZWxlbWVudC9ob21lL2ItZnVzZS9Qcm9qZWN0cy9naXQvZGVuby1kb20vaHRtbC1wYXJzZXIvd2FzbS90YXJnZXQvd2FzbTMyLXVua25vd24tdW5rbm93bi9yZWxlYXNlL2J1aWxkL2h0bWw1ZXZlci1lMzg4OGViMTExMTM3YTI1L291dC9ydWxlcy5ycwAAAL4MEACHAAAACAAAABgAAABodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcnByb2Nlc3NpbmcgIGluIGluc2VydGlvbiBtb2RlIAAAAG8NEAALAAAAeg0QABMAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9odG1sNWV2ZXItMC4yNS4xL3NyYy90cmVlX2J1aWxkZXIvbW9kLnJzAABYDRAAFwAAAFgNEAAXAAAAoA0QAGoAAAA4AQAAVW5leHBlY3RlZCB0b2tlbiAAAAAoDhAAEQAAAHoNEAATAAAAVW5leHBlY3RlZCB0b2tlbmFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaHRtbF9lbGVtX25hbWVkKCZub2RlLCBuYW1lKQCgDRAAagAAAFsCAAAJAAAAoA0QAGoAAACJAgAAIAAAAGltcG9zc2libGUgY2FzZSBpbiBmb3JlaWduIGNvbnRlbnQAAL4MEACHAAAAYwYAABAAAAC+DBAAhwAAAFoGAAAsAAAAVW5leHBlY3RlZCBvcGVuIHRhZyAgYXQgZW5kIG9mIGJvZHkA9A4QABQAAAAIDxAADwAAAFVuZXhwZWN0ZWQgb3BlbiB0YWcgYXQgZW5kIG9mIGJvZHlleHBlY3RlZCB0byBjbG9zZSA8dGQ+IG9yIDx0aD4gd2l0aCBjZWxsY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQAAAKANEABqAAAAIQUAADAAAABGb3JtYXR0aW5nIGVsZW1lbnQgbm90IGluIHNjb3BlRm9ybWF0dGluZyBlbGVtZW50IG5vdCBjdXJyZW50IG5vZGUAAKANEABqAAAA6gIAACMAAACgDRAAagAAAPwCAAAYAAAAYm9va21hcmsgbm90IGZvdW5kIGluIGFjdGl2ZSBmb3JtYXR0aW5nIGVsZW1lbnRzZm9ybWF0dGluZyBlbGVtZW50IG5vdCBmb3VuZCBpbiBhY3RpdmUgZm9ybWF0dGluZyBlbGVtZW50cwAAoA0QAGoAAABeAwAALAAAAKANEABqAAAAXQMAABoAAACgDRAAagAAAFgDAAAaAAAAZnVydGhlc3QgYmxvY2sgbWlzc2luZyBmcm9tIG9wZW4gZWxlbWVudCBzdGFjawAAoA0QAGoAAABoAwAAEgAAAKANEABqAAAAUgMAABoAAACgDRAAagAAAAcDAAAlAAAARm91bmQgbWFya2VyIGR1cmluZyBhZG9wdGlvbiBhZ2VuY3kAoA0QAGoAAAAaAwAAHwAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuc2luay5zYW1lX25vZGUoaCwgJm5vZGUpAKANEABqAAAAFwMAABkAAACgDRAAagAAACMDAAARAAAAoA0QAGoAAAAkAwAAEQAAAKANEABqAAAADwMAACkAAACgDRAAagAAAOUCAAAsAAAARm9ybWF0dGluZyBlbGVtZW50IG5vdCBvcGVuAKANEABqAAAAyAIAACwAAACgDRAAagAAAAYDAABAAAAAVW5leHBlY3RlZCBvcGVuIGVsZW1lbnQgd2hpbGUgY2xvc2luZyAAAAASEAAmAAAAVW5leHBlY3RlZCBvcGVuIGVsZW1lbnQAoA0QAGoAAACBAwAAHQAAAKANEABqAAAAvQQAAE8AAACgDRAAagAAAKgEAAAlAAAAZm9zdGVyIHBhcmVudGluZyBub3QgaW1wbGVtZW50ZWR4EhAAIAAAAFgNEAAXAAAAWA0QABcAAACgDRAAagAAAH8EAABhc3NlcnRpb24gZmFpbGVkOiBtb3JlX3Rva2Vucy5pc19lbXB0eSgpoA0QAGoAAAB/AQAAFQAAAKANEABqAAAAewEAABUAAACgDRAAagAAAHcBAAAVAAAAVW5hY2tub3dsZWRnZWQgc2VsZi1jbG9zaW5nIHRhZ2Fzc2VydGlvbiBmYWlsZWQ6IHNlbGYucGVuZGluZ190YWJsZV90ZXh0LmlzX2VtcHR5KCkAoA0QAGoAAACKBAAADQAAAFVuZXhwZWN0ZWQgY2hhcmFjdGVycyAgaW4gdGFibGUAeBMQABYAAACOExAACQAAAFVuZXhwZWN0ZWQgY2hhcmFjdGVycyBpbiB0YWJsZQAAoA0QAGoAAACgAwAAKAAAAKANEABqAAAApwMAAB0AAABGb3VuZCBtYXJrZXIgZHVyaW5nIGZvcm1hdHRpbmcgZWxlbWVudCByZWNvbnN0cnVjdGlvbgAAAKANEABqAAAAqQMAABsAAACgDRAAagAAALADAAANAAAARm91bmQgc3BlY2lhbCB0YWcgd2hpbGUgY2xvc2luZyBnZW5lcmljIHRhZ21hdGNoZXMgd2l0aCBubyBpbmRleKANEABqAAAATQUAABIAAACgDRAAagAAAE0FAAAlAAAAoA0QAGoAAACoAQAAMQAAAG5vIGNvbnRleHQgZWxlbWVudAAAoA0QAGoAAADnAAAALwAAAKANEABqAAAAdQMAACoAAAC+DBAAhwAAAN0EAAB4AAAATm9uLXNwYWNlIHRhYmxlIHRleHRub3QgcHJlcGFyZWQgdG8gaGFuZGxlIHRoaXMhvgwQAIcAAACOAwAAEwAAAL4MEACHAAAAlQMAACsAAABpbXBvc3NpYmxlIGNhc2UgaW4gVGV4dCBtb2RlvgwQAIcAAAAaAwAAEAAAAL4MEACHAAAAFwMAAEcAAAC+DBAAhwAAAA8DAAA7AAAAQ2xvc2luZyB3cm9uZyBoZWFkaW5nIHRhZ05vIGhlYWRpbmcgdGFnIHRvIGNsb3NlTm8gbWF0Y2hpbmcgdGFnIHRvIGNsb3NlTm8gPHA+IHRhZyB0byBjbG9zZUZvcm0gZWxlbWVudCBub3QgaW4gc2NvcGUgb24gPC9mb3JtPkJhZCBvcGVuIGVsZW1lbnQgb24gPC9mb3JtPk51bGwgZm9ybSBlbGVtZW50IHBvaW50ZXIgb24gPC9mb3JtPjwvaHRtbD4gd2l0aCBubyA8Ym9keT4gaW4gc2NvcGU8L2JvZHk+IHdpdGggbm8gPGJvZHk+IGluIHNjb3BlaW1wb3NzaWJsZSBjYXNlIGluIEluQm9keSBtb2RlAAC+DBAAhwAAAAgDAAAQAAAATmVzdGVkIDxub2JyPm5lc3RlZCBidXR0b25zbmVzdGVkIGZvcm1zbmVzdGVkIGhlYWRpbmcgdGFnc25vIGhlYWQgZWxlbWVudAAAAL4MEACHAAAA1gAAAEkAAACgDRAAagAAALoDAAAKAAAAoA0QAGoAAAAdAgAABgAAAEluZGV4IG91dCBvZiBib3VuZHMAOBcQABMAAAAvcnVzdGMvOTBjNTQxODA2ZjIzYTEyNzAwMmRlNWI0MDM4YmU3MzFiYTE0NThjYS9saWJyYXJ5L2NvcmUvc3JjL3NsaWNlL3NvcnQucnMAAFQXEABOAAAAxgQAAA0AAABUFxAATgAAANMEAAAYAAAAVBcQAE4AAADUBAAAGQAAAFQXEABOAAAA1QQAACQAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlAFQXEABOAAAAGQUAAEAAAABUFxAATgAAAD8FAABOAAAAVBcQAE4AAABNBQAAVgAAAGFzc2VydGlvbiBmYWlsZWQ6IGVuZCA+PSBzdGFydCAmJiBlbmQgPD0gbGVuVBcQAE4AAAC5BQAABQAAAFQXEABOAAAAygUAACgAAABhc3NlcnRpb24gZmFpbGVkOiBvZmZzZXQgIT0gMCAmJiBvZmZzZXQgPD0gbGVuAABUFxAATgAAAJsAAAAFAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvdGVuZHJpbC0wLjQuMi9zcmMvYnVmMzIucnPMGBAAXAAAAB0AAAAuAAAAzBgQAFwAAABWAAAAOwAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL3RlbmRyaWwucnMAAEgZEABeAAAAAAMAAD8AAABIGRAAXgAAAK4DAAA9AAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvc3RyaW5nX2NhY2hlLTAuOC4yL3NyYy9hdG9tLnJzyBkQAGAAAAAHAQAAHwAAAMgZEABgAAAABQEAAC8AAAAKVG9rZW5pemVyIHByb2ZpbGUsIGluIG5hbm9zZWNvbmRzCgBIGhAAIwAAAAogICAgICAgICB0b3RhbCBpbiB0b2tlbiBzaW5rCgAAdBoQAAEAAAB1GhAAHQAAACAgICAgICAgIHRvdGFsIGluIHRva2VuaXplcgp0GhAAAQAAAKQaEAAcAAAAICAlICAAAADMGBAAAAAAANAaEAACAAAA0hoQAAMAAAB0GhAAAQAAAFNhdyBFT0YgaW4gc3RhdGUgAAAA+BoQABEAAABVbmV4cGVjdGVkIEVPRlNhdyAgaW4gc3RhdGUgIhsQAAQAAAAmGxAACgAAAEJhZCBjaGFyYWN0ZXJnb3QgY2hhcmFjdGVycyBNGxAADwAAAGh0bWw1ZXZlcjo6dG9rZW5pemVyL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvaHRtbDVldmVyLTAuMjUuMS9zcmMvdG9rZW5pemVyL21vZC5ycwBkGxAAFAAAAGQbEAAUAAAAeBsQAGcAAAAzAQAAQXR0cmlidXRlcyBvbiBhbiBlbmQgdGFnU2VsZi1jbG9zaW5nIGVuZCB0YWdEdXBsaWNhdGUgYXR0cmlidXRlAHgbEABnAAAAYAUAABUAAABzdGF0ZSAgc2hvdWxkIG5vdCBiZSByZWFjaGFibGUgaW4gcHJvY2Vzc19jaGFyX3JlZgAATBwQAAYAAABSHBAALAAAAHgbEABnAAAAZgUAABYAAABCYWQgY2hhcmFjdGVyIAAAoBwQAA4AAABnb3QgY2hhcmFjdGVyIAAAuBwQAA4AAABkGxAAFAAAAGQbEAAUAAAAeBsQAGcAAAAXAQAAYXNzZXJ0aW9uIGZhaWxlZDogbWF0Y2hlcyEoc2VsZi5wcm9jZXNzX3Rva2VuKHRva2VuKSwgVG9rZW5TaW5rUmVzdWx0IDo6IENvbnRpbnVlKQAAeBsQAGcAAADyAAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IG1hdGNoZXMhKHNlbGYucnVuKCYgbXV0IGlucHV0KSwgVG9rZW5pemVyUmVzdWx0IDo6IERvbmUpAAB4GxAAZwAAAH4FAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogaW5wdXQuaXNfZW1wdHkoKQAAeBsQAGcAAAB/BQAACQAAAHByb2Nlc3NpbmcgaW4gc3RhdGUg4B0QABQAAABkGxAAFAAAAGQbEAAUAAAAeBsQAGcAAACzAgAAcHVibGljc3lzdGVtLS0hLS0h77+9LS0tLe+/vS3vv71kb2N0eXBlW0NEQVRBW3NjcmlwdHByb2Nlc3NpbmcgRU9GIGluIHN0YXRlIEweEAAYAAAAZBsQABQAAABkGxAAFAAAAHgbEABnAAAApAUAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaW5wdXRfYnVmZmVyLmlzX2VtcHR5KCkvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9odG1sNWV2ZXItMC4yNS4xL3NyYy9kcml2ZXIucnMAALYeEABgAAAAegAAAAkAAAAeAAAACAAAAAQAAAAfAAAAIAAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUvcnVzdGMvOTBjNTQxODA2ZjIzYTEyNzAwMmRlNWI0MDM4YmU3MzFiYTE0NThjYS9saWJyYXJ5L2FsbG9jL3NyYy9jb2xsZWN0aW9ucy9idHJlZS9uYXZpZ2F0ZS5ycwAAZx8QAF8AAACiAAAAJAAAAFNvbWVOb25lHgAAAAQAAAAEAAAAIQAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL2J1ZjMyLnJz8B8QAFwAAAAdAAAALgAAAHNlcmlhbGl6ZV9ub2RlIGZhaWxlZCB0byBwcm9kdWNlIHZhbGlkIFVURi04IgAAABQAAAAEAAAAIwAAAC9ob21lL2ItZnVzZS9Qcm9qZWN0cy9naXQvZGVuby1kb20vaHRtbC1wYXJzZXIvY29yZS9zcmMvbGliLnJzAACYIBAAPgAAAD0AAAAcAAAAWzEsAOggEAADAAAAY2FsbGVkIGBSZXN1bHQ6OnVud3JhcCgpYCBvbiBhbiBgRXJyYCB2YWx1ZQAkAAAACAAAAAQAAAAlAAAAmCAQAD4AAABxAAAAJgAAACYAAAAEAAAABAAAACcAAACYIBAAPgAAAHIAAAA7AAAALAAAAGAhEAABAAAAmCAQAD4AAABzAAAAJAAAAGFscmVhZHkgbXV0YWJseSBib3Jyb3dlZCgAAAAAAAAAAQAAAAUAAACYIBAAPgAAAHsAAAAtAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQCYIBAAPgAAAJMAAAAfAAAAXQAAAPAhEAABAAAAmCAQAD4AAACXAAAAJAAAAFs4LAAMIhAAAwAAAJggEAA+AAAAoQAAACYAAACYIBAAPgAAAKIAAABBAAAAmCAQAD4AAACjAAAAJAAAAFszLABIIhAAAwAAAJggEAA+AAAAmwAAACYAAACYIBAAPgAAAJwAAAA3AAAAmCAQAD4AAACcAAAASgAAAJggEAA+AAAAnQAAACQAAABbMTAslCIQAAQAAACYIBAAPgAAAKsAAAAnAAAAmCAQAD4AAACsAAAAPQAAAJggEAA+AAAArQAAACQAAACYIBAAPgAAAK4AAABCAAAAmCAQAD4AAACvAAAAJAAAAJggEAA+AAAAsAAAAEIAAACYIBAAPgAAALEAAAAkAAAAmCAQAD4AAABJAAAAKQAAAFs5LCIjZG9jdW1lbnQiLFtdAAAAICMQABEAAACYIBAAPgAAAEsAAAA2AAAAmCAQAD4AAABNAAAAKAAAAJggEAA+AAAAZQAAAB8AAABbAAAAbCMQAAEAAACYIBAAPgAAALkAAAAcAAAAmCAQAD4AAAC6AAAAFAAAAJggEAA+AAAAvgAAACAAAACYIBAAPgAAAL8AAABEAAAAmCAQAD4AAADAAAAAIAAAAJggEAA+AAAAwQAAAD8AAABdLAAA2CMQAAIAAACYIBAAPgAAAMQAAAAlAAAAmCAQAD4AAADGAAAAJAAAAJggEAA+AAAAygAAABwAAAApAAAADAAAAAQAAAAqAAAAKwAAACwAAABmb3JtYXR0ZXIgZXJyb3IALCQQAA8AAAAoAAAAL3J1c3RjLzkwYzU0MTgwNmYyM2ExMjcwMDJkZTViNDAzOGJlNzMxYmExNDU4Y2EvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAAEgkEABKAAAAkgAAABEAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi90ZW5kcmlsLTAuNC4yL3NyYy90ZW5kcmlsLnJzAACkJBAAXgAAAFcAAAA1AAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvdGVuZHJpbC0wLjQuMi9zcmMvYnVmMzIucnMUJRAAXAAAAB0AAAAuAAAAL3J1c3RjLzkwYzU0MTgwNmYyM2ExMjcwMDJkZTViNDAzOGJlNzMxYmExNDU4Y2EvbGlicmFyeS9jb3JlL3NyYy9jaGFyL21ldGhvZHMucnN0b19kaWdpdDogcmFkaXggaXMgdG9vIGhpZ2ggKG1heGltdW0gMzYp0CUQACgAAACAJRAAUAAAAE0BAAANAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvdGVuZHJpbC0wLjQuMi9zcmMvYnVmMzIucnMQJhAAXAAAAB0AAAAuAAAAECYQAFwAAABWAAAAOwAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL3RlbmRyaWwucnMAAIwmEABeAAAArgMAAD0AAABFT0YgaW4gbnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlRU9GIGFmdGVyICcjJyBpbiBjaGFyYWN0ZXIgcmVmZXJlbmNlYXNzZXJ0aW9uIGZhaWxlZDogbmFtZV9sZW4gPiAwL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvaHRtbDVldmVyLTAuMjUuMS9zcmMvdG9rZW5pemVyL2NoYXJfcmVmL21vZC5yc2AnEABwAAAAXQEAABEAAABgJxAAcAAAAF4BAAAkAAAAYCcQAHAAAABlAQAAGgAAAENoYXJhY3RlciByZWZlcmVuY2UgZG9lcyBub3QgZW5kIHdpdGggc2VtaWNvbG9uRXF1YWxzIHNpZ24gYWZ0ZXIgY2hhcmFjdGVyIHJlZmVyZW5jZSBpbiBhdHRyaWJ1dGUAAABgJxAAcAAAAIcBAAA+AAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQBgJxAAcAAAAIkBAABFAAAAYCcQAHAAAACJAQAALgAAAGAnEABwAAAAZQEAAEUAAABgJxAAcAAAAF4BAABTAAAASW52YWxpZCBudW1lcmljIGNoYXJhY3RlciByZWZlcmVuY2UgdmFsdWUgMHjgKBAALAAAAEludmFsaWQgbnVtZXJpYyBjaGFyYWN0ZXIgcmVmZXJlbmNlSW52YWxpZCBjaGFyYWN0ZXIgcmVmZXJlbmNlICY3KRAAHQAAAEludmFsaWQgY2hhcmFjdGVyIHJlZmVyZW5jZU51bWVyaWMgY2hhcmFjdGVyIHJlZmVyZW5jZSB3aXRob3V0IGRpZ2l0c1NlbWljb2xvbiBtaXNzaW5nIGFmdGVyIG51bWVyaWMgY2hhcmFjdGVyIHJlZmVyZW5jZWNoYXIgcmVmIHRva2VuaXplciBzdGVwcGluZyBpbiBzdGF0ZSAAAADUKRAAJQAAAGh0bWw1ZXZlcjo6dG9rZW5pemVyOjpjaGFyX3JlZgAABCoQAB4AAAAEKhAAHgAAAGAnEABwAAAAfwAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGUvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9zZXJkZV9qc29uLTEuMC42OC9zcmMvc2VyLnJzAABoKhAAXgAAADIGAAASAAAAaCoQAF4AAAAqCAAAOwAAAGgqEABeAAAANAgAADcAAABcdFxyXG5cZlxiXFxcImFwcGxpY2F0aW9uL3hodG1sK3htbC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL2J1ZjMyLnJzABsrEABcAAAAHQAAAC4AAAAyAAAADAAAAAQAAAAzAAAANAAAADUAAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5ADYAAAAAAAAAAQAAADcAAAAvcnVzdGMvOTBjNTQxODA2ZjIzYTEyNzAwMmRlNWI0MDM4YmU3MzFiYTE0NThjYS9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnMA6CsQAEsAAADdCQAADgAAAHJlY3Vyc2lvbiBsaW1pdCBleGNlZWRlZHVuZXhwZWN0ZWQgZW5kIG9mIGhleCBlc2NhcGV0cmFpbGluZyBjaGFyYWN0ZXJzdHJhaWxpbmcgY29tbWFsb25lIGxlYWRpbmcgc3Vycm9nYXRlIGluIGhleCBlc2NhcGVrZXkgbXVzdCBiZSBhIHN0cmluZ2NvbnRyb2wgY2hhcmFjdGVyIChcdTAwMDAtXHUwMDFGKSBmb3VuZCB3aGlsZSBwYXJzaW5nIGEgc3RyaW5naW52YWxpZCB1bmljb2RlIGNvZGUgcG9pbnRudW1iZXIgb3V0IG9mIHJhbmdlaW52YWxpZCBudW1iZXJpbnZhbGlkIGVzY2FwZWV4cGVjdGVkIHZhbHVlZXhwZWN0ZWQgaWRlbnRleHBlY3RlZCBgLGAgb3IgYH1gZXhwZWN0ZWQgYCxgIG9yIGBdYGV4cGVjdGVkIGA6YEVPRiB3aGlsZSBwYXJzaW5nIGEgdmFsdWVFT0Ygd2hpbGUgcGFyc2luZyBhIHN0cmluZ0VPRiB3aGlsZSBwYXJzaW5nIGFuIG9iamVjdEVPRiB3aGlsZSBwYXJzaW5nIGEgbGlzdEVycm9yKCwgbGluZTogLCBjb2x1bW46ICkAAAAMLhAABgAAABIuEAAIAAAAGi4QAAoAAAAkLhAAAQAAADAxMjM0NTY3ODlhYmNkZWZ1dXV1dXV1dWJ0bnVmcnV1dXV1dXV1dXV1dXV1dXV1dQAAIgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAEAAAAOQAAADoAAAA7AAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvdGVuZHJpbC0wLjQuMi9zcmMvYnVmMzIucnNwLxAAXAAAAB0AAAAuAAAAZ2V0X3Jlc3VsdCBjYWxsZWQgYmVmb3JlIGRvbmUvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9odG1sNWV2ZXItMC4yNS4xL3NyYy90b2tlbml6ZXIvY2hhcl9yZWYvbW9kLnJzAAAA+S8QAHAAAABVAAAAFQAAAG5hbWVfYnVmIG1pc3NpbmcgaW4gbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZQAAAPkvEABwAAAAWwAAAA4AAAD5LxAAcAAAAGEAAAAOAAAAaW52YWxpZCBjaGFyIG1pc3NlZCBieSBlcnJvciBoYW5kbGluZyBjYXNlcwD5LxAAcAAAAPQAAAAZAAAAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZQD5LxAAcAAAADcBAAAzAAAAQm9ndXNOYW1lTmFtZWROdW1lcmljU2VtaWNvbG9uTnVtZXJpYwAAADwAAAAEAAAABAAAAD0AAABPY3RvdGhvcnBlQmVnaW4APgAAAAQAAAAEAAAAPwAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3RlbmRyaWwtMC40LjIvc3JjL2J1ZjMyLnJznDEQAFwAAAAdAAAALgAAAJwxEABcAAAAVgAAADsAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi90ZW5kcmlsLTAuNC4yL3NyYy90ZW5kcmlsLnJzAAAYMhAAXgAAAK4DAAA9AAAAaW5saW5lb3duZWRzaGFyZWRUZW5kcmlsPD4oOiAAAACZMhAACAAAAKEyEAACAAAAozIQAAIAAAApAAAAwDIQAAEAAABTb21lQgAAAAQAAAAEAAAAQwAAAE5vbmUtLy9hZHZhc29mdCBsdGQvL2R0ZCBodG1sIDMuMCBhc3dlZGl0ICsgZXh0ZW5zaW9ucy8vLS8vYXMvL2R0ZCBodG1sIDMuMCBhc3dlZGl0ICsgZXh0ZW5zaW9ucy8vLS8vaWV0Zi8vZHRkIGh0bWwgMi4wIGxldmVsIDEvLy0vL2lldGYvL2R0ZCBodG1sIDIuMCBsZXZlbCAyLy8tLy9pZXRmLy9kdGQgaHRtbCAyLjAgc3RyaWN0IGxldmVsIDEvLy0vL2lldGYvL2R0ZCBodG1sIDIuMCBzdHJpY3QgbGV2ZWwgMi8vLS8vaWV0Zi8vZHRkIGh0bWwgMi4wIHN0cmljdC8vLS8vaWV0Zi8vZHRkIGh0bWwgMi4wLy8tLy9pZXRmLy9kdGQgaHRtbCAyLjFlLy8tLy9pZXRmLy9kdGQgaHRtbCAzLjAvLy0vL2lldGYvL2R0ZCBodG1sIDMuMiBmaW5hbC8vLS8vaWV0Zi8vZHRkIGh0bWwgMy4yLy8tLy9pZXRmLy9kdGQgaHRtbCAzLy8tLy9pZXRmLy9kdGQgaHRtbCBsZXZlbCAwLy8tLy9pZXRmLy9kdGQgaHRtbCBsZXZlbCAxLy8tLy9pZXRmLy9kdGQgaHRtbCBsZXZlbCAyLy8tLy9pZXRmLy9kdGQgaHRtbCBsZXZlbCAzLy8tLy9pZXRmLy9kdGQgaHRtbCBzdHJpY3QgbGV2ZWwgMC8vLS8vaWV0Zi8vZHRkIGh0bWwgc3RyaWN0IGxldmVsIDEvLy0vL2lldGYvL2R0ZCBodG1sIHN0cmljdCBsZXZlbCAyLy8tLy9pZXRmLy9kdGQgaHRtbCBzdHJpY3QgbGV2ZWwgMy8vLS8vaWV0Zi8vZHRkIGh0bWwgc3RyaWN0Ly8tLy9pZXRmLy9kdGQgaHRtbC8vLS8vbWV0cml1cy8vZHRkIG1ldHJpdXMgcHJlc2VudGF0aW9uYWwvLy0vL21pY3Jvc29mdC8vZHRkIGludGVybmV0IGV4cGxvcmVyIDIuMCBodG1sIHN0cmljdC8vLS8vbWljcm9zb2Z0Ly9kdGQgaW50ZXJuZXQgZXhwbG9yZXIgMi4wIGh0bWwvLy0vL21pY3Jvc29mdC8vZHRkIGludGVybmV0IGV4cGxvcmVyIDIuMCB0YWJsZXMvLy0vL21pY3Jvc29mdC8vZHRkIGludGVybmV0IGV4cGxvcmVyIDMuMCBodG1sIHN0cmljdC8vLS8vbWljcm9zb2Z0Ly9kdGQgaW50ZXJuZXQgZXhwbG9yZXIgMy4wIGh0bWwvLy0vL21pY3Jvc29mdC8vZHRkIGludGVybmV0IGV4cGxvcmVyIDMuMCB0YWJsZXMvLy0vL25ldHNjYXBlIGNvbW0uIGNvcnAuLy9kdGQgaHRtbC8vLS8vbmV0c2NhcGUgY29tbS4gY29ycC4vL2R0ZCBzdHJpY3QgaHRtbC8vLS8vbydyZWlsbHkgYW5kIGFzc29jaWF0ZXMvL2R0ZCBodG1sIDIuMC8vLS8vbydyZWlsbHkgYW5kIGFzc29jaWF0ZXMvL2R0ZCBodG1sIGV4dGVuZGVkIDEuMC8vLS8vbydyZWlsbHkgYW5kIGFzc29jaWF0ZXMvL2R0ZCBodG1sIGV4dGVuZGVkIHJlbGF4ZWQgMS4wLy8tLy9zb2Z0cXVhZCBzb2Z0d2FyZS8vZHRkIGhvdG1ldGFsIHBybyA2LjA6OjE5OTkwNjAxOjpleHRlbnNpb25zIHRvIGh0bWwgNC4wLy8tLy9zb2Z0cXVhZC8vZHRkIGhvdG1ldGFsIHBybyA0LjA6OjE5OTcxMDEwOjpleHRlbnNpb25zIHRvIGh0bWwgNC4wLy8tLy9zcHlnbGFzcy8vZHRkIGh0bWwgMi4wIGV4dGVuZGVkLy8tLy9zcS8vZHRkIGh0bWwgMi4wIGhvdG1ldGFsICsgZXh0ZW5zaW9ucy8vLS8vc3VuIG1pY3Jvc3lzdGVtcyBjb3JwLi8vZHRkIGhvdGphdmEgaHRtbC8vLS8vc3VuIG1pY3Jvc3lzdGVtcyBjb3JwLi8vZHRkIGhvdGphdmEgc3RyaWN0IGh0bWwvLy0vL3czYy8vZHRkIGh0bWwgMyAxOTk1LTAzLTI0Ly8tLy93M2MvL2R0ZCBodG1sIDMuMiBkcmFmdC8vLS8vdzNjLy9kdGQgaHRtbCAzLjIgZmluYWwvLy0vL3czYy8vZHRkIGh0bWwgMy4yLy8tLy93M2MvL2R0ZCBodG1sIDMuMnMgZHJhZnQvLy0vL3czYy8vZHRkIGh0bWwgNC4wIGZyYW1lc2V0Ly8tLy93M2MvL2R0ZCBodG1sIDQuMCB0cmFuc2l0aW9uYWwvLy0vL3czYy8vZHRkIGh0bWwgZXhwZXJpbWVudGFsIDE5OTYwNzEyLy8tLy93M2MvL2R0ZCBodG1sIGV4cGVyaW1lbnRhbCA5NzA0MjEvLy0vL3czYy8vZHRkIHczIGh0bWwvLy0vL3czby8vZHRkIHczIGh0bWwgMy4wLy8tLy93ZWJ0ZWNocy8vZHRkIG1vemlsbGEgaHRtbCAyLjAvLy0vL3dlYnRlY2hzLy9kdGQgbW96aWxsYSBodG1sLy8AAOQyEAA0AAAAGDMQACoAAABCMxAAHwAAAGEzEAAfAAAAgDMQACYAAACmMxAAJgAAAMwzEAAeAAAA6jMQABcAAAABNBAAGAAAABk0EAAXAAAAMDQQAB0AAABNNBAAFwAAAGQ0EAAVAAAAeTQQABsAAACUNBAAGwAAAK80EAAbAAAAyjQQABsAAADlNBAAIgAAAAc1EAAiAAAAKTUQACIAAABLNRAAIgAAAG01EAAaAAAAhzUQABMAAACaNRAAKAAAAMI1EAA1AAAA9zUQAC4AAAAlNhAAMAAAAFU2EAA1AAAAijYQAC4AAAC4NhAAMAAAAOg2EAAjAAAACzcQACoAAAA1NxAAKgAAAF83EAAzAAAAkjcQADsAAADNNxAATgAAABs4EABFAAAAYDgQACQAAACEOBAAKwAAAK84EAAtAAAA3DgQADQAAAAQORAAHwAAAC85EAAcAAAASzkQABwAAABnORAAFgAAAH05EAAdAAAAmjkQAB8AAAC5ORAAIwAAANw5EAAoAAAABDoQACYAAAAqOhAAFQAAAD86EAAZAAAAWDoQACMAAAB7OhAAHwAAAC0vL3czby8vZHRkIHczIGh0bWwgc3RyaWN0IDMuMC8vZW4vLy0vdzNjL2R0ZCBodG1sIDQuMCB0cmFuc2l0aW9uYWwvZW5odHRwOi8vd3d3LmlibS5jb20vZGF0YS9kdGQvdjExL2libXhodG1sMS10cmFuc2l0aW9uYWwuZHRkLS8vdzNjLy9kdGQgeGh0bWwgMS4wIGZyYW1lc2V0Ly8tLy93M2MvL2R0ZCB4aHRtbCAxLjAgdHJhbnNpdGlvbmFsLy8tLy93M2MvL2R0ZCBodG1sIDQuMDEgZnJhbWVzZXQvLy0vL3czYy8vZHRkIGh0bWwgNC4wMSB0cmFuc2l0aW9uYWwvLy0vL1czQy8vRFREIEhUTUwgNC4wLy9FTmh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy1odG1sNDAvc3RyaWN0LmR0ZC0vL1czQy8vRFREIEhUTUwgNC4wMS8vRU5odHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNC9zdHJpY3QuZHRkLS8vVzNDLy9EVEQgWEhUTUwgMS4wIFN0cmljdC8vRU5odHRwOi8vd3d3LnczLm9yZy9UUi94aHRtbDEvRFREL3hodG1sMS1zdHJpY3QuZHRkLS8vVzNDLy9EVEQgWEhUTUwgMS4xLy9FTmh0dHA6Ly93d3cudzMub3JnL1RSL3hodG1sMTEvRFREL3hodG1sMTEuZHRkYWJvdXQ6bGVnYWN5LWNvbXBhdEluZGV4IG91dCBvZiBib3VuZHN9PhAAEwAAAC9ydXN0Yy85MGM1NDE4MDZmMjNhMTI3MDAyZGU1YjQwMzhiZTczMWJhMTQ1OGNhL2xpYnJhcnkvY29yZS9zcmMvc2xpY2Uvc29ydC5ycwAAmD4QAE4AAADGBAAADQAAAJg+EABOAAAA0wQAABgAAACYPhAATgAAANQEAAAZAAAAmD4QAE4AAADVBAAAJAAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUAmD4QAE4AAAAZBQAAQAAAAJg+EABOAAAAPwUAAE4AAACYPhAATgAAAE0FAABWAAAAYXNzZXJ0aW9uIGZhaWxlZDogZW5kID49IHN0YXJ0ICYmIGVuZCA8PSBsZW6YPhAATgAAALkFAAAFAAAAmD4QAE4AAADKBQAAKAAAAGFzc2VydGlvbiBmYWlsZWQ6IG9mZnNldCAhPSAwICYmIG9mZnNldCA8PSBsZW4AAJg+EABOAAAAmwAAAAUAAABzdGF0aWNpbmxpbmVkeW5hbWljQXRvbSgnJyB0eXBlPSkAAAAjQBAABgAAAClAEAAHAAAAMEAQAAEAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi90ZW5kcmlsLTAuNC4yL3NyYy9idWYzMi5yc0xAEABcAAAAHQAAAC4AAABEb2N0eXBlbmFtZQBFAAAAEAAAAAQAAABGAAAAcHVibGljX2lkc3lzdGVtX2lkZm9yY2VfcXVpcmtzAABHAAAABAAAAAQAAABIAAAARW5kVGFnU3RhcnRUYWdUYWdraW5kAAAARwAAAAEAAAABAAAASQAAAEoAAAAIAAAACAAAAEsAAABzZWxmX2Nsb3NpbmdHAAAAAQAAAAEAAABMAAAAYXR0cnMAAABHAAAABAAAAAQAAABNAAAARG91YmxlRXNjYXBlZEVzY2FwZWRTeXN0ZW1QdWJsaWNTY3JpcHREYXRhRXNjYXBlZAAAAE4AAAAEAAAABAAAAE8AAABTY3JpcHREYXRhUmF3dGV4dFJjZGF0YURvdWJsZVF1b3RlZFNpbmdsZVF1b3RlZFVucXVvdGVkQ2RhdGFTZWN0aW9uRW5kQ2RhdGFTZWN0aW9uQnJhY2tldENkYXRhU2VjdGlvbkJvZ3VzRG9jdHlwZUJldHdlZW5Eb2N0eXBlUHVibGljQW5kU3lzdGVtSWRlbnRpZmllcnNBZnRlckRvY3R5cGVJZGVudGlmaWVyAE4AAAAEAAAABAAAAFAAAABEb2N0eXBlSWRlbnRpZmllclNpbmdsZVF1b3RlZERvY3R5cGVJZGVudGlmaWVyRG91YmxlUXVvdGVkQmVmb3JlRG9jdHlwZUlkZW50aWZpZXJBZnRlckRvY3R5cGVLZXl3b3JkQWZ0ZXJEb2N0eXBlTmFtZURvY3R5cGVOYW1lQmVmb3JlRG9jdHlwZU5hbWVEb2N0eXBlQ29tbWVudEVuZEJhbmdDb21tZW50RW5kQ29tbWVudEVuZERhc2hDb21tZW50Q29tbWVudFN0YXJ0RGFzaENvbW1lbnRTdGFydE1hcmt1cERlY2xhcmF0aW9uT3BlbkJvZ3VzQ29tbWVudFNlbGZDbG9zaW5nU3RhcnRUYWdBZnRlckF0dHJpYnV0ZVZhbHVlUXVvdGVkQXR0cmlidXRlVmFsdWUATgAAAAQAAAAEAAAAUQAAAEJlZm9yZUF0dHJpYnV0ZVZhbHVlQWZ0ZXJBdHRyaWJ1dGVOYW1lQXR0cmlidXRlTmFtZUJlZm9yZUF0dHJpYnV0ZU5hbWVTY3JpcHREYXRhRG91YmxlRXNjYXBlRW5kU2NyaXB0RGF0YUVzY2FwZWREYXNoRGFzaFNjcmlwdERhdGFFc2NhcGVkRGFzaFNjcmlwdERhdGFFc2NhcGVTdGFydERhc2hTY3JpcHREYXRhRXNjYXBlU3RhcnRSYXdFbmRUYWdOYW1lTgAAAAQAAAAEAAAAUgAAAFJhd0VuZFRhZ09wZW5SYXdMZXNzVGhhblNpZ25SYXdEYXRhVGFnTmFtZUVuZFRhZ09wZW5UYWdPcGVuUGxhaW50ZXh0RGF0YQgAAAAMAAAADAAAAONBEADXQRAAy0EQAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3N0cmluZ19jYWNoZS0wLjguMi9zcmMvYXRvbS5yc/hEEABgAAAABwEAAB8AAAD4RBAAYAAAAAUBAAAvAAAAL3J1c3RjLzkwYzU0MTgwNmYyM2ExMjcwMDJkZTViNDAzOGJlNzMxYmExNDU4Y2EvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAAHhFEABKAAAAkgAAABEAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi90ZW5kcmlsLTAuNC4yL3NyYy90ZW5kcmlsLnJzAADURRAAXgAAAFcAAAA1AAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvdGVuZHJpbC0wLjQuMi9zcmMvYnVmMzIucnNERhAAXAAAAB0AAAAuAAAAQWZ0ZXJBZnRlckZyYW1lc2V0QWZ0ZXJBZnRlckJvZHlBZnRlckZyYW1lc2V0SW5GcmFtZXNldEFmdGVyQm9keUluVGVtcGxhdGVJblNlbGVjdEluVGFibGVJblNlbGVjdEluQ2VsbEluUm93SW5UYWJsZUJvZHlJbkNvbHVtbkdyb3VwSW5DYXB0aW9uSW5UYWJsZVRleHRJblRhYmxlVGV4dEluQm9keUFmdGVySGVhZEluSGVhZE5vc2NyaXB0SW5IZWFkQmVmb3JlSGVhZEJlZm9yZUh0bWxJbml0aWFsTm90V2hpdGVzcGFjZVdoaXRlc3BhY2VOb3RTcGxpdEVPRlRva2VuTnVsbENoYXJhY3RlclRva2VuQ2hhcmFjdGVyVG9rZW5z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AAAABQAAAAEAAABMAAAAAAAAAAABAAANAAAAggEAAAAAAACYAAAAAAAAAAIAAAAAAAAAHAAAAAAAAACPAAAAAAAAAFUCAAABAAAAeAIAAAIAAACuAAAAAAAAAAMAAAAAAAAA7gAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEgAAAAAAAAADAAAAAAAAAI0AAAAEAAAAowEAAAAAAAAAAAAAAAAAAJwAAAAIAAAAXwAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAUQQAAAAAAAASAwAABQAAAB4AAAAAAAAAEwAAAAIAAAAvAQAAAAAAAGsAAAABAAAAFAEAAAAAAAABAAAAAAAAAFUDAAADAAAAjgAAAA4AAAC1AQAAAAAAAAACAAAAAAAAAQAAAG9uZHJhZ2VuZG5vbmVvbmtleXByZXNzY29udGVudFNjcmlwdFR5cGVjb250ZW50ZmVwb2ludGxpZ2h0cHJlc3RhcnRPZmZzZXRhcmlhLXByZXNzZWR2aWV3VGFyZ2V0YWRkaXRpdmVxYmdjb2xvcm5lcWxjbWZsb29kLWNvbG9yaWRmcmFtZWRpc3BsYXlhbmltYXRlQ29sb3JhbHBoYWJldGljYXJpYS1yZWFkb25seWV4cG1pKmZlTWVyZ2Vvbmxvc2VjYXB0dXJlb3RoZXJ3aXNlbWFza3VuaXRzeGxpbms6YWN0dWF0ZW1hbmlmZXN0ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZHVsc2VwYXJhdG9ycnRjcG9seWdvbmZpbGwtb3BhY2l0eXpvb21BbmRQYW5zY3JvbGxpbmd1cG9pbnRlci1ldmVudHNmb3JtYXRhY3R1YXRlbGltaXRpbmdDb25lQW5nbGVmb250LWZhY2V0Ym9keW9uYmVmb3JlY29weXJvd3NwYWNpbmd0aGlubWF0aHNwYWNlbWF0aGVtYXRpY2FscGF0dGVybnVuaXRzb25lcnJvcnN0cm9rZS1saW5lam9pbmFsaWdubWVudHNjb3BldW5pb25oZWFkc2l6ZXNjb2xzYWN0aW9ucG9seWxpbmVzcGVlZG5vYnJ0ZW1wbGF0ZWcxaGFuZGxlcmZlc3BlY3VsYXJsaWdodGluZ2FyaWEtZXhwYW5kZWRjbGlwcGF0aGxlcXhsaW5rOnJvbGVmaWVsZHNldGFsdEdseXBoSXRlbWJib3h0YW5yZXF1aXJlZGZlYXR1cmVzb25kcmFnZHJvcGNsYXNzaWRkaXJlY3Rpb25vbmRyYWdsZWF2ZXNlY3Rpb25nbHlwaGFyaWEtc2V0c2l6ZWdyb3VwYWxpZ25rZXJuaW5nc3Ryb2tlLW1pdGVybGltaXRhcmNzZWNjb2RldHlwZWxpbmtyZWxvbnBhZ2VzaG93cmVsbmFyY2NvdGZsb29ya2V5VGltZXNjaGFycmVwZWF0Y291bnRyZXBlYXQtbWluZmVtZXJnZW5vZGVhc2lkZWNvbHVtbmFsaWdub25iZWZvcmVlZGl0Zm9jdXNvbmZpbmlzaGVsZXZhdGlvbm9ucmVzaXplc3Ryb2tlLXdpZHRoYXJpYS1pbnZhbGlkcHJlc2VydmVhc3BlY3RyYXRpb21heHBhcnRpYWxkaWZmc3RhcnRvZmZzZXRpc2luZGV4b25tb3VzZWRvd25vbmRhdGFzZXRjaGFuZ2VkeG1sOmJhc2VrMXN0cmluZ3N1YmRlZmluaXRpb25VUkxhcmFiaWMtZm9ybWlmcmFtZXN0ZW12c2NyaXB0Ymlhc2hvcml6LWFkdi14c3RvcC1jb2xvcmF0dHJpYnV0ZU5hbWVmb3JlaWdub2JqZWN0aXRlbXByb3BnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbGNvZGVmbG9vZC1vcGFjaXR5cmF0aW9uYWxzZmVDb21wb25lbnRUcmFuc2ZlcnRleHRwYXRoeGxpbms6dGl0bGVzaGFwZW1hcGNoYXJzZXR0YXJnZXR5b25kYmxjbGlja21wYXRob25kcmFnc3RhcnRoaWRlZm9jdXNlZGdlbW9kZW1nbHlwaG5vbmNlcmFkaWFsR3JhZGllbnRhbm5vdGF0aW9uLXhtbG1wYWRkZWRncmFkaWVudFRyYW5zZm9ybWZlZnVuY2FvbmZvY3Vzb3V0b25jaGFuZ2V2a2Vybm5vdHByc3Vic2V0Zm9udC13ZWlnaHRtYXRoc2l6ZWNvbG9yLWludGVycG9sYXRpb25zZWNocmVmZXJyZXJwb2xpY3lyZWFkb25seXBvaW50c2FjY2VwdC1jaGFyc2V0Zm9udC1zaXplY2FyZHJ0dW5pY29kZS1yYW5nZXBhdGhnY2RtYXJnaW5oZWlnaHRrZXlwb2ludHNoMmFjdGlvbnR5cGVyZXF1aXJlZEZlYXR1cmVzcnVsZWFyaWEtY2hlY2tlZGNsaXBwYXRodW5pdHNzcmNkb2NkaXNwbGF5c3R5bGVtdWx0aXBsZXZlcnNpb25udW1PY3RhdmVzbWF0cml4cm93b2Zmc2V0bWFya3ByaW1lc3N0cm9rZS1vcGFjaXR5aHJlZm1zcGFjZW9uYmx1cmJnc291bmRvbm1vdXNld2hlZWxtb2xhcmdlb3ByZXN1bHRhemltdXRoYWxpbmtzdG9wYXJpYS1idXN5Zm9udHdlaWdodHNwcmVhZG1ldGhvZGJldmVsbGVkeG1sOmxhbmdwb2ludHNBdFhhcmN0YW5ocnF1b3Rlb25tb3VzZW92ZXJjdXJzb3JzdXBlcnNjcmlwdHNoaWZ0Y29sdW1ubGluZXNmb250ZmFtaWx5eGxpbmtjbGlwLXBhdGhtYXNrc3VwdmFsdWVzcGFjaW5nZmVkcm9wc2hhZG93Zm9ybWFjdGlvbm9uY29udGV4dG1lbnV0b2dnbGVmaWdjYXB0aW9uc2VlZHBvaW50c2F0eWlkZW50bmFyZ3N2bGlua2FjY2VudGl0ZW1yZWZzaG93Y2hhcm9mZmhvcml6LW9yaWdpbi14ZWRnZU1vZGVzZW1hbnRpY3NhY2NlcHRsb2dhcmlhLWF0b21pY3NjYWxldW5pY29kZS1iaWRpb3JkZXJrYXJjcm9sZWRpdmlzb3JoYW5naW5nc2RldmF4aXNkb21pbmFudC1iYXNlbGluZWVuYWJsZS1iYWNrZ3JvdW5kb25sYW5ndWFnZWNoYW5nZXRyYWNrbm90c3Vic2V0cG9pbnRzQXRZbWVhbmZpbGxmZUNvbnZvbHZlTWF0cml4c3R5bGV0b290aGVydHJhbnNsYXRlbG9jYWxzYW1weGNoYW5uZWxzZWxlY3RvcnNwYWNlZXF1YWxyb3dzc3RpdGNoVGlsZXNmZWZsb29kZG5vdGFudW1iZXJtYXJrZXJIZWlnaHRsaW5ldGhpY2tuZXNzZGlzY2FyZGFsdEdseXBoRGVmdGFibGV2YWx1ZXNwcmltaXRpdmV1bml0c2ZlbmNlaW5maW5pdHlrZXJuZWx1bml0bGVuZ3RobGluZS1oZWlnaHR0YXJnZXRYYXJpYS1tdWx0aXNlbGVjdGFibGVjZWxscGFkZGluZ2RhdGFmb3JtYXRhc2tlcm5lbFVuaXRMZW5ndGhnZXFhbHRHbHlwaGVtYmVkcGF0dGVybkNvbnRlbnRVbml0c2FyY2NvdGhwcm9ncmVzc21mcmFjc3Ryb2tlYmFzZWxpbmVmb3JhbGxmZUZ1bmNHYW5pbWF0aW9ubm92YWxpZGF0ZXJ1bGVzc3JjaXRlbXNjb3Blb25iZWZvcmVhY3RpdmF0ZWJkaWZldHVyYnVsZW5jZWdseXBoUmVmY3NjbmFtZXNpbmNvbHNwYW5iYXNlb25iZWZvcmVwcmludHNvdXJjZWxvd2hzcGFjZXRpdGxlc2NyaXB0bGV2ZWxvbmN1dHJldmVyc2VkdGJyZWFrc2V0bWFya2VyLXN0YXJ0ZW5jdHlwZW1ldGFkYXRheENoYW5uZWxTZWxlY3Rvcm1vZGVzZXBhcmF0b3Jzb25pbnZhbGlkaDZjb25qdWdhdGVyZXF1aXJlZEV4dGVuc2lvbnNtdW5kZXJvdmVyaDVtZXRob2RtYXRoY29sb3JkaXZlcmdlbmNlZmFsc2VzcGVjaWZpY2F0aW9ub25yZWFkeXN0YXRlY2hhbmdlZG9tYWlub2ZhcHBsaWNhdGlvbm1hdGhiYWNrZ3JvdW5ka2VybmVsTWF0cml4bmF0dXJhbG51bWJlcnNkZXB0aHNjYWxhcnByb2R1Y3RvcGVyYXRvcmNsYXNzcG9pbnRzQXRaY29vcmRzYm9yZGVydGV4dGxlbmd0aHNjcmlwdHNpemVtdWx0aXBsaWVyb25zdG9yYWdlYXJpYS1jb250cm9sc29ucHJvcGVydHljaGFuZ2VpbWFnZXByb2R1Y3RjYW52YXNwcm9tcHRmZXRpbGVvbmZvcm1jaGFuZ2VhbmltYXRlbW90aW9ubWF4c2l6ZWFyaWEtbGl2ZWxpbWl0Zm9ybXRhcmdldGVxdWFsY29sdW1uc3JlY3RmZWNvbXBvbmVudHRyYW5zZmVyZmVEaXNwbGFjZW1lbnRNYXBkZWdyZWVvbmJlZm9yZGVhY3RpdmF0ZWJhc2VGcmVxdWVuY3lkeWN1cmxiYXNlbGluZS1zaGlmdGNsaXBhYXJpYS1kcm9wZWZmZWN0eGxpbms6dHlwZW9ubG9hZHJlZlhwcnN1YnNldHByZXNlcnZlYWxwaGFpbnB1dG1vZGVrNGdyYWRpZW50dW5pdHNhcmlhLXZhbHVlbWF4bG5hY3JvbnltYXJ0aWNsZXRzcGFuZmVibGVuZGNvbG9yLXByb2ZpbGVmb3JhcmlhLWRhdGF0eXBldmVydC1hZHYteW1zcXJ0dGhpY2ttYXRoc3BhY2Vtb21lbnRtaXNzaW5nLWdseXBodGRmb3Jtbm92YWxpZGF0ZWZvcm1mb250c2l6ZW1hc2tjb250ZW50dW5pdHNmb3JtbWV0aG9kYXJjY29zaG9ucGFzdGVpbnRlcnZhbG10ZHRhYmluZGV4YXJpYS1ncmFic3JjbGFuZ210YWJsZXJlcGVhdGNvbG9yLXJlbmRlcmluZ2ZvbnRzdHlsZWF0dHJpYnV0ZVR5cGVleHBvbmVudHBhdHRlcm5vbmRyYWdlbnRlcmFyaWEtdmFsdWVtaW5tb21lbnRhYm91dGRhdGV0aW1lc3ZndmFyaWFuY2VmZU9mZnNldG9uZXJyb3J1cGRhdGVkb3dubG9hZGFyY2hpdmVmeGV4aXN0c3N0ZXBidXR0b25tdGV4dGZlQ29tcG9zaXRlZGVmYXVsdHN0ZW1obWVudWl0ZW1mb250LXZhcmlhbnRvbmNvbnRyb2xzZWxlY3R0YWJsZXByb3BlcnR5Zm9udC1mYWNlLXVyaWljb252ZXJ0LW9yaWdpbi15b25oYXNoY2hhbmdleDJvbmtleWRvd25saW5lYnJlYWtyb290aXRlbXR5cGV0aW1lc3VyZmFjZXNjYWxlbGFtYmRhc3Jjc2V0Znlob3Jpei1vcmlnaW4teWNvZGViYXNldi1hbHBoYWJldGljYXJlYWFyaWEtbXVsdGlsaW5lcmVwZWF0LW1heGFic29uZW5kZm9vdGVydmVydC1vcmlnaW4teHRleHQtZGVjb3JhdGlvbmFiYnJtb3ZlcnRhcmdldHByaW1pdGl2ZVVuaXRzZmVmdW5jYnRleHQtYW5jaG9ybm9yZXNpemV4bWxuczp4bGlua2NlbnRlcmZvbnRtc2ZuazNwaWVjZWVsbGlwc2VyZWFsc25vZW1iZWRlbXB0eXNldGZlQmxlbmRycHdpZHRoc3htbG5zdGV4dExlbmd0aGVxdW5pdHMtcGVyLWVtYmFzZVByb2ZpbGVkYXRhdGVtcGxhdGViYXNlZm9udGRpZmZkeHR5cGVhcmlhLWNoYW5uZWxzeXN0ZW1sYW5ndWFnZXJlZnlyZWZ4YWx0aW1nZGlhbG9nb25zY3JvbGxhcmlhLXNlbGVjdGVkdmVjdG9ycnlwYXR0ZXJudHJhbnNmb3JtZm9udC1zaXplLWFkanVzdHRhcmdldHhtcm93cmVwZWF0Q291bnRhbHR0ZXh0bGVuZ3RoYWRqdXN0dmVyeXRoaW5tYXRoc3BhY2VtaW5sZW5ndGhtYXJrZXItZW5kZGF0YWZsZHBhcnNlY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzbmF2aGVpZ2h0cHJlZmV0Y2h3cml0aW5nLW1vZGVhcmlhLWRlc2NyaWJlZGJ5cGF0dGVybmNvbnRlbnR1bml0c2Rpcm5hbWV1MnhtbDpzcGFjZWRldGFpbHNuZXN0b25rZXl1cG11dGVkb25kcmFnb25pbnB1dG9uc2VsZWN0YWx0aHR0cC1lcXVpdmFjY2VudC1oZWlnaHRjb250cm9sbGVyY2hhbmdlY2VsbHNwYWNpbmdwYXRobGVuZ3RoYmFja2dyb3VuZGFyaWEtc29ydGZyYW1lYm9yZGVyZ3JhZGllbnR0cmFuc2Zvcm12ZWN0b3Jwcm9kdWN0Zm9udC1mYW1pbHlhcmlhLWhpZGRlbmFsaWdubWVudC1iYXNlbGluZWhpZGRlbmZpbHRlcnVuaXRzc2NyaXB0bWluc2l6ZXVzZW5vc2NyaXB0c3RyZXRjaHl2LW1hdGhlbWF0aWNhbGNvbXBsZXhlc2FyaWEtbGFiZWxsZWRieXJvd2FsaWducGljdHVyZXByZXNlcnZlQWxwaGFhcmlhLXJlcXVpcmVkeTJ1bnNlbGVjdGFibGVjb250ZW50ZWRpdGFibGV6c3RvcC1vcGFjaXR5b25tZXNzYWdlbHRmYWN0b3JpYWxmaWd1cmVsb29wY2FwLWhlaWdodGN5eHJlZmZlZGlmZnVzZWxpZ2h0aW5nb25hY3RpdmF0ZWxpc3Rpbmdvbm1vdXNlbW92ZWR0b3B0aW11bWZlRHJvcFNoYWRvd2ZpbHRlcnNtYWxsb25vZmZsaW5lcGFub3NlLTFtYXJxdWVlem9vbWFuZHBhbm1uYWRkcmVzc21hdGh4MW9uaGVscHdoZW5vcmFyaWEtdmFsdWVub3dhY2Nlc3NrZXlkZXNjZW50di1pZGVvZ3JhcGhpY2lycmVsZXZhbnRjaGVja2Vkb25iZWZvcmVwYXN0ZXRyYW5zZm9ybW5vZnJhbWVzY29zaG10cmZlSW1hZ2Vjb250ZXh0bWVudXZhbGlnbmdseXBoLW5hbWVvbmJlZm9yZXVwZGF0ZXNwZWN1bGFyY29uc3RhbnRkZWxhcmlhLW93bnNmZVNwZWN1bGFyTGlnaHRpbmd0aGVhZG9ubW92ZWVuZG1lbmNsb3NlbWFyZ2lud2lkdGh3b3JkLXNwYWNpbmdvYmplY3Rsb2diYXNlbWxhYmVsZWR0cmFuaW1hdGVNb3Rpb250ZXh0UGF0aGRyYWdnYWJsZWRmbnJlcXVpcmVkYXJjY29zYmlnaW50YXR0cmlidXRldHlwZWJhc2VmcmVxdWVuY3lzZXBoMWZlY29udm9sdmVtYXRyaXhsYW5naGdyb3VwZXVsZXJnYW1tYWNvc2JyZmVkaXNwbGFjZW1lbnRtYXBrZXlzcGxpbmVzd2lkdGhpbnRlcmNlcHR0ZW5kc3Rvb25zZWxlY3RzdGFydG1lcnJvcm1hY3Jvc21vemJyb3dzZXJvbmFib3J0bWF0cml4b25hZnRlcnByaW50bW92YWJsZWxpbWl0c3Ryc3Ryb2tlLWxpbmVjYXBub3RhdGlvbm9ubW91c2VlbnRlcmFubm90YXRpb25mcmFtZXNldGNyb3Nzb3JpZ2luaW52ZXJzZWhlYWRlcnNmZW1lcmdlZGF0YXNyY3NpbmhnbHlwaHJlZm9uZm9ybWlucHV0dmlzaWJpbGl0eW9uZHJhZ292ZXJzcGFjZXJvdmVybGluZS10aGlja25lc3N4b3JvbmRhdGFzZXRjb21wbGV0ZXBpbmdsZXR0ZXItc3BhY2luZ2xlbmd0aEFkanVzdHZlcnl0aGlja21hdGhzcGFjZW9ucmVwZWF0aW1ldGF2aWV3Ym94ZGVmc3JiYWxpZ25kYXRhc3ByZWFkTWV0aG9kZGVmaW5pdGlvbi1zcmNhc2NlbnR2YWx1ZXR5cGVvbnJvd2VudGVyb25zdG9wcnNwYWNlbWFya2Vyb3JpZW50YXRpb25lbmNvZGluZ3BsYWludGV4dHJlc3RhcnRzdGREZXZpYXRpb25udW1vY3RhdmVzbWFya2VydW5pdHNjbGlwUGF0aFVuaXRzc3RkZGV2aWF0aW9uY290cGFyaWEtZGlzYWJsZWRtaW5zaXplZmVTcG90TGlnaHRjZWlsaW5ncnkxZmFjdG9yb2Zic3RhdGVjaGFuZ2VrZXl0aW1lc2RpcmVuZG9wdGdyb3Vwb25yb3dzZGVsZXRlZmVnYXVzc2lhbmJsdXJsb3dsaW1pdGsyc3Ryb2tlLWRhc2hvZmZzZXR1cGxpbWl0eGxpbms6aHJlZmFuaW1hdGVUcmFuc2Zvcm1zbG9wZWZlRnVuY0Jwb2ludHNhdHh1bmRlcmxpbmUtcG9zaXRpb25ocmVmbGFuZ2NhcHRpb25tdWx0aWNvbHdicmRpc2FibGVkcXVvdGllbnRmZVRpbGV0cnVlYXJjc2luaGVxdWl2YWxlbnRmZW9mZnNldHZhbHVlc2NhbGNNb2RlYXJpYS1hY3RpdmVkZXNjZW5kYW50bWVudXhsaW5rOnNob3dzdWJzY3JpcHRzaGlmdG9ucG9wc3RhdGVhcmNzaW50ZXh0YXJlYXUxYXJpYS1zZWNyZXRrZXJuZWxtYXRyaXhvdmVybGluZS1wb3NpdGlvbm9uYmVnaW50YWJsZVZhbHVlc3Njb3BlZG9uc3VibWl0b25kcm9wbWFpbmdyYWRpZW50VW5pdHNjb2xncm91cGNhbGNtb2RlaGVhZGVyY290aGluc29uc3RhcnRpbWFnaW5hcnljb250ZW50c3R5bGV0eXBlYnZhcnZhcnJhZGlvZ3JvdXBleHBvbmVudGlhbGVvdXRwdXRrZXlQb2ludHNzZXRkaWZmb25vbmxpbmVibG9ja3F1b3RlY2l0ZWxpbmVhcmdyYWRpZW50Z2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbHBhcmFtaW50ZWdyaXR5aW1hZ2luYXJ5aW9uYm91bmNlb25tb3VzZXVwZmVjb2xvcm1hdHJpeGZlVHVyYnVsZW5jZWZpbHRlclVuaXRzcmVmWW9uY2VsbGNoYW5nZWlzbWFwZGV0ZXJtaW5hbnRub21vZHVsZXN1YnNldG1heGxlbmd0aHByZWxvYWRvbmRhdGFhdmFpbGFibGVyZXBlYXQtc3RhcnR2c3BhY2VvcGVuYXVkaW9hdHRyaWJ1dGVuYW1lZW1vbm1vdXNlbGVhdmVyYWRpdXNjbGlwLXJ1bGVvbmNsaWNrcGltc3Vic3VwYXN5bmNkb21haW5sb25nZGVzY2FyaWEtZmxvd3Rvdi1oYW5naW5nZmVkaXN0YW50bGlnaHRodG1sc3BlY3VsYXJDb25zdGFudGFsbG93ZnVsbHNjcmVlbm9ubW91c2VvdXRscXVvdGVhcHBseWhyYW1wbGl0dWRlZmVQb2ludExpZ2h0cG93ZXJhcmlhLXJlbGV2YW50cmVhbHJldmZlTWVyZ2VOb2RlZGVjbGFyZWFsdGdseXBoY2xvc2Vjb2xzdGFuZGJ5cmVwbGFjZWNvbHVtbnNwYW5pbjJtdW5kZXJkaWZmdXNlY29uc3RhbnRwb2ludHNhdHpvbm1vdmVtcm9vdHNwZWxsY2hlY2tzdXJmYWNlU2NhbGVldmVudHJvbGVoa2VybnJlcGVhdGR1cm1hbGlnbm1hcmthcmNjc2NzdW1tYXJ5a2V5U3BsaW5lc2JlZ2luY29udHJvbHNzbG90c2VsZWN0aW9uc3Ryb2tlLWRhc2hhcnJheWNvbmRpdGlvbmNvbG9ybWV0ZXJ2ZXJ5dmVyeXRoaWNrbWF0aHNwYWNlbGl1bmljb2Rlb25yZXNldGFyaWEtYXV0b2NvbXBsZXRlbGVnZW5kb25iZWZvcmVjdXRwbGFjZWhvbGRlcm1zdWJtZWRpYWFyZ2ZvbnQtc3RyZXRjaG5vaHJlZnVuZGVybGluZS10aGlja25lc3NkZWZpbml0aW9udXJscGF0dGVyblRyYW5zZm9ybWNvbHVtbndpZHRobG93c3Jjc2NoZW1lZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZG9ubW92ZXN0YXJ0b3B0aW9ucnVieXJvd2xpbmVzb25yb3dleGl0b2xvcmlnaW50YXJnZXRZaW5kZXhhcmNjc2NoZm9udC1mYWNlLW5hbWVzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc3ZpZXdkZXNjdmVyeXZlcnl0aGlubWF0aHNwYWNlcmVwZWF0RHVyZzJ0YW5oZHVybWFjdGlvbmxhYmVsdXNlbWFwZmVmdW5jcmludGVyc2VjdG1hbGlnbmdyb3Vwc2VsZWN0b3JiZG9mZWNvbXBvc2l0ZXNvbGlkY29sb3JjeG9uZmlsdGVyY2hhbmdlaW5pdGVtaWRtZWRpYW50Zm9vdGFyaWEtcG9zaW5zZXRyb3dzZGl2aWRlc3RpdGNodGlsZXNmb250LWZhY2Utc3Jjc3BhbmxpbmVhckdyYWRpZW50dHJlZm9wYWNpdHlsaXN0c3Ryb25nbWluZGRsaWdodGluZy1jb2xvcmJ5bWFza1VuaXRzbW11bHRpc2NyaXB0c2ZlQ29sb3JNYXRyaXhyeHhsaW5rOmFyY3JvbGVwYXRoTGVuZ3Rob25mb2N1c3RoYXJpYS1sZXZlbGNvbXBhY3RzdGFydG9udW5sb2FkYXV0b3N1Ym1pdGxhcGxhY2lhbmltYWdlLXJlbmRlcmluZ2d0aW5wdXRjb21wb3NlY2lvbmZvY3VzaW5nb3V0ZXJwcm9kdWN0dmlld0JveG1hcmtlclVuaXRzc2hhcGUtcmVuZGVyaW5nZm9udC1mYWNlLWZvcm1hdGJvZHlkaXZtYXJrZXJ3aWR0aGNsZWFyc3lzdGVtTGFuZ3VhZ2VyZXBlYXQtdGVtcGxhdGVtcHJlc2NyaXB0c2ltcGxpZXNzY3JvbGxkZWxheWFuaW1hdGV0cmFuc2Zvcm1hdXRvY29tcGxldGVjc3ltYm9sY29udGVudHNjcmlwdHR5cGV5c3RyaWtlbGluZXN1bWRlY29kaW5nZmVGbG9vZGZlRGlmZnVzZUxpZ2h0aW5na2JkZmVtb3JwaG9sb2d5Y25yZXF1aXJlZGV4dGVuc2lvbnNjbGlwUGF0aG5vdG1hcmtlci1taWRvbmFmdGVydXBkYXRlbm90aW5sYW5ndWFnZW1hcmtlcmhlaWdodGZlZnVuY2dmZUZ1bmNSd3JhcHRleHQtcmVuZGVyaW5nYXJjdGFuYXJpYS10ZW1wbGF0ZWlkYmFzZXByb2ZpbGV2aWRlb3Byb2ZpbGVzdHJpa2V0aHJvdWdoLXBvc2l0aW9ubXN1cHR0cmFkaWFsZ3JhZGllbnRzZWxlY3RlZGdyYWRub3NoYWRlc3BlY3VsYXJFeHBvbmVudGFuaW1hdGVhY3RpdmVtYXRodmFyaWFudG9uYmVmb3JldW5sb2FkdHJhbnNwb3NleWNoYW5uZWxzZWxlY3RvcnNhbmRib3hyb3RhdGVvbmRlYWN0aXZhdGVraW5kZmV0Y2hjb2x1bW5zcGFjaW5nYmxpbmtzZWNtc3R5bGVmZURpc3RhbnRMaWdodGF1dG9wbGF5b25yb3dzaW5zZXJ0ZWRtZmVuY2VkZmVpbWFnZXhtcHJlbmRlcmluZy1pbnRlbnRkaWZmdXNlQ29uc3RhbnRhY2N1bXVsYXRlbmV4dGlkc2NvcGV5Q2hhbm5lbFNlbGVjdG9yYWNjZW50dW5kZXJvbnBhZ2VoaWRlYWx0Z2x5cGhpdGVtc2VhbWxlc3Njb250ZW50U3R5bGVUeXBlY29kb21haW5tYXNrQ29udGVudFVuaXRzY2FydGVzaWFucHJvZHVjdG1waGFudG9tbWludXNzcGVjdWxhcmV4cG9uZW50YXV0b2ZvY3VzY2lyY2xlc2l6ZWRlZmVycmVtcGllY2V3aXNlcGx1c2Nsb3N1cmVhbmltYXRlY29sb3JvY2N1cnJlbmNlZnJvbWgzYW5kc3dpdGNoZmVHYXVzc2lhbkJsdXJkYXRhbGlzdGZvbnQtc3R5bGVhcHBsZXRkbG9uem9vbXgtaGVpZ2h0ZnJhbWVzcGFjaW5nbGltaXRpbmdjb25lYW5nbGVmZXNwb3RsaWdodHBhdHRlcm5Vbml0c21lZGl1bW1hdGhzcGFjZWltZ2VkZ2VvdmVyZmxvd2ZpbGwtcnVsZW9yaWVudHN2aWV3dGFyZ2V0aWRlb2dyYXBoaWNsaXN0ZW5lcmg0cG9zdGVyZmFjZW5vd3JhcGZpbHRlclJlc2FyY3NlY2hwcmVzZXJ2ZUFzcGVjdFJhdGlvZmVGdW5jQWludGVnZXJzbHNwYWNldGltZXNrZXlnZW5hcmlhLWhhc3BvcHVwcm93c3BhbmFsdGdseXBoZGVmZm9ybWVuY3R5cGVmaWx0ZXJyZXN4Zm9yZWlnbk9iamVjdHN5bWJvbHN5bW1ldHJpY29uY29weWNzY2hzZWxlY3R0ZXh0YXBwcm94aGlnaGZlTW9ycGhvbG9neW1hcmtlcldpZHRoCFAQAAkAAAARUBAABAAAABVQEAAKAAAAH1AQABEAAAAwUBAABwAAADdQEAAMAAAAQ1AQAAMAAABGUBAACwAAAFFQEAAMAAAAXVAQAAoAAABnUBAACAAAAG9QEAABAAAAcFAQAAcAAAB3UBAAAwAAAHpQEAADAAAAfVAQAAsAAACIUBAAAgAAAIpQEAAFAAAAj1AQAAcAAACWUBAADAAAAKJQEAAKAAAArFAQAA0AAAC5UBAAAwAAALxQEAACAAAAvlAQAAEAAAC/UBAABwAAAMZQEAANAAAA01AQAAkAAADcUBAACQAAAOVQEAANAAAA8lAQAAgAAAD6UBAAGQAAABNREAACAAAAFVEQAAkAAAAeURAAAwAAACFREAAH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b3RDb25ncnVMZXNzU2xhbnRFcXVheGk7bHRyaWU7YXJpbmc7TnNja29DaXJjbGVEb3Q7bGF0O25vdG5pTnRpbGRlbWFwO3N3bndhclNob3J0UmlnaHRBcnZCYXJ2cnBwb2xpbnN3QXJDYXBpdGFsRENpcmNsZVRpbWxwYU5vdFRpbExhckRvdWJsZVZlcnRpY2FsQmFjY2VkaXNlYVNxdWFyZUludGVyc2VjdGlzaW1lcXR3b2hlYWRiYXJ2ZURTY3lMYW1iZGE7Tm90VGlsZGVUaWxyaWdodHJpZ2h0dWNpcmM7Q2xvc2VDdXJseVF1b3RlO0NvdW50ZXJibGFja3RyaWFuZ2xlbFVuZGVyQmFhbmdydHZiO3VkYmxhY2JvcHJpZ2h0bGVmdGFybnJpZ2h0YWF3aXJicmtlcGhpdjtsZWZ0cmlnaHRhcnJvd3M7Z3RyZXFsaW9wQW1Eb3duVGVlb2d0aW1lc2Jhck5vdEVsZW1jaXJjZW1lYXN1cmVkYW9taW51cztTdXBlcnNUaWxkZUZ1bGxFcXVhbDtucHJlTm90VmVydGljYWxCU2NpcmM7aXNpbnN2dGNhcm9uO0FhY2hlY2ttYXJrO3dwO0Rac2N5O2ludHByb0VhbGFycmhrO3VjaXJjUmhqc2VyaWdyYXZlO0xvd2VyUmlnaHRBcnJzbXRlbGludGVWZXJ0aWNhbFNlcGFzb2ZnbkU7Ymlnd2VMZWZ0UmlnaHRBcnJvdztOb3ROZXN0ZWRHcmVhbnJBTG9uZ0xlZnRSaWdodEFycm93O1JldmVyc2VVRG93bkxlZnRWZWN0b3JEY2Fyb1JpZ2h0QXJyb3dCbnN1cHNldGVxO3N1cGVkUmlnaHRUcmlhbmdsZUJhclVkYmxhY2xkcXVvcmVyTEplcHNpQnVtc3VibXRpSHVtcERyY3lyY2VkdXBhcnF1YXRlcm5pb25zTm90U3Vic2V0RXF1YWw7c2NpcmNOb3RMZXNzVGlsT2N5O25lZG9iZWJpZ3VwcnVyZXNhY2N1ZGFycmxGaWxsZWRWZXJ5U21hbGxTcXVhcmU7b3Njcjt4d2VkZ2dhbW1hZEhmcmN1bGFycnBEb3duTGVmdFJpZ2h0VmVjdEVsZW1lU2NyQXRhaWFuZ2U7UnJMZWZ0RG91YmxlQnJhc2hvcnRtaWRWRGFzQW1hY3I7SUVjY29sdHNjeTtsamN5cGFyc3N1YnJhcnI7Ym5lUmNlR3NjclVwYXJyb3c7RW9nb29yZGY7ZHRyaWZzd25yc2FxdVdvcGY7bnNpdmFyc3Vic2V0bmVxcTtuc2NjbmFwRXR3aXh0QXRpbGRlO3h2ZWdzY3ZhcnByb3B0Y2VkaURvdWJsZVJpZ2h0QXJyb3dOZXN0ZWRHcmVhdGVyR3V0ZG90O3Zhcm50aGV0YXY7cHJvZmFsSW50ZXJzZWN0aW9uO2xvcGRhZ2dzdXBzRGNzdWJtdWx0dXRpbGRlO1N1Y2NlZWRzRXFsbGhhcmNvbmludFJpZ2h0VHJpQ2lIaWxiZXJ0U3BvZWxpZ2x2c29sYmZvcmFsbDtsb25nbGVmdHJpZ2h0RG93blJpZXNkYm94dlI7ZG90ZWdzY3I7b2Rzb2xkO25kYXNoZG93bmF5c2Njd2lubEFycm52RGFzaHJhcnJmcztEb3VibGVDZUREb3Q7WnNjdGlub2xjcm9zc2NpcmNsZWRjaXJpbm9kb3Q7bGVmdHJpZ2h0YXJyb3c7TGVmdEFuZ2xlQnJhY2tlbWVhc3VyZVlmcmRvd25kb3duTGVzc0dyZWF0aXF1ZWd0cmVyaWdodGhhcnBvb251bG9uZ2xlZnRhTGVmdFZlc2NuUGFydGl2RGFzaDtJbWFjcjtUYXVlZkRvZm9ya3Y7WmNhcm9uO0djaXJjYmZyYmVwc2k7Ym94Vkw7ZXFzbGFudGNvbXBsZVJFbmRhc2g7YnNlbWljaXJjbGVkZGFYZnI7RG91YmxlVXBEb3duQXJ0aWxHSmN5cm90aU5vdExlZnRUcmlhbmdsZUVxcHJ1c21hbGxPbWlqY3VsYXJyZXBzaXZHcmVhdGVyVGlsZGVjb2xvbjtzbGFib3htaW51S2ZyO1JldmVyc2VVcEVxYW5nbGU7Q29udG9yYWRvbWludXNMc2g7VXBBcnJvd0Rvd25BcnJvdztxdW90O0V4aXN0aGJTcXVhcmVJbnRlcnNWZXJ0aWNhbFRpbHJhZW1wdHlOZXN0ZWRMZXJhcnJ0bDtOb3RIdW1wRG93bkh1bW1sbGJhcnJMZWZ0RG93blZlY3RvckJhRG93bkxlZnRWZWN0b3I7VnZkYXNuc3ViO2FuZ3pUaWxkdHJpYW5nbGVyaWdodGVxO2hhcnJjcmlnaHRsZWZSY2xkcnVzaGFyY3VyYXJybTtUaWxkb3RwcnBhcjtFbXB0eVZlcnlTbWFsbFNxdWF1aGFybGxzY3I7dnppZ3phZ2NhY3V0UGFydGlhbFNxdWFyZVN1cGVyc2V0RXF1YUh1bXBaSGN5O0hzdHJvaztyb3RmcmFjY3NjcjtBb3BmbG9ucmlnaHRzcXVpZ2FybndhcmhrO0dyZWF0ZXJHcmVhZXhpc3RzdWJzZXRlcXE7Q291bnRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JudHJpYW5nbGVyaWdwdW5jc3A7RXF1YWxUYWxlZnNpYWN1dXJjbGxjb3JuZXJ3Y2lyTm90UHJlY2VkZXNTbGFDb3VudGVyQ2xvY2t3aXNlQ29udG91cnBzY0xvbk5vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyTGFycmJjb25nO29yb3JzbWlkO2FuZGFuZDtUaWxkZUVxdWFsO250cmlhbmdsRmlsbGVkU21hbGxTcXVhclByaW1jb21wbHRsd2VkYmFjdXJybG9uZ21hQUdyZWF0ZXJFcXVhY2lyc2NpcjthbmRzbG9wc2hvcnRzcnJlYWxpbmVtYWx0ZXNQcm9kdWN0O0xlZnREb3duVGVpbnRsYXJob3JzbG9wU2hvcnREb3duQXJyb0RpYWNyaXRpY2FsRG91YlJpZ2h0VHJpYW5nbGVFcXVOb3RTdXBlTm90VGlsZGVGdWhrc3dhckV4cG9wcm9mc3Vsb25nbGVmdHJpZ2h0YXJybG9uZ21hbmdydGltYWdlc3N0ZXRoO3RoZXRhc3hoQXJyO0NjZWRQZnI7Ym93dGllRW1wdHlWTm90TmVzdEVwU21hbGxlc3NhdHJpYW5oYXJJbXBsaWVzRG93blJpZ0Rvd25SaWdodFZlY1N1Y2NlZWRzU0xlZnRDZWltaW51c2Q7dWZpc2h0O3RlbHJTYWN1dGU7ZnJvd0Rvd25BcnJvd1VwQXJyb3dNaW51c1BsdXNzY2FwO3Nxc3ViZTtnRURpYWNyaXRpY2FsVGlseHZlZTtwcm5hcE5vdExlc3NFcmlnaHR0aGxhcnJmc25vdGludmFVb2dkbGNvcm47ZGVtcHpldGE7dGVudHJpYW5nbGVuTGVmdHJpZ2h0YXJyb3dMc3Ryb2s7YW9nb0RvdWJsZVVwQXJyb3c7Y3NjS2N5O3N1YkVib3hoVXBBcnJvZG90ZXFIYWNlaztMb25nbmRhc3Vic2ltO2d0bFBhclZlcmJhbGVmdGxlZnRhTm90U3VjY2VlZHNFcXVzdWJzZXRlcXFrYXBwYTtIYWNNZWxsaW50cm5sZXFxYm94dEJjeTthcGVTaG9ydExlZnRBcnJob2JpZ3RyaWFDaXJjbGVUaXRyaWFuZ2xlcmlnaHRlcU1zY3JvcmRlcjtnamN5RGlhY3JpdGljYWxEdmFuZ3J0O2hmQ2RveWljQ291bnRlckNjYXJldDtkb3duaGFycG9vbnJpZ2hvb2tyVmJhcnNxc3VidGhoYXJyY2lyO2NpcmNsZWFycm93bGVmdDtkc2NyO2ltYWNibGFja3RyaWFuZ2xlQ2xvYmJyaztic29sO3JkcXVvcjtzaW1sRTtVcGRvd25hcnJvd25jb25nZG9yZHNoTG9uZ2xlZnRhcnJvd2JveGJveDtmZmxsaXZhcnRyaWFuZ2xlbG5wYXJhVW5kZXJCcmFja2VOb3RTcXVhcmVTdXBlVXBFcXVpbGlicmxhcnJscERpYWNyaXRpY2FBcHBseUZ1TmVzdGVkR3JlYXRlckdyZWF0ZWJlcm5vdTtIdW1wRXF1YWxyZGxkaGFyaW1hZ3BhcnREb3duTGVmdFRlZWd0cXVlc2d0cXVwcmVjbmFwcGNpcmNsZWFycm93bGVmd3JlYXRoO2NlbXBidWxyZmlFYWNmYWxsTGVmdERvd25WaW1hdGhuYW5HSmN5O05vdExlc3NHcmVhdGVybHN0cm9wbHVzO2JpZ29kb3Q7R2ZyO2RhZ2dlcm5zdXBzZXRlcWN1cGxyaG5ocHZ6aWdscmFMb3dlclJpdXJpbmc7d2ZyS0hjeW9tZWdhTGVmdFVwVmVjdG9yQnhvcGZHcmVhdGVyU2xhbnRFcXVhbExlZnRUZWVWZWN0b2dyYXZlblJpZ1RSQUREc3Ryb2s7bGF0YXNtYWxsc2V0bWluUHJlY0xvbmdSaWdodEFyaWdodGxlZnRPcGVuQ2xlc2RvQWJyQWJyZXZlWUljeVJpZ2h0QW5nbGVCcmF6Y2Fyb247Z3RyZXFxbGRpYW1vbmRzdXRpbGRlbmVMZWZ0VHJpYW5nbGVCYXRjZWR2YXJ0cmlhbmdsZWxlZWRvbG9icmtkaGFycmRvd25kb3djaXJjZXE7ZGJsdmFyc3Vic2V0bHRjSXRpQ3Njcjtsb25ncmlzY3BvbmFwb3NqbWF0aGRyYmthcm93WmZBZ3JhS2NlTG9uZ0xlZnRSaWdodEF6d25qO2pjaXJjaXByb21pZGZlbWpzY3J2YXJrYXBwdmVydGJpZ29wU2Z2YU5vdFB1b3BmbnZydHJpZW9pbkRvd25SaWdodFZlY3RvcjtMZWZoc3Ryb21pZGFzUHJpVEhPUk5wbHVzc2lyYXJyZnNwaGk7c3VwaHNvbDtsZWZ0dGhyZWV0aW1Ob3RTcXVhcmVTdWJ0ZWxyZWNzemxpZ0lKUHJvZHVjdHJpcGx1c1ZlcmJhcjtiY3k7bGVmdHRoTGxlZnRhcnJVcHBlaWlpbk5vdEdyZWF0ZXJGdWxsRXFuc21pVmVydGljYWxUaWxkZVJhY3V0ZTtwcmVjYXB1YXJWZXJ0aWNhbFNlcGFyYW9sYXJycm9hbmdzcWN1cHNzaHk7aW9nb247bmhwYUdib2hob29rcmlnaHRhcnJvd2JhY2tjb25zY2VkZG90ZXE7bm9wZjtCdWN1cGJyQ29sb247SnNlVXJkYWdnZWR6aWdPbVNob3J0TGVmdEFycm9SaWdodERvd25WTGVzc0dyZWF0ZVVwc2lsb247TmVnYXRpdmVWZXNhY3V0ZTtjdXJ2ZWFyckRvcGY7Y2Fyb247Tm90RXFCckRvdWJsZUxvbmdSaWdodEFycm9SaWdodEFycm93TGVmdXBzaUNPUFlwbU5vdFRpbGRlRXF1YWxTdXBsdXNhY2xyaGFyO2xvbmdsZWZ0cmlnaGFwcHJvb3RpbGJwcmltZTtudmdlO0NlbnRlUmlnaHRBcnJvd0xlZnRpbm9VbmRlckJyYWNEb3VibGVEb3duQXJyb3dlcXVhbGxybTt5Y2lyYztEb3VibGVDb250b3VySWNkb3Q7UkJhcnI7dkJhcnY7VGhlcmVmb3JlO2Jzb2xhZW1wdHl2O05vdERvdWJsZVZlcnRpY2Fsc3Vic2V0bmVxY2lyY2xlYXJyb3dsRGlhY3JpdGljYWxHcmF2ZTtOb3RMZXNTaG9ydFJpZ2h0QXJyb0NlbnRlckRkZGFnVHJpcGxlRG90U2hvcnRVcEFycm93O05vQnJsZWZ0ZWZob29rcmlQcmVjZWRlc1NsYW5ib3hEbDtOb3RSaWdodFRyaWFuYmlnb3RpbWVzO1N1YnNldEVxdWFsO2lpbmZpbjtsZXNzc05vdEVxdWFsVGlsZGU7UWZyO2tqbGVmdHJpZ2h0YXNxY2F0b3Bib3Q7dG9lbGx0cmlKb25ydHJpZTtDb3VudGVOb3RFeGluZ2VxO3R3b2hlYWRsZWZ0YXJydHJpYW5nbE5vdFN1cGVyc2V0RXF1YWw7ZXhwZWN0YXRpb25Vb2dvZnJhYzM4O0xvbmdyaWdocmF0aU5vdFJpZ2h0VHJpYW5nbGVFcXVhbERvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvU3F1YXJlSW50ZWJuZTtFZmJyZXZlO0xlZnREb3duVGVlVmVjdExlZnRBcnJvd1JpZ2h0QXJycnRpbWd0ZG90O0FicmVuc3Vwc2V0ZXFxO29hc3RJZkxlZnRyaWdodGFsb3RpbWVzO2hzdHJva3N3amNpcm11bWFUaWxkZUZ1bEhhdDtsbGNvcm5sbWlkb3RkaXZpZGVsSGFydm9wZnJhYzE2ZWU7ZnNRc2NyaGFycmNpbGNlZGxlZnRoYXJwb29uVXBBcnJvd0Rvd25PYWN1dGU7UmNlZGlsanNlcmNMZWZ0UmlnaHRWZ3Ryc2ltZG93bmhhcnBvb25yaWdodHJhdGFpbDtudmRhc2xlZnRyaWdodHNxdWlnYWJpTm90VGxvem5vdGluO2xmbG9vcjtOb3RMc3Vwc2V0bmVxYW5kc2xvcGU7TG1paWlpaW5wcnVyZWxBYnJldmU7UmlnaHRBbmdsZUJyTm90RG91cmF0aW9ucGk7cnRocmVlaHNsYXNxdWFhZ3JhdmU7RG93blJpZ2h0VGVlVmVjdG9yVnNVdGlsZGV3ZWRiYXJzZWFycm9Ob3RMZXNzTGh5YnVsbGN3Y29uR3JlYXRlckdyZWF0dWZFcXVhbFRpbG9wTXNjbGxjb2d0cmxlc2x2ZXJ0bmVwcmVjbmVxcTt3ZWRiYXI7UmFjdVVwVEludmlzaWJsZVRpdmFydHJpYW5nbGVya2N5O0xlZnRBbmdsZUJydmVlYmFJb3Buc3Vwc1hzZ2Vxc2xhbnRuYnVtcG5MZWZ0YXJyYXBvbnNob3J0bWlkSmNpcmNyY3ViO0Rvd25MZWZ0UmlnaHRWZWN0b3I7Y3VydmVhcnJvd3J2YXJ0cmlhbmdsZXJpZ2h0O2JveHY7bEJhcmJlbXB0eXZhbmR2bGN1UmlnaHRVcFZlY3RvcjtKc2Jsa2N1cmx5dmVlY2x1YnNkdERpYWNyaXRpY2FsVGlsZGU7Z2ZFZ2NpcmNsZWFycm93bGVSaWdodEFycm93TGVyYW5nbGFtYnhvdGltZTtuYXBFO0d0RG93bkxlZnRWZWN0b2JveHZyO1ByZWNlZGluZmluO252YXA7cGFyc2ltbWludXNkdTtyaWdodHRocmVldGltZXNzdHJhaWdodGVwc2lsTm90TGVzc0dyeHV0cmlxdWF0TGVzc0VxdWFsR3JlYXRlcmRsY29ybmhzY3JuR3RkaXZpZGU7ZmVtYWxMZWZ0VUhzdGJsYWNrdHJpYW5rY0REYm94aHU7emRvdExlZnRGbG9vcjtsdHF1ZUxhY3RlbHJlYztzdXBzdWJEb3Q7c2xhcnJ2YXJzY2FwY3VwTmVnYXRpdmVUaGluU3BhY2U7UmlnaHRBcnJvd0JhcjtpdGlsc2NuYXBHcmVhdG1hY3JsYXJyO05vdERvdWJsZVZlcmlnaHRsZWZ0aGFycG9vbkxlZnRBbmdsZUJmcmFjMzRwcm5SaWdodFRlZVZlR3JlYXRlckZEaWFjcml0aWNhbERvdWJsZXBsYW5Ob3RTdXBlcnN0YnJrbGFlbXBuamNTdWNoVGhvckNvbmdyaWdodGFycm93dGFTcXVhcmVTdXBlcnNldGltcGVkO0xlZnRDZWlsaW5nbGJyYWNlUWZycmJibGhhcnN0cmFpZ2h0ZXBzaWxvbjtPbWVkYmtndHJhcHByb3hzdWJkb0dicmV2ZTt0aGluTm90VGlsZGVGdWxsRXF1Tm90TGVzc1NWZGFzcG9tYXJrZXJjd2NvZmZsbGlnbGU7b2dhbmdydHZiZDtpbmZpbnRpUm9wZjtvcnNsb3NoY1ZlcnRpY2FsQnJlYWx2YXJzdWJzZXRuZXE7UkJib3hib3hIdW1wRG93bkh1bVRoaWN1bG5hcHByb3hOb3ROZXN0ZWRHcmVhdGVyR3JlYXRuc3VjY0Rhc2h2dmZyb2FjdXRlZW9nb25tYWNpbnRjYXFvcHVwaGFycG9SaWdodFVwRERpYWNyaXRpY2FsRG90O0hpbGJlcnRTaW50O05lc3RlZEdyZWF1bXZhcnJob01lbGxpbnRVcHBlclJpZ2hkaXY7YnJ2YmFyY2lyY2xlYXJyb3djc3VwZVN1Y2hUaGFWZXJ0ZW1yb3Bmc3FzdWJzZXRlYWFjdXRFcXVhcmF0YWlWZGFzaE5vdEV4aXN0Y2lyY2xlYXJyb3dyaWdodG1hcHN2YXJ0aGV0YXRyaXBsc3FDbG9ja3dpc2VDb1VuZGVyUGFyZXVsY29ybmVtY3k7RG93bkxlZnRSaWdoYmxhY2t0cmlhbmdsZXJpZ2Fjd2lMZWZ0VXBEb3duVmVjdG9yRXRyb2JqY3lTbWFsbEdmcnR3b2hlYWRyaWdodGFycm93O1pIcHJvZmxpbmRsZ2VzbDtQaTthbmRhbmdlcXFMZWZ0VXBUZWVWZWN0b3I7cnJhcnI7c2Nhcm9uO09wZW5DdXJseURvdWJsZVFCZWNhdUljaVRvcFJldmVyc2VFbGVib3h1clByZWNlZGVzU2xhbnRFcXVhYnVtcFJpZ2h0RG91YmxlQkdKY2N1ZXNjO1dvcGZOb3REb3ViTmVnYXRpdmVNZWRpdW1TcGFjZWxyYXJyYXJpRGZybnN1YnN0aW1jc2NyT2ZyQ29udG91c2NpcmM7RXNjcjtOZWdhdGl2ZVRoaWNrU3BhY2U7Zmx0bnM7RW1wdHlWZXJ5U21hbGxzaW1sVmVydGljYUNvbnRvdXJJbnRlZ3JBYXJydWRoYUFwcGx5RnVuY3RlbGNhcDticHJpT3NDcm9zcztwaXZzdXBzaWNpVW1TY3k7d2VkZ2U7VmVlO0RvdWJsVGlsZGVUaWxkZTtwcmVjY3VybHllcTtpc2luZG9lcXNsYW5BcHBhbWFuTGVmdHJpZ2h0YXJybnByZWNlcWx0cXVlc05vdExlZnRUcmlhblJjYXJvc2ltcHh2ZWVwY2ltb2Y7emZyO1N1cGVyc2VlcWNJZnI7YmlndmlxdWVzdDtsZXNuZWFycm9kb3RzcXVOYWNucmlnaHRhcnJvd2Rvd3BjeWpzVW9wQWN5Y2FwYnJjdXNmcm93bnByZWNuYWRvdDtMb25nUmlnaGJveHVSO2ltYWdwYXJ0O3JhbmdlO3JiYnJrO25SU0hjckJhcnI7bHRpbWVzO0hBUkRjeXJlTWZMb25ncmlnaHR0cmlhbmdsZXJpcmJya3NsZDt4bGFycjtEb3VibGVVcERvd25BcnJvd3Jtb3VzdGFTdWJzZXRFcXVhcmlnaHRsZWZ0YXJyb3dzRGlmZmVyZWdsRXFpbmNpcmNsZWRhc2RlbXB0eXZwbHVzdHdib3hWSDtCZWNhdXNlO05vdEh1bXBEb2xlc3Nkb3N0cmFpZ2h0ZXBwb3VuZDtOb3RFcXVhbFRpbGROb3RTcXVhcmVTdXBlcnNldHBlcmNYaW5WRG53YXJyYXRhTm90U3VjY2VlZHNTRG91YmxlVmVydGlzdWJtdWNpcm1tRERvdG1ucHdlZGdlcTtOZXdzd0Fycjt2YXJrYXBwYTtTT0ZUTGVmdFJpZ2h0VmVjdG9ybWFwc3RvZG93bjtOb3RTcXVhcmVTdXBlcmR0ZG90O0xtaWRvdGdpT3RpbWVBcHBseUZ1bmN0aW9uUHNjcjtFbGVCZXJ2QXRvcGZvcmtsZWZ0cmlnaHRoYWNjdXBzVXBBcnJpZ2h0bGVmdGhydWx1aGFFZ3JhdmVubGVmdGFycmRvdWJsZWJhcnZCYVBzaWVsaW50bWFwc3RvdXN1cGVkb3Q7ZG90c3F1cmNybGVmdGxlZnRhcnN1Y2NjdXJseWVxO3BhcmFjaXJjbGVkZGFzaHZhbmdydGxvb3BhcnJvd2xzY25zaW07U3VjY2VlZHNFcXVhUnJpZ2h0YXJyb3duc3FzdXBlbWlkY2lyckJhVFNjeVJpZ2h0QXJyb3dMZWZ0QXJ2YW5hbmdtc2RhZU5vdEVxdWFsVGlsZGViYWNrZXBzaWxvbmRvbGxhcnBybnNEaWFjcml0aWNhbERvdWJsZUFjdWFhY2RpZ2FmcmFjMThsYXJyYmZzbnVtc0xlZnRyaWdodGFycm93O0NoaTtOb3RQcmVjTm90VGlsZGVGdWxFbGVtZW5jdWRhdnN1cG5FSWRvdGxvbmdsZWZ0cmxlZnRyaWdodHNxdWlnYXJic29sYjtubGVxcTtjb3B5bGJhb2dyYXZlO0VtcHR5U21hbGxTcXVhcm9wYXJjZWlsbG9vcGFycm93bGVmcmFxdURvd25MZWZ0UmlMZWZ0VXBUZWVWZWN0b3JyYW5nbGVEZWw7Z3REb3VibGVSaWdodENpcmNsZVBsdXNMZXNzRnVsbEVxdWFyaWdodHRocmVnZXNkb3Q7SXVtbGJhcnd1ZGFwaWQ7TGVzc1RpbGlvcGY7YW5nbGFtYWxnO2dpbWVFbXB0eVNtYWxsU2dlcXE7TmVnYXRpdmVUaGRia2FyRmlsbGVkU21hSW52aXNpYnBsdXJmaXNoTm90RG91YmxlVmVydG9zc3Vwc3Vudmx0O1VwRXF1Q29uZ3J1ZW50O0tjZWRpZ2ZycHJvZmFob29rbGVmdGFyTGVmdHJmcmFzbDtGc2Nycm1vdXN0YWNoZTtSaWdodERvd25UZWVWZWNhYztDbG9ja3dpc2VDb250bHNFY2Fyb1JvdW5kSW1wbGFtRGlhY3JpdGljYWxBY1FVT1REb3duQnJldmU7bmxlTm90RG91YmxlVmVydGljYWxCYU5lc3RlZEdyZWF0ZXJHcmVhdGVyO2Jicmt0Y2VudGVyZG91b3BzdXAzZURvdDtjdXJseWVxc3NyYXJKc2NyO2RibGFjY2lyY2xlYXJWZXJ0aWNhbFRpbGRzcXN1cHNldGVic2ltO3NwYWRlc0RvdWJsZVVwRG9ERG9sdXJkc0JhTG9uZ0xlZnRBc2NuYXA7SWdyTG9uZ0xlZnRSaWdodEFybkxlZnRhcnJvd3ByY3VlO1VicmV2ZWdvcGxBdGFpUmlnaHRGbG92YXJwaUZpbGxlZFZlcnlTbWJzaW1lO3Zuc3VwYm94RHI7c3ViZWRvcGhpdkxlc3NkaGFtZnI7a3NjckNjb25pbnQ7SG9yaXpvcmFjdXRlO05vdFJpZ2h0VHJpYW5nbGVCVXBzaWxvTm9CcmVhazt0cHJpbWVkc2NEaWFjcml0aWNhbGRvdWJsZWJiTm90O250bFRyaXBsZURvbHNoO2NvbXBsZW1lU3Vic2V0RXF1bG5lcXF2bnN1Tm90TmVzdGVkR3JzaGN5T2NpcmNFb3BiaWd0cmlhbmdsZWRUaWxkZVRpbGRlU3VwZXJzZXRFcXVhVWFycm9jaXJhbmRhYm5lcXZ6aWd6YXhuaXM7RERvdHJ2YXJ0TGVmdERvdWJsTGVmdFRyaWFuZ2xlRXF1Tm90UHJlY2VkZXNTbGFuQWdyYXZldmFybm90aGluZztkZG90c2VxYkxlc3NTbGFudEVxTXNjcjt1ZnI7YW5nbXNkYWdsbGNvcm5lc29sYmFEb3VibGVMb25nUmlnaHRBcnJMZWZ0UmlnaHRBcnJvdmRhc2hvbXJhbmc7Tm90TGVzc0xlZGRhcmxhZ3JOZWdhdGl2ZU1lZGloYXJydztsRWc7bGVzc2dJbnRlcnNlYnVsbGVOZXN0ZWRHcmVhdGV1cGx1cztGaWxsZWRTdmxldnByb3A7dHJpc2JJb2dubWlsQmFyclRoZXRhO3h3ZWRnZWh5YkxlZnRUcmlhbmdsZU5vdExlc3NUaWxkZTtEb05lc3RlZEdyZWF0ZXJxb3BmYmxhY2t0cmlhbXVscHJuc2ltO2NoZWNrO3BybkVtaWRhc3RjdWxhcnJwO0Rvd25UZWVBcnJvZXVnbmU7bWFwc3RvbGVmdDtSZXZlcnNlRWxlbWJsb2NDbG9ja3dpRG91YmxlUmlnaHRBcnJvdztwZXJ0ZWxlc3NhcHBkaWdhbW1zbWVwYXJJbnZpc2libGVUYWJyZXZlO2VuZzt0b2VhO2xtb3VzQ2NhckZvdXJpZXJ0cmZsbmFwcHJvbmdlcztFcXVpbGlibmxhckRvdWJsZURvd25BcnVwaGFycG9vRW9nVXBFcXVpbGlicml1UHJlY2VkZXNTbGFMZWZ0QW5nbGVCcmFja2V0Ym94VlJOb3RHcmVhdGVyVGlsZGV2c3VibkU7Y3Rkb0NvcHJvZHVjdGRyY0xvd2VyTGVmdEFycm93bGhibGtJbWFnaW5hcnlJO3Nxc3Vic2V0ZXE7bm90aW5jYXBicmJveHRpbW1vZGVsc0JzY1RpbGRlRXF1YU5vdFZlcnRpY0xvbmdsaGNpcmM7Y2N1cHByZWNlcVpldGE7Tm90VmVydGljYVNob3J0TGVmdEFPdGltZXM7TGVmdERvd25WZWN0bnRnQ2xvc2VDdXJseURvdWJsYnNvbGJyYXF1bztDb3BmbWludXNHY2lvcGx1V2NlUGx1c0RvdWJsZUxvbmdMZWZ0UmlnSU9jeW5hdHVyYXZlZTtVcGRvd25hcnJvdztGb3VEb3duUlRjZWNoaTt0cmltaXJhcnJhQ3VwQ2FwTG9uZ1JpZ2h0QXJkZW1wdHl2O25wcmVjO0xlZnREb3duVGVlVmVjdG9yO05vdEh1bXBFcW5vdGluZG90bHRyaWVTcXVhcmVVbml5ZnI7SmZyO3JlYWxpbmU7ZGl2Ym94cGx1c0tjZWRpbGhlcmNsb3BhcmR1aGFySW50ZVRoaW5TcHJyYXJpZ2h0YXJwbHVzdHdvO0NpcmNsZVRpbWVOb3RSaWdodFRyYWZyO2xhcVdzY3I7dHdvaGVhZHJpYmZsZXFMZWZ0RG91YmxlQlNob3J0TGVmdEFycm93ZXF1aXZERFN1Y2hUaE5lc0xhbWJPY2lyRXhibGFja3RyaWFuZ2xlZElKbGlnVXBBcnJvd05vdFN1cGx2ZXJ0c2ZXc2NybGVzZG90ZXhwZXJpZ2h0c3F1aWdhdUFOb3RTdWJzZXRmcGFydGlTdWI7Tm90SHByZWNuYXBwcm94Tm90VGlsZGVUU3Njcm9jeTtEb3duYXJyb3dubHRyaXJwYXJubGVmdGFycm9ucnRTT0ZUY3k7WkhjbnNxc3ViZUVtcHR5U21Ob3RHcmVhdGVyRkNlVG9wZjtVcERvd25BcnJvd3RpbWVzZGhrc2Vhcm93Q291bnRlckNsb2Nrd2lzZUNvbnRjaXJtaWQ7ZG90ZXFkb3Q7ZW9wcmFycmI7ZGJsYWM7bXU7Tm90SHVtcEVxdWFsaW50cHJvZGNpcmNsZWFycm9SZXZlcnNlRXF1aWxpYnJlemFjTGVmdERvd25UZWVWRG91YmxlTG9uZ0xlZm9oYmFyO05vdE5lc3RlZExlc3NMbGFuZ2Q7bmdzaW1hc3ltcGVxO2xjZWlsbGVmdGxlZnRhcnJwcmVjYXBwckVxdWlsUGZybHVydWhhdG9wO2xvd2FzdHZhcnRobG9vcGFycm93Y3VybHllcXByZWNydWx1dHJwZXppdW07RGlhY3JpdGljYWxBY3VMZWZ0QW5nbGVCcmFjaW1hZ2xpbmU7Tm90TGVmdFRyaWFuZ2xlRXF1YWxOb3RWZXJ0bG9vcGFyQXBwbHlGYW9nT3BlbkN1cmx5UWJpZ3N0YXI7ZXF1YVByb2R1QWxjdXJ2ZWFycm93bGVpaW5maW9kaXY7bGVzc2VxZ3RyaXVtbGVxdWl2cGxhbmNraDtOZnNxdWFyZm5lYXJyb3dDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGxhdGFpaW50ZXJibGFja3RyaWFuZ2xlbGV0cmlhbmdsZWRvd2JsYWNrbG96ZW5pb2dvYWN1dElPY3k7TGVmdFVwVmVjdG9yO2R6Y0ZpbGxlZFNtYWxsU0NvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWxsdmVydG5lcXFwb3VucmRsbnBvbGlsQWFyY29wZjtsbDtQcm9wb3J0aW9udWRic2Vhck5lc3RlcmVhbHBiaWdzdGFyTm9uQnJlYWtpbmdTcHZhcmVwc2lsb01hcDtsYXJyaGt0b3BmO2duc2duZXFudHJpYW5nZG93bmhhcnBvWWN5Q2lyY2xlTWludXM7RG93bkJ0aGlVdGlsZGU7RG93blJpZ2h0Vk5lZ2F0aXZlVmVyeVRoaW5TcGFjZVVwRXFhYnJlc3VjY2N1ck5vdFNxdWFyZVN1cGVyc2V0O05vdExlc3NFcXVhbHRzYXBwcmFycmxVYWN1dGVUc3Ryb1JpZ2h0QW5nbGVCcmFja2VzdWJzdXF1YXRpbnRERG90cmFibGFja3RyaWFuZ2xpb2N5SGF2ZWVOb3RTdWJzZXRFcXVhUmlnaHRVcFZlY3ROb3ROZXN0ZWRHcmVhdGVMb25ncmlnbnZyQWFuZ3phdHdvemNhcm9ubGVmdGhhcnBvb251cDtjc3ViZTtsb3plbmVncmF2SmNpcnRpbWVzbmdlcXE7cmJya3NsdVlvR2FtbWFkO21hcHN0b2xlZnROb3RTdWNjZWVkbHNxYjtudmluVWJyY1BmUmZycXVhRG93bmFycm9Ob3RSaWdodFRyaWFuZ2JuZXF1dGJyaztMZWZ0Rmxvb3JkYmthcm93O2ZyYWMyNTtyQXJyTGVzc0VxdWFsR3JlYXRjeWxjdHk7Tm90TGVzc1NsYW50RXF1YWxDb3VudGJzaW1jdXJseWVxcGxjZWRpbDttYXBzdG9saXNpbnNMb3dlclJpZ2h0QXJib3hVcmZsdG50d29oZWdhbW1hZDttbGNwdHJwZXlvcE5lZ3JvcGFyRG93bkxlZnRWZXFzbGFudGd0Tm90RXF1YWJvd3Rhc3Q7anNjQ2xvY2t3aXNlQ29udG9kZWx0YTtuc2hEaWFjVWFjdW5zdXA7Tm90R3JlYXRlckdyZG93bmhhcnBvb25sZWZTaG9ydFJSY2F5YWN5cmVhbHM7VXBzRG91YmxlTGVmdEFycm9scmNvcm5lU0hjeTtkcmNyb3BvdGltZXNhc3VwYXJyTmNhcm9wbGFjdXJseWVxc3VDbG9ja3dpc2VyQWFycjtzaG9yTG9uZ0xlZnRSaWdoRXF1YWw7bG90aW1lc2hvcnRtaW5WcmxoYXN1Y2Nuc3NxY3VwO0RvdWJsZVJpZ2h0QXJyb25WZExjZXBvaXJlYU5lZ2F0aXZlTWVxY29sRGVsdGFkcmJjdXJhcnJtbmVhcnJvdztMZWZ0RG93blZlY3RvckJSaWdodERvd25UZWVWZWN0b3Jub3RpbnZjYXBwclJvdW5oYXJkbnZkYWJsYW5rO2FuZGFuZFJpZ2h0VHJpYW5nbGVFY2VwZXJpb2Q7RG93blJpZ2h0TGxlZnRBTVA7bmN1cDtyaXNlZWJlbXBPdmVyUGFyZW50aGVzaWVxY29sb247Rm91cmllRG91YmxlVXBEb3duQXJyb3c7T3ZlckJyUmlnaHRBcnJvd0xlZnRBcnJvdztuZXF1aXhvZG90O3Nob29mRG93bkxlZnRUZWVWZW5jb25nZG90O3ByZWNjdVJpZ2h0RG91YmxlQnJhYmFja2VlcXVpdjtsaGFydXBsdXNjdHJpZG90cmFlbXBDdXBDYW5wYXJhbGxlR3JlYXRlclNsYW50dnJ0cmlWb3BmO3ZBcnJlbGluVmRhc2N1cGNhcHNjYXJvbmxvejtVcmluanVrY3k7bGVzZG90b3I7Tm90U3Vic2V0RXF1YWxCZnI7V2VkaW50Y0VjYXJvbkRvdWJsZVJpTm90U3VwZXJzZXRFcXVhbHZhcnN1cG9jaXI7dm9wZjtkaWdhbWJveHBsdXJpbmdSaWdodFZlY0thYmxhY2tzcXVSaWdodERvd25UZWVWZWN0Tm90UHJlY2VkZXNTbGFudEVxdWFzdXBkb09mcjtycnRoaW5zb2hiRmZ2YXJzaWdtcW9wZjthcDtEaWFjcml0aWNhbEFjdXRlZXVyaG9va2xldXBoYXJwb29uTG9uZ0xlZnRSaXlhY3V0bnZydHJpT29wZjtESmN5TnRpbGRlO3JzaDtEc2NyYm94cGx1VXBUZWVBcnJvdztsYXRlO1VwRXF1aWxpYnJpdW07Y3V3ZUNycGFyZ1ZlcnRpY2FsTGluZXFwZWdyT21lZ3RwcmlFbXB0eVZlcnlTbWFsbFNxZGFsZXRTb0hvcmljdXJseWVxcHJlYztnZXFuZUFycjtjY2FwczthbmdzcGg7aG9hcnNob3J0cHJicmFja2JveGhVO1N1Y2NlZWRzVGlsZHJBdEFhY3V0c2NjdWVVcFRlZTtEb3VibGVSaWdodEFsc2ltbnRyaWFuZ2xlcmlnaHRTcXVhcmVJbnRlcnNlY2hmcjtjYXBkb3Q7TWllY3lBY2lsZWZ0YXJyb3c7SWZyZnJhYzU4O1BvaW5jYXJlcGxPcGVuQ3VybHlRdW90TGVmdFRyaXBoaXN1cGRhZ05vdFN1cGVyc2V0RXFaYWN1dGVZQW5hdHVyYWxzO2xicmtlO05vdFN1cGVyc2V0RXF1YU5vdEdyZWF0ZXJHcmVhdERpYW1vaWluc3VjY2FwcHJlY2FDb2xvbmVEb3VibGVSaWdodFROZWdhdGl2ZVRoaW5TcGFjZWluZmlzbWVwYU9ncmF1ZmxhdDtFY2Fyb247QWxwaGdzaW1saGVhcnRzQ29udG91ckludG9sY2lyO1plcm9XaWRsbGhhdXBhVmN5Tm90UHJlY2VkZXNFcXVhU3F1YXJlU3Vic2V0ZXVtbENpcmNsZURSb3VsdGxhcnI7TGVmdFVwRG93blZlY3RaZXJvV2lkdGhrc2Vhcm93O0RvdWJsZURvd25Ba2FwY2lyZm5pbnQ7Y2lyY2xlZGRhc2FuZ3N0O3phVXBwUmlnaHRUZWVBcnJvbGVmdGhhcnBvb25kdHJwZXpudW1lVXVtbExlc3NUaWxkZTtVZGJsYUxlZnREb3VibGVCcmFja1VwcGVyTGVmdHNoY3k7QXNzY3lob29rbGVmdHJhZWxlZnR0aHJlZXRpbWVJZG90O3N1Y2Nuc2lOb3RSaWdodFRyaWFuZ2xlRXF1YWw7RG91YmxlRG93bkFycnJhdGlvbmFsc2N1cmx5d2VkZ2U7ZHpjeTthc2NycmNlaWw7a2ZyO1Byb3BvRGlhY3Jsb25nbGVmdHJpZ2h0YXJwYXI7cmxhYmVjYXVzZWN1cmx5ZXFzdWNjO3ZkckFhckxvd2VyUlJpZ2h0VGVlQXJpbnRsYXJoa1RjZWRpbGVzc2FwcHJSZXZlcnNlVXBGaWxsZWRWZXJ5U21hbGxTT3BlbGRyZGhhcjtBZ3JhdmRvdG1ubEFyclN1cGVyc2V0RVNxdWFyZVN1cGVyc2V0RXF1YWxlcmFycnNjdWFycjtybGFyck9jaXJjO05vdERvdWJsZVZlcnRpY2FsQmFyeGNpcmM7dHJpYW5nbGVsZWZ0bG93YmFyO2xhZ3Jhbjt2YXJzdXBzZXRuY3VwY3N1cDJrZ3JlR2ZoZXJFcXVpbGlicml1bWJpZ3NiZXJub2xhdGVzO1JyaWdodG11bWFwRG91YmxlVmVydGljYXR3b2hlYWRyVXBEb3duQXJSaWdodFVwRG93blZudmx0cmZhbGxpY2Nhcm9uO01mcjtpdGlsZEx0cGZyO3ZzY3I7SWdyYXZib3h0aW1lcmlnaHRsZWZ0aGFudmFmcmFjMnF1YXRlckNvbnRvdXJJbnRlZ3JramNoQWJlY2F1c0RvdWJsZVVwQXJyb3dpbXBlYmZyO05vdEdyZWF0ZXJTbGFudERvd25MZWZ0VmVjdG9yQmFuTGVwcm9mbGluZTtLZkxlZnREb3duVmVjdG9yQ29Jc2NzdWNjbmFwcHJyaWdodGhhcnBvb25kb3duO0Nsb2Nrd2lzZUNvbnJpZ2h0cmlnaHRhcnJvWmN5O3VsY29ybnBtO2J1bGxhbmdtaW51cztSaWdodERvd25WZWN0b3JCb3JkbXJwcG9hbGVmc3lzdXBwbHVyaWdodGhhcnBvb251cDthb3BmZXF1YWxzO1JldmVyc2VVcEVxdWlsaXNldG1ueHdlZGFtYWxSYWN1dERvdWJsZUxvbmdMZWZ0UmlnaGNvcGZQcmVjZWRlc0VxdWFSaG87TG93ZXJSaWdoZWdzZG9lYWN1dG5sZTtuUmlnaHRhZW9nb09tYWNsZXNjYztUaWxkZUVxdWFsYnNvbENvdW50ZXJDbG9ja3dpc2VDb250b3V1ZGhhcjt0ZG9TdWNjZWVkc1NsYW50RXF1YWZjeU5vdExlc3NTbGFudEVxdWFuaEFycjtQcjtHcmVhdGVyR3JlYXRlZXBsTmFjdXRSaWdodFRlZVZlY3RvclRpbGRlRnVsbEVxb2N5bG9wbHVlY2Fyb25ydHJpZXRycE5vdFJldmVyc2VFbGVzZXR0c2NyVWJyZWxhbmdsZTtucGFydGFuZ21zZGFhO3JjZWRpbDtwZXJwbm1pZDtiYWNrZXBzaWxvbjtDY252bEFyQ2ZSaWdodFVwRG93blZlY3Rvb2NIdW1wRG93bkh1bXA7bHJtbGVxc2xOb3ROZXN0ZWZyYWM3YXdOZWdhdGl2ZW53YUNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWw7TGZybHNpbWdpbnRsYXR3b2hlYWRsZWZ0YXJyb3c7Q29uaW50ZHN0clJ1bGVEbWRhc2g7Tm90R3JlYXRlclNsYW50RXFIb3Jpem9udGFsTGlpc2luaW1hZ3BhQ3NjclNjaXJjZm9ybXA7WXNjcmxhbWJkYTtiaWd0cmlhbmdsZXVwc2NuRWdjaXJjO3RoaWNrc2ltR3JlYXRlckZ1bGxFcXVhbGx0bGFycmlxdXRyaXNiO3JpZ2h0cmlnc3dhcnJvd25hcG9zO1JpZ2h0VXBWZWN0b3JCYXI7UmlnaHRVcFRlZVZlY3plZXJwcG9saWxlZnRoc3psRW95Y3k7U3VwZXJzZXRFcXVhbDtjaXJFR3JlYXRlclNsYW51Z3JQYXJ0aWFudW1zcHRyaWFuZ3BlcmlSaWdodEFycm93TGVmdEFIb3Jpem9udGFsTGluZTtib3hVUjtDb25pbnQ7T2Rib3JvREQ7U09GVGN5Tm90SHVtcERvd25oZXJjb250d29oZWFkcmlnaHRhcnJ1c2NyWG9wZmdlcTtQcm9wb3J0aW9uYWw7cXByaW1lO253bmVhcmxlc3NhcHByb3g7Rm91cmllcnRybmxBcnI7dXVhUGx1c01pb3BsbHJ0c3VwbnJpc2luZ2RvUmlnaHRBbmdseGxhY29tcGZuO0dyZWF0ZXJFcWJveHZlc2NyO0lKbGlnO21pZDtlcXNpbWh5cGhEb3VibGVDb250b3VySW5pbnRlZ2xmaXN4c3Vic2lwcmVjbnNpbTt4aGFycjtiaWd0cmlHcmVhdGVyTGVkSGFzdXBuZWNpcmR3UkVHO3JkY2JveGhETnNsZXNzYXBwcm94SW50ZXJzb3VtbGRvd25hcnJvRW1wdHlWZXJ5U0NIUG9wZjtXZWRnZW9pbnRvdnVsY29ybmVyO0NvbnRvdXJJbnRlZ3JhbDtSaWdodFVwVGVlVnZkYXNoO3NjY3V0cmFkZTtmYWxsaW5nZG90Y2ZyO05vdFNxdWFyZVN1cGVyc3VsdHJpTm90VGlsZGVGdWxsRXFMZXNzRmJveHZIdHdvaGVhZGxlZnRhcnJvVXBzaWxvbkFFbGlrZ3JlZW47bHRyUFZlcnRpY2FsVGlramN5O0xhY3V0ZXN0cmFpZ2h0ZXBzaWxvblJpZ2h0Rmxvb3I7RW1wdHlTbWFsbGlvdGE7YXBwcm94RG91YmxlTHplZG91YkRpYW1vbmQ7Zm9ya3NjY3VlO2x1cmRMZWZ0VXBEY2NpcmNyc2hMZWZ0RG93blZlY3Rvcjtsb3dhbmhWZnN3YXJoVW5pb247V29Mb25nUmlnaHRBcnJvdztwcmlFcXVpbGlDaXJjbGVNaW5qY2ltb2RlZmVtYWxlZG93bmhhcnBvb25yaWdodDtWZXJ0O1FzY3NlQXJWZGFzaGw7bnZydHJTdWNjZWVkc1NsYW50RXF1blZkYXNoc3FjUmlnaHREb3duVmVjdG9yQmFybHJ0cmh5YnVjdXA7SHVtU2hvcnREb3duQXJyb3c7c3ViZWRuc3Vwc2V0SmN5aXNpbmRidW1wRURvdWJsZUNvbnRvdXJJbnRlZ3JhbHNleHRudkhhVmJEb3duYXN0cmFpZ2h0R3JlYXRlclRzdXBwbHVzO05lZWNvbHF1YXRlRmlsbGVkU21hbGxTcURvd25MZWZ0VGVlVmltYWdsT3BlbkN1cmx5RG91YmxlUXVvdGU7T2ZsbHRybHNxdW9yYmthcm93dmFycGk7b2FzdDtFeGlzdHNMZXNzRXF1YVNxdWFyZVN1YnNldDtlcmFycjtkamN5VGhlcmVmb3JldmFycjtNZU5vdExlZnRUcmlhbmdsZWFuZGRvbGNyb3NyYXJyYXBTaG9ydExlZnRBcnJvdztjd2Nuc3VjY2VxdGlsZGN1bGFyRmN5RG93bkFQcm5lc2VhcmJhY2twcmlDbG9ja3dpc2VDb250b3VydGNlZGlsO3VoYmxOb3RHcmVhdGVyTGVzcztib3hEUjtMZXNzU2xwcm9wdG87cGl0Y2hmb3JrO2dicmVMb3BmO2NjYXB6Y3k7Y3VydmVhcnJvaGNsYXJyc2ZmbGlQb2luY2FyZXBsYW5lO0F0aWxlbXB0eXNIb3Jpem1lYXN1cmVkYW5nbHNjaXJib3hVbDtsYXJycGxmbGF0cmlhbmdsZXByaW1TcXVhcmVTdWJzRFNjeTtFcXVhbFRpbGRlO2JlY2F1c2U7ZXF2cHhvcGFjaXJjU09hY2NhcnhvcGx1cztOb3RFbGVtZW50Ym94aHVMYXBsYUltTUVtcHR5U21hbGxTcXVhaG9tdGh0O1ZlcnRpY2FsU2VwYW5nc05vdEdyZWF0ZXJGdWxsRXF1YWxoZXJjb0lvbnBhcnQ7RG93bkFycm93RG91YmxlRG93bkFycm9uTHR2O2x0aHJlZTtDYXBpdGFsRGlmZmVyZW50ZHppT3Njck5vdExlZnRUcmlhbmdsZUVxdXNtZU5vdFNxdWFyZVN1YnNldEVxdWFuanJhcnJoazttY29tbVRvTG93ZXJMTm90RXF1YWxUaWxTdWNjZWVkc0VxdWFsTm90Q29uZ3J1ZW50O3hyZGVtY3VwYnJjYXA7TGVmdFZzdXBlZG9taWNnamNOb3RMZXNzR3JldHdvaGVhZHJpZ2hFY2lib3hoZDtwb2ludHZhcm5vdGhuYXRUY2Fyb247Tm90SHVtcERDbG9zZUN1cmx5RG91YmxlR3JlYXRlckxlc2x0aGN1dmVlTm90SHVtcEVxdWFsO250cmlhbmdsZWxlZnRlTm90U3F1YXJwcjtiYWNrcHJ0aGlja2FlZG90bG9icm5hcGlvYXNvdmJhcjtKdWtjeTtydHJpO3N1YnNldGVxQXBwbHlGdW5jdGljb25nYW1tYU9tYWNyO3ZzdXBubnBhcnNsO1djaXJjb21pYnVtcGVpaWludDtsdGRvY2FjdXRlUHJlY2VkZXNTbGFudFJpZ2h0RG93blRlZVZlY3RvRG91YmxlVXBEVXBBcnJvd0JhcjtvY2l2YXJ0cmlhbmdsZWxlZnBobW1hdDt1dGlsZGVXc2NDb3VudGVyQ2xvY2t3aXNlQ29udG91ckluQ2xvc2VpbWFnbGluZUVsZW1lbnRlcWNpcmNrZnN6dnpvb3BmRWdyaHlwaGVuRG91YmxlTGVmdFJpZ2hudGlMZWZ0VXBEb3duVmVjdG9lb3BmO2Jick5jYXJzZG90TGVzc1NsYW5SaWdodFRlZVZMYW5nVWZ2YXJzdWJUU2Nuc3Vic2V0ZXFxR3JlYXRlckxlc3M7emFjdXRlcmlnaHRsZWZ0aGFycFJ1bGVEZWxhU3VtO2ZsbGlJdGlsZGx1cm5jZWRpbGxIYW5hcHBubGVzO2Rzb2xEb3duQXJ1d2FuZ2xlO2h5cGhlRHNhY2ROb3ROZXN0ZWRMZXNzTGViZXRoO25WRGFzaDtleHBlY3RhdGlvU2ZyTGVmdGFycm9VbmRlckJyYW5nbXNkYWhsb3plU2Nhcm9uO2x1cmRzaGFib3htaW5tbGNiZWNhdXM7ZnJhc2x2YXJwcm9Sc2NyO2N5TGVzc1NsYW50eHVwRG91YmxlTG9uZ1JpZ2h0QXJOSmN5UmlnaHRybG1wcnVyZWw7SW50ZXJzZWN0aW9uTm90U3VjY2VlZHNTbGFudEVxdWFuY2VkbkxsO25lYXJoaztDaXJjbGVUaW1lcztsb3dhc3Q7cGVyY25XY2lybnNob3J0cEFwcGx5RnVuRG93bkxlZnRSR2NlZExvbmdMZWZ0UmlnaHRscmhhcmRpbnRlZ2VBbHBiaWd1cGx1c3N1cHBsdXNsb3pmQ2x0aGlja2FwcGR1YXJybmV4aXN0c29kc29Mb3dlckxlZnRBcnJvdztib3hqb3BmRXhwb25lbnRpYWxFO09FbGlnO0dyZWF0ZXJGdWxsRXFaZXJvV2lub3RpbmRvdDtJbXBsaWV1bGNvQ29udG91ckludGVic29saGluY2FyZUxlZnRSaWdodFZlY2VwYW50cmlhbmdsZXJpZ2h0O0ZpbGxlZFZlcnlTbWFsYXBhY2lyYm94dmw7QmVjYXVzZU5vdFByZWNlZGVzU2xhbnRFcGVydGVua2hiYXJQYVRIT1JlcXNsYW50bEludGVyc2VjbnNxc3ViZTtuc3Vic3VjY2N1cmxSZXZldG9lYXJiTWludXNQbHVzO3JmbG9vcjtHcmVhcmZycmFybG1vdXN0YUlFY3lsZXNnZXNyaWdodHNxRmlsbGVkVmVyeVNtYWxsc3RyYWlnaHRwRG91YmxlTG9uZ0xlZnRSaWdodEFycm93O0RvdWJsZUxlZnRSaWdodHJ0cmllO3JpZ2h0bGVmdGhhcnBvb2xvb0Nkb3ROZXN0ZWRHcnBsdXNiO2JOT3RpbWRBZ3RyYXBwbHZlcnRuZXFub3RjbHVic3VpdDt1QXJlcGx1Q29wcm9kZ2pjeTtuZXNlYXI7ZW1wY29sb247bGFjbGc7RG93bkJyZXZDYXBpdGJsYWNrdHJpYW5nbGVkb3duZXNkb3RjaXJFO1VwcGVyTGVmdEFOb3RTcXVhcmVTdXB1ZGJsbGVnO05vdFJpZ2h0VHJpYW5nbGVFWHNjcmJsYWNrdHJzZXhnZXNjYztOb3RFeHZhcnRyaWFuZ2xlcmlnaGxBYWhhbWlvYWNoZWNsc2FxdW87c2lnbWF2RmlsbGVkTG9uZ1JpZ2h0Z2xqTGVzc0VxdWFsR3JlYXFzY3I7Tm90U3Vjc3VicHNkb3RlO29saW5nYnJ1Z3JhdmU7Y3VldmFycHJvcHRvVWJyZXZlO3B1bmNzcFVhcnI7Y3Rkb3Q7dWxjcmFybmxzaW07anNlbGVmdGFycm93dGFpbGRzdEdjaXJSaWdodEFuZ2xlQmd0cXVlc3RWZXJ0aWNhbFNlbGRyc3VjY2FwcEJyZVVwcGVyc3Vwc2V0ZXFxUmlnaHRUZWVBYmlnd2NoZWNrbWFHcmVhdGVyR2xuZXE7YWFhcHByb3hlcTtzbWFsbHNldG1pUmFycjtyaWdodGxlZnRhcnJvc2R2bnN1YnN1Y2NlcTtOb3RUaWxkZUVxdWFsO2N1cnJlYm5lcXVpdnJpbndlaXN1Y2Nuc2ltO25wb2xyc2NyO3JhZGljQ2NpcmM7RGFnZ2VyO0dhbW1hY3N1cFlhY3VEb3VibGVMb25nTGVmdEFycm93O1RyaXBsZURvdDtMb25nbGVsb2Jyaztkb3duaGFycG9vbmxlZnQ7dGNub3ppZ3JhcnVwaGFycG9vbmxlZG9sbGF2YXJzdWJzZXRuZXFxT2dyYXZlO2NvbG9uZXFMZWZ0Q2VpbGluQWdTSENIY3k7YW5kRG93blJpZ2h0VGVlVmVjdG9mcmFjNzhsdHF1ZXN0Q2VkaWxsR3JlYXRlclNsZHNjeW5yaWdodGFydXBoYXJwb29ucmlnaEFjaXJ5dW1sO0FhY3V0ZWNvbmc7ZnBhcmJzaW1lSnNlcmN5YmFja2Nvbmc7eHJBcnJMZXNzRXF1YWxHcmVhdGVyO0REb3RyYWhkO1RoaW5TcGFicnZiYXI7U2hvcnRMQWZyO3Zhck5vdFJpZ2h0VHJpYW5nbGVFcXVhc2VhcmhrO29taWNyb25hYmxhO0RvdWJib3hVTDtzdWNjc2ltO2l0O0JhcnZOZWdhdGl2ZVZlcnlUZWdzZG52ZG9yZGVyb2Y7bG90aW1ucGFyYWxsZWw7UmlnaHREb3duVmVjdG9yQmFMZXNzTENpcmNsZVBsdXByZWNuYXBwcm94O1RmckNsb2Nrd2lzZUNib3dPbWFjcmdicmV2TG93ZWN1cmFycjttRHJvYnJrTm90UmV2ZXJzZUVsZW1lUmV2ZXJzZVVwRWVxdWl2REQ7YmlndXBsVXBwZXJSaWdodEFycm93bHRkQWN5O3Bob25jd2NvbmluaW50TmVnYXRpdmVUY2hlVGlsZGVUaWxka2dyZWVOZWdhdGl2ZHVoc3VjY2N1cmx5ZXFVYnJjeTtVbmlubGVzc2JveGRMO3BvdW5kZG90c3F1YXJTaG9ydFVwQXJyb3d1cHNpaDtUU2N5O2lzY3I7TnU7T2FkdGRvY2lyY2xlZFI7TG93ZXJMZWZ0QXJyb05vdFJldmVyc2JveHVSUGx1c01pbnNjbnN1cGRva3NjZXNoeWx0Y2NtbGRyUmlnaHRBbmdsZXVhY3VsYWZzY3JOZWdhdGl2ZVRoaWNrU3BhY2VUaWxkZUZ1bGxtc2NyO2d0bFByaWdodHNxdWdlcztwbGdzaW07UnJpZ2hlbWFjcjtTdWNjZWVkc1NsYW5yc3F1b0pjaXJjO05vdEdyZWF0ZXJUaXZlcmJTdXBlcnNldDtSaWdodFVwVGVlcGx1c2NpUmlnaHRBbmdsZUJyYWNrZXRuaWNpcmNsZWRTO2NjYUNvbnRvdXJJbnRlZ3JhZWdzZG90VGhpY2tnZTtMZWZ0QW5ubGRybHREc3R2YXJ0cmlhbmdOb3RHcmVhdGVyR3JlYXRlY2VtcHR5djttZWFzY3VkYXJybDtEY2FydmNidU5vdEdyZWF0ZXJTbGFudEVxdWJsYWNrc3FjdXBjdXA7emV0YU9jeXhyYXJybmhwYXJsbmVxcTtzdWJzdWI7ZmxsaWdMZWZ0RmxUaGRhc1JmcjtjeWxjbWFsdXRyaWY7SWdyYWxlc3NldGltZXNiO25oQXJybG5zaW07Zm9wY2lyZlRzdHJva29mY2lyO0V4cGxlZnRyaWd0b3Bib3N0cm5zO25SaWdodGFycnJpZ2h0cmlnaHRhcnJvd3M7bnN1Y2NlcTtDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVnUmlnaHRWZWN0b3JCYXJjd2JhcndlZENhY2JveHZodmFyc3Vic2V0bmVOb3ROZXN0aGVyZWZvck9wZW5DdXJseUtjRG91YmxlQ29sbmFwcHJveG1oZ3RjYWNFbmx0ZGRhcnJTSEN0aW50O2JyZXZtZWFzdXJlZGFuZ2xlbmxlZnRyaWdOZWdhQUVsTGNhcnNmcnF1ZXN0ZXFzY0RvcGZpbnRlZ2VycztOb3RQcmVjZWRlc1NsYW50RXF1TGVmdERvdWJsZUJyYWNjb21wbGVtYXdpbnRoc2xhc2hkb3BkcmJrTGVmdFRyaWFuZ2xEb3duQXJyRG90VGlsZGVUaW1vYmxhY2t0cmlhbmdsZTtTdWNoVGhhdDtib3h1bWlkZG92bHRyYmlndXBsdXM7Z3RjaXJuR3R2Tm90SHVtcEhpbGJlcnByc2ltO2NvbG9uZTtudkludmlzaWJsZUNvbW1hO05vdFN1cGVyc2V0d3JVbmRlclBhcmRvdWJsZWJhcndsaGFyZHBvcGY7dUFycjtsZWZ0dGhyZWl1a2NIdW1wRG93bkhwcm9mc3Vic2V0ZWNhcGNhcGxnRTtWRGFzaDtvdGltZXNhcztsZHJ1c2hMYW5nO2lzaXpjYVJldmVyc2VVcEVxdWllcXZwYXVicmV2cmRxY2VudDtJZGVzaW07YmxrMW52bEFkaWFtc05lZ2F0aXZlVmVyeVRjdHJpbWluUmlnaHREdmVlZWxlZnRyaWdodHNxdWlnYXJyb3c7SW50O2ZsdG5zZ3Rkb3RlcWNvbG9sb29wYXJyZG93bmFycm93O29sdDtjZWRpbDtPcGVuQ3VybHlEb2VsaW50ZXJzO25HdDtVbmlvblBsdXNzcWN1cHM7TGVmdFJpZ2h0VmVjdG9yO2R0ZG1ob0RvdWJsZUxlZnRUZWU7bmxlZnRyaWdodGxlZnRsZWR6aWdyYXJTcXVhcmVJblpmcjttaWRkb2xhck5vdExlcWZhc3ltcGVxc3FzdWJzZUxvd092ZXJQYXN1YnNsZWZ0cmlnaHRoYXJSaWdodFRyaWFuZ2xlRXFvdGltZWNvcHJvZDtubXNpZ21hdjtSaWdodFVwRG93blZlY3NjbkU7SmN5O05lZ2F0aXZlVGhpbnF1YXRlcm5pb25zO3N0cmFpZ0xlZnRWZWN0bHNoU3VjY2VlZHNTbHNvcGdhY3VHcmVhdGVyTGVzc0Rvd25BcnJvd0JhcjtVcFRlZUFJSmxDbG9zZUN1cmx5RG91Yk9hY3V0ZUxsZWZvbWljUnVsZURlbGF5ZWQ7TGVmdEFyRG91YmxlVmVydGljYWxCeWlsZXNzZ3RTcXVhcmVTdWJzZXRFcW5hdHVyTGVmdFVwRG9uamN5R3JlYXRlckdyZWF0ZXI7UmV2ZXJzZVVwRXF1TG93ZXJLSmNwcmVjYXBwcm9Eb3BiaWdzcWN1cDtDYXlkbGNyb3BzcWN1cHhtRG91YmxlTGVmdFJpZ2h0QXJyb3JCYXJyTm90U3VjY2VlZHNFcXVhY2FjdXNlYXJodmFycGhkdHJpbnZsdEF0aWxkZVVwQXJyb3dEb3duQXJyb3Nxc3Vwc2V0ZXFuY0VxdU5vdExlZnRUcmlhbmdsZUJhcnRvcGNpckxlZnREb3ViemlncmFMZWZ0VGVlQXJyb25lc2ltTm9wZjtudmdlc21hbGxzaGFycjtpamxpZ0V4cG9udGN5O2R6aWdyYXJyO3BybnNpU21hbGxDcGFyYWxsZWxBcHBseUZ1bmN0aW9uO25sZWZ0c2hjaGNVYXJyTGxlZnRhcnJvbGVzc2d0cjtycnRock5lZ2F0aXZlVGhpY2tTcGF0d29oaWlvdGFzY0U7bGFlbXB0UmV2ZXJzZUVsc3VicmlnaHRzcXVpZ2Fycm9CZXJub05vdEdyZWF0ZXJKb3BkcmNvaEFyckNhcGl0YWxEaWZmZXJlbnRpYWxEO25lZG90TmNlZGlzaW1sRW1hcHN0bztTaG9ydFJpZ2h0QXJyb3c7c3VwMjthbWFsZ2hhcnJjaXJleHBvbmVudGlhbGU7TGVmdFRyaWFuZ2xlRW5zdXBzZUxvbmdyaWdodGFycm93O1JpZ2h0RG93blZlY3RvcnJtb3VzdGFjaGVnZXNkb3RvbE5vdFNxdWFyZVN1YnNuZXhpdGhpbnNwO1NIQ0hjQnNjcmd2ZXJ0bk5vdFN1ZmFsbGluZ2RJRWN5O3VydHJpO3ZwcmxmbG9tYXBzdG9kb3duYmlndHJpYW5nbGVkb3duO0Rvd25MZWZ0UmlnaHR0cmllb1NpZ3Jsb25nbWFwc3ROZXN0ZWRMZXNzTGVzcztzcXN1U21hbGxDaXJjbGU7dnN1cHpjYXJvQmVybm91bGxpc2xuTG9uZ2xlZnRhcnJkZmlzaHQ7Ym94dGltZXNib3R0b0VhY3V0ZTtNZWxsc2xhcmxuc2l4bWFzb2Z0bWlkY2lyaXNpRGlhY3JpdGljYWxEb3VmamxpZ0NheWxleXNJY2lyYzt1dHJpZm5sZWZ0cmlnaHRhckNhcGl0Y2FybmFjdUdyZWF0ZXJGdWxsRXF1YWw7a3Njcjt2ZWxsaXBBb3BzcWNhcGVtYWNoZWFydHN1aUdyZWF0ZXJGdXZhcnRoZXRCZXRhO05vdEdyZWF0ZXJTbGFuQWNyZmlzaHRFeHBvbmVudGlhbEVramN5bnJhcnJhdGFpbGx1cmRzaGNjZWRpbDt6d25VbmRlckJhcnN0cm5zZWNpcnJkbGROb3RHcmVhdGVyTE5vdEdyZWF0ZXJFcXVhbDtVZ3JhdmU7d3NjdmFycHJvcHRvO3NzY3N1cG5lO3N1Ym11bHlvTm90TGVzc0xlc3NVbmlvbkFwcGx5bHVydWhsb3BsdXM7ZGVsdExsZWZ0YXJyb3dndHJQYXJ0aWFsRDtGaWxsZWRWZXJ5RG91YmxlVmVydGljYWxCYXI7Y2lyZm5pbk5vdEdyZWF0ZXJGdWxsRWZqbHhoYUxlZnREbnVtc3A7TGVmdHJpZ2hSaWdodFVwSHNjTGVmdFVwRG93blZlY0xlc3NFcUhjaXJjcm9hcnJOb3REb3VibGVzbWVwYXJzQ09Eb3duQXJyb3dVcFZkcGVyY250O092ZXJOb3RSaWdodFRyaWRoYXJDZW50ZXJEb3Q7c2ltcmFUaGVyZWZHcmVhdGVyRnVsbEVxdWlhb2ZjaU5vdExlc3NHcmVhdGVjb25nZG90TGVzc1NsYW50RXF1YWw7Y3Vwc2Vuc3ZhcnRyaWFuZ2xlbGVmdFJCYXJyb2xpbmU7bmxlZnRyaWdodGFycm93ZXBsdXM7bmlzZ3NjckRhc2h2O2Vtc3N3YXJoaztEb3VibGVWZXJ0T3BlbkN1cmxjaXJjbGVhcnJvd2xlZnRuYWJFcXVpVmVydGljYWxTZXBhcmF0b3JscmFyY3VybHl3ZWROb3RIdW1wRG93bkh1bXByaXNpbmdkc3VjY2VOb3RSZXZlcnNlaG9yYmFyO3ljaXJFZG90aGVhcnRzdWl0O3VoYXJyO0RvdWJsZUxlZnRSaWdodEFycm93O3ZydHJuc3Vic2V0ZXE7VXBEb3duQU5lc3RlZEdyZWF0ZXJHckxlZnRyaWdjb21tYTtSZXZlcnNlRWxlbWV1aG5ndHN0cm9reHJBcnI7UmlnaHRBbmdsZUJyYWNrTm90U3VwZXJzZXRFVW5kZXJQY2FwYnJjdXB0d1RpbGRlRXF1Q29udG91cklub2Rhc2xicmRsY29yTG9uZ0xlZnRBcnJvdztBc3NpY29weXNyY3VybHllcXByUnJpUmlnaHRhcnJCZmJveHBPdmVyQnJhVXBwZXJMZWxmaWxhZ3JhR2NyaWdodHJpdkFycjtvZFJpZ2h0VGVlO29oYmFyc2Nwb2xpbkFvZ29uTGVmdEFycm93O0dzb2Rhc2hjdWVwcjtQbGNjYm94bWludXM7VGhpY2tTcHJzcXVvcktvZ3JhdWJOb3RSaW52RGFzaDtiaWdvdGlVYnJHcmVhdGVyRXF1YWw7d29wZjtQb2luY2FyZXBJbnZpc2l1dGRvQ2xvc2VDdXJseURkaWFtb25zY2FscGhpb2N5O2Jicmt0YnJmcmFhbXA7bnVtZXJBcHBseUZ1bmNjaXJjbGVkY2ljYXBhbmQ7Y29tcGxiaWdvbnZndEJldHN6bGlnO3N1Y2NlcXVwdXBhcnJvd3NzaW1yYXJybG9wbHVwYXJyb3dQc2k7YmxhY2tzcXVhclJpZ2h0VHJpYW5nbGU7R2N5O252bENpcmNsZURvZm9yYWxsZ3Ryc2ltO21kYXNoRG91YmxlTGVmdFJpZ2h0QXJhZWxpZztMZWZ0Q2VpbGhvcHJubWl0cmFyaXNpbmdkb3RlcWNpcnNpbXJhck5vdFNxdWFyZUxjeTtzZWFycm93O29sc3FjYXA7TGVzc1RpbGRlZURvaG9va2xlZnRhcnJvd01lZGllYXN0ZXI7UHJlY2VkZXNFbnZpbmZpemlnZ29wZlJjYXJvbmNpcmZuY29uZ0NvbmdyZGNudGlsZGNpcmNsZWRhc3Q7TG9uZ0xFbXBsdHJpO25zaW1Ob3RDdXBDYXBJbnRlcnNlY3Rpb3Jtb3VzdGN1cGRvdDtTcXVrb3BmO0VtcHR5VmVyeVNtYWxsU3F1cmJya3NscnRyaTtUY2FSaWdodFRyaWFuVXBwZXJMZWZ0QXJydXRkb3Rib3hIVTtTY2VkaWxsb25ncmlnaGR1YXJ0aGlja2FwcHJveHZhcnN1cHNlRG91YmxlTGVmdFJTaG9ydERvd25Bcm5zdWJFTm90TmVzdGVkR3JlYXRlckdyZXFwcmltZVZlcnlUaGluU3BhY2dlc2RvdG87QnJldmJpZ2NhdWFjdXRIb3Jpem9udGFsTHZhcnN1YnNldG5lcU5vdEdyZWF0aXVzcXVEb3duUmlnaHRWZWN0b3JOb3ROZXN0ZWRHcmVMZXNzRXF1YWxHaWZmT3BlbkN1cmx5RG91YmxlUXVMZWZ0VmVjdG9yQmFMZWZ0VXBvZWxpZzt1d2FuZ2xTbWFsbENpcmNsbGxjb3JuZXI7b2xjaXJEaWFjcml0aWNhbFRSdWxlRGVsYXlOb3RMZXNzU2xhbnRFcXVhbDtsZWZ0cmlnaHRzcXVpZ2JsYWNrdHJpYW5nbGVyaXNtYWxsc2V0bWludWptYWRjYXJvbnNlc3dhckVtcHR5VmVyeUNsb3NlQ3VyVmVydGljYWxCYXI7THN3ZWRkemlncmFycnRhdTtMYXJyO21pZGNDYXBpdGFsRGlmZmVyZW50aWFib3hVTGJveHZMUmlnaHREb3VEc2NyO05vdFJldmVyc2VFcmlnaHR0aHJlZXRpbWVzO1Nob3J0Umlac2NyO3JhZ2VzbGVzbmxlcXNsYW5yaW5nO1NxdWFyZVN1cGVyc2V0RXFvbGNyb3NzO3RyaXBsdXM7c3FjYXBzQ2Nhcm9uO25lcXV1cGhhcnBTdWJNaW51c05vdExlZnRUcmlhbmdsZUJhT3ZlclBhcmVuT3ZlclBhcmVudFBvaW5jYXJlcGxhbmVOdGlsc3dhcnJwc3VwZG90O21pUmN5SHN0cm9Eb3VibGVDb250b3VySW50ZWdySWNpcmNwZXJpY2lyYztib3h0aWhlbGxyaGFydVVyaW5nO1NxcnRzYztFbWFjU0hDSGN5UG9wbG9uZ3JDSGN5O1NmcjtucmlnaHRuY29uZ2RvdHRoa2FiYWNrTm90R3JlRG93bkxlZnRUZWVWZWN0Q2lyY2xlVHVncmF2c2ltZExvbmdsZWZ0cmlnaHRhcnJvd09yO1JpZ2h0VXBWZWN0b3JCYXhzTm90VmVycm9hbmc7TGVmdEFycm93UmlnaHRBemVldHJmO1JpZ2h0VGVlQXJyb3diZW1ybm1zdWNjYXBwcm94O0xlZnRVcFRlZVZndHJhcnI7a2NlZGlsO2NpcmNsZWRhbGFycnNpbUxtaWRvbGVmdHJpZ2h0YXJyeHJhUmlnaHRVcERvd25WZWN0b3JubEVMZWZ0UmlnaHRWZWN0b0djZWRpbG1vdXN0O25nZU5vdEdyZWF0ZXJFZW9nb247Z25hcHByb25zdWJzZXRlcXNlQXJydXB1cGFOY25nRXZzdWJuZTtQcm9wb3J0aW9uYW9wZU5vdEdyZWF0ZXJMZXNzRG90RXF1YWw7bG93YmRxTGVmdFVwVmVjdG9yTm90R3JlYXRlckVxdWFydWx1aGFyO1ZlcnRpY2FsQmFyeHNxY3VwZXRhO2NyY3VkYXJyck5vdFNxdWFyZVN1cGVyc2V0RXF1YWw7ZWFjdXRlTmVnYXRpZGRhZ2dlcnN1Y2NuZWxvbmdsZWZ0YXJycHJuRTtFb2dvbjtDYXBpdGFsRGlmZmVyZW50aWFsRGd0cU5vdEN1cENhcDt0b3BjaXN0cmFpZ2h0cGhpO2ljeWV4cGNlZGlsQ2VudGVyRG9hcGFjaXI7cGhvbmU7RG91YmxlVXBEb3duQUxlZnRUZWVWQXJpbmJpZ29kY2NhcmxkcGxhbmNtSWFjdUVtcHR5U21hbGxTcVVuZGVyQmFwcHJveGVOb3RHcmVhdGVyRXF1RGlhY3JpdE5vdEdyZWF0ZXJTbGFudEV2ZWViY2lyY2xlZGRhc2g7Y2FwY2FSaWdodEFyRXF1aWxpYnJpdW07cmlnaHRoYXJwb2FuZ21zTm90TGVmdFRyaWFuZ2xlO3dmcjtwcm9mYWxhcjtEb3duQXJyb3h3ZWRnZTtOb3ROZXN0ZWRHcmVhdGVyR0tvaXNsZmlzaE5vdFN1Y2NlZWRzRXF1YWN1RG91YmxlTGVmdFRlZWVkRG91YmxlTG9uZ0xlZnRSaWdodEFycmxvdGluaGF0c2hjU3Vic2V0RXFudnNjdXJ2ZWFycm93cmlnaHRMZWZ0Q2VpbGluZztsSGF1bnNob3J0cGFzY2Fyb0RpYWNyaXRpY2FsQXBhbnByY0ljaXJhb2ludGVnZXJhY3lpc2lucztMZWZ0cmlnaHRhcmNOb3RUaWxkZVRpbGRIb3Jpem9udGFsdXRyaTtSaWdodFRlZUFycm93O0ludGVyTm90TGVmdFRyaWFuZ2xzdWJzZXRuZXFxaXVrdGhldHZEYXN1cHNpbG9uO2Vxc2lDbG9ja3djdXBvcjtUY2VkaWxJbkFicmV2U3F1YXJlaW50Y2FsbmhhcnI7bnNob3J0cGFyYUNvbmdydWVucGx1c21uY2hlY2tzaGFycDtEaWFjcml0aWNhbERvdHByb0xvbmdsZWZ0YXJyb2tmcnJlZztScmlnaHRhcnJvdztyb3BmO0Vwc2lsb3pjVmVyeVRoaW5TYXRpbGRlZm9yaztzdXBzZXRldXBkb3duYXZhcm5vdGhpTGFwbGFjZWZlbWFIdW1wRURvdWJsZXJpZ2h0dGhyZWV0aWxlZnR0aHJoeWJ1bGRzdHJvaztjdXBvcnRoZXJlZm9QaWxtb3VzdGFjaGNjYXBzTmNlR2JyZUludGVnclRoaWNrU3BhY2U7RG91YmxlQ29udG91ckludGVncmFsO2ltYXRzZXRtaW51c25ndFZjb29sdm5Eb3duUmlnaGhhbWlsdHJhcnJiZmJhcndlZGdlO2NzdWJlbGFuZztOb3RQcmVjZWRlc1NsYW50TG9uZ0xlZnRSaWdPcGVuQ3VybHlRdW9tZEdkb3RwZXJwO1N0YXI7bnJhcnJjYm94RFJMZWZ0QXJyb3dSaWdodEFyaWdyYXJhcnJmZ2FwO1Nob3J0TGVmR3JlYXRlclRpbGRlZHRyZG93bmhhcmNvbmlkZG90bEFhcnJubGFwbGFua2FjaW1pZGFzdDtyY2Fyb09ncm5HZ2xhbmdsVmVyeVRiYWNrY29mcGFydGludFVmcjtiaWd3ZWRnZWludGVyY2F0aGV0YXN5bVByb3BvcnRpb3JhZW1wdGxzcXVvdXdhbmdlcXVlc3NvbGJhcjtHcmVhdGVyckhhdXBzaWx0cmlhbmdsZXJpZ2h0aXNpbkVvZ29uO0dKbG9vcGFycm93cmlnaGxhcXVvYW1wRG93bkxlZnRSaWdodFZlY3RvbWFwc3RvbGVmYmlnb3RpbWViaWd0cmlhbmdsZWJveHZoO3N1YmRvdGlpb3RtYXJ0d29oZWFkbGVndHJkb3RGb3JDYXlsZXlDbG9zZUN1cmx5RG91YmxlUXVvdGU7T21pY3Jvbkd0djttbk5lc3RlZExlc3NMZXJwYXJndExlZnRSaWdodFZlY3RzdGFyZjtCZWNhdXNsZWZ0bGVmYWJyZXZlcmJya2U7c3VwbGludGNhbDtmZmlsUmlnaHRBcnJvd0xlZnRBcnJOb3RTdWNjZWVkc1RSQnVtcGVxO2JveG1pbnVzSGNpcktIY3k7T2RzcGFydHJpYW5nbGVsZWZ0O3NyYXJybmZpY2l0cnBleml1bXNjcG9saW50eHNxY3VwaGFyZ25lcXFzZnJvcGx1c2R1O2NvcHJSZXZlcnNlVXBFcXVpbGlicml1bTtsZHNBcGJveEh1eG9wbHVyYmFycjtTbWFsbENpQ2xvc2VDdXJseWljO0Rvd25BcnJvd1VwQXJyb09wZW5DdXJseURvdWJsZWNhcm9uO3VoYmxrO2JhY2tzaW1lcWJldHdlZW5yYWRpYztvcnZOb3REb3VibGVWZXJ0blZkYXNoO25jb2d0cmxlc3NFVEhzdXBoc29wcm5zaW1zcWN1Z3Jhdm5vdG5pdmNzaW1lcTtPc2NzaW1uRmlsbGVkU21hbGxzcXVvcjtBbHBoYU5ld0xpZGl2b3hkdHJpbmxzaW1udHJsc3Ryb2JpZ3dlZGdOb3RMZWZ0VHJpTmVnYXRpdmVWZXJ5VGhpblNwbnZyQXJOb0JJbnRlZ2tzY0hzdHJOY2VkTGVmdFRlZVZlY3RvcmFwRTtOb3RMZWZ0VHJpYW5nbGVFUmlnaHRUcmlhbmdsZUJhTXNSaWdodFZlY3RvckJuc2hvcnRwYXJhbGxMb3dlckxlZmxIYXI7ZmpxdWF0aW5uY2Fyb3N1YnNldG5lcTtwcmVjbmFwRWNhYm94VVJQcmVjZWRlc1RpbGRwYXJ0RGludWJvdHR3ZWllcnA7Tm90UmV2TEpjeU50aWxkT3RpbWVzRG91YmxlUmlnaHRBcmpzY3I7bGJyYWNlO0Rvd25UZWVpbmNhcnVyY3JvcGJpZ2NVcHBlclJpZ2h0QURvd25SaWdodFRlZVZlaW1hZ2U7RG93bkFycm93VXBBcnJzdHJhaWdodGVwc2lOb3RTdWNjZWVkc0VxdWFsO1FvcGY7RG91YmxlUmlnaFNtYWxsQ2lyY2xlRWRJbnRCb1Nob3J0UmlnaHRzcXN1cHNldDtjaXJjbGVkY2lyYztFbXB0eVNtYWxsU3F1eWFjeTtsYnJrc0RvdWJsZUxvbmdSaWdodEFycm93cmVhbGluVW5pb25QbEF1bUdyZWF0ZXJFcXVhbExlc21pbE5vbkJzY2U7WmZyZWdyYXZlbHRjYztucHJjdWVHcmVhdGVyRXF1YWxMZXNzO3NpZ21hZm9TO2V4cG9uZW5sYWN1ZnJvd247R2NlZGlsO3JzcWJOb25CcmVha2luZ1NwYU5vdFNxdWFyZVN1cGVyc2V0RXFzZXRtaW51Y2VtcHR5c2lnbWFNaW51c1BsUmlnaHREb3VibGVCcmFjbGFycnNpc3ViZG90O2VtcHR5bG9uZ2xlZnRhcmNhcGFpZXhjbG5kVXBBcnJvd0JhYm94Vmw7dHJpYW5nbGVkb092ZXJQYXJOb3RMZXNzRXNpTHNjcjtubGVxO3JjeTtsb3plbmducHJlY2VxO2VmRHlpY3k7cXByaW1ub3BmbGZyO3JhbmdkdGhrYXA7Ym5lcXVpT3ZlckJyYWNlZnBhcnRpbmJpZ29kb3RSZXZlcnNlRXF1aWxpYmVwc2l2O05vdEdyZWF0ZXJTbGFudEVxdWFwbHVzc2ltO0ZpbGxlZFZlcnlTbWFsbFNxdWFyZUJyZXZlVXBzaWxsZXM7d2VpZXJlYWw7Z3Rkb1JpZ2h0Q2VpbGluZztvc29sU2hvcnRSaWdoTmVnYXRpdmVWZXJ5VGhpblNwYWVhc3RlcmRibGFDY29uaW5uaEF1c3RjYXJvbnJmcjtOb3NjaWlzaW5zdjt5YWN1dGU7bnNjY3VlY3VsbnRsZ25HTGVmdFVwVGVlVmVjdG1mcm9taWRnZXNsR29wZkltYWdqbWF0TGVmdEFycm93QmFyO2R1Q2xvc2VDdXJsYm94Vjtob3JiYXJnYWNsaGFyZDt5YWN1ZXF1ZXN0RG91YmxlVXBBcnJpZ2h0aEVtYWRsY2xhZW1wdHl2U21hbGxDaXJjc21pTGVmdEZsb05vdEdyZWF0ZXJGdWxsRXF1YWw7RG91YmxlTGVmdEFMY2Fyb25lY29Pc2NyO1RjYXJvUmNhcm9uO25zaW1lYmlnTm90U3VwZXJzZU5lc3RlZEdyZWF0ZXJHcmVhdFpzY3JjYXJvY2VtcHR5dnBjeTtLYXBwZG93bmRvbGVmdHJpZ2h0aGhlYXJ0U3F1YXJlU3VwZXJzZW1wdHlzZXQ7Z3RsUGFyO05vdExlZk5vdENveGxBTG9uZ1JpbHBhclV0aWxoZWlvZ29sZWZ0cmlnaHRhcnJvbGVmdHRHb3BmO2VvcG9pbnRpbmRyY3JvcDt0aGlja0NvbG9uZTtVcGRvd25hcnJMZWZ0RG93blZlc3VwbXVscmFxdW9DdXA7ZGFzaHZuc3FzdXBOb3RTdWNjZWVkc1RpbERvdWJsZUxlZnRSaWdodEFDZG90O2hzY0xlZnRSaWdoSHByZWNlcTtGb3FkcmNyb3ZhcnNpZ21hb2VsZEFycmJhcnVydHJpcmlzaW5wZXJpb0xjc2NuYXVyY3JvcDtwcmN1c3FzdXBlY3VlcHN1YnBsdXNHcmVlbXNwMTQ7Ymlnb3RQcmVjZWRlc0VxdWFsO2xtaUxlc3NTbGFzdXBlO2NoZWNrbWFyaW1wZWRDSGN5TWVkaXVtU3BhY1JpSHNjcml1bWw7bGFuc3N0YXJmcGx1c2RvO2duYWxlZnRyaWdodGhhcnBvb25zO0Rvd25MZWZ0UmlnaHRWZWN4ZnJjYXBzO25wcmU7Tm90RXhpc2NhcGRvUmlnaHRUcmlhbmdsZUVxdWFsYnVsbGV0O2JhY2twcmltZTtzZG90YnNob3J0cGFyYWxsZVNjaXJZY2lyaW5maW50TmV3TGluZXZlbGxpYmlnc3RhbHRkb3Q7ZGxjcm9wO1J1bGVEZWxheWVQcmVVdWRyYmthSG9wZjtzb2Z0Y3lVcHBlckxlZnRMZXNzR3JlYXRlcjtWdmRpdmlkZW9udGltZXM7WmFjdXRMYWN1dGU7bnZpbmZpbjtob29rcmlnaHRhclJpZ2h0RG91YnZhcnRyaWFuZ2xMZWZ0RG91YmxlQnJSaWdodEZjdXJseXdwdW5jc25nZXFzbGFoYWxmO1JldmVyc2VFcXVpbGlicml1Um91bmRJbXBsaWN1cnZlYXJOb3RTdWNjZWVkc1NsZG93bmhhcnBvb25yaWdoZXBzaWxvbjtob29kdWhhcjtucmFycnc7U2FsZGN2ZXJuc21pZFpjeWJlcm5yaWdodHRocmVlU2FjYmVybWhvO2xhdGFpbHRyaXRjZG9sZXNkb3Q7TmVzdGVkR3JlYXRlckdyZWF6d25qZWdyYXZlO2xuYXBwcmxlZnRhcnJvd05vdEN1cENhbWludXNkbG9uZ2xlZnRyaW9zbGFzaDt0c3RvY2lyY25vdGludmE7bGVmdHJpZ2h0c3F1cHJhdmZ0b3BjZXhjbENoaUNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYUxlZnRBbmdsZUJyYWNrZXQ7ZnJhYzNiZXJub3VhbmR2O1RoaW5VcERvd25BcnJvQ291bnRlckNsb2NrZ25FcGx1c2RvTXU7WmVyb1dpZHRoU3BTY2Fyb25Ob3RUaWxkZUVxdWFyaGFyZG5lZG90O3N1cHBXZnI7c2hjeTtTcXVhcmVTdWJzZXRFcXVhbExvbmdsZWZMc3RuZWFybnNjcnN1cDt0cmFkRG91YmxlVXBEb3duQXJyZXFzbGFudGxlc3M7ZHJjclVwQXJyb3dCZ3NpbWw7Q29wcm9kdWNOb3REb3VibG5jeTtHcmVhdGVyRXF1YWxMaXNjblJpZ2h0Q2NpcnJhZW1wdHl2cmFycmJmc3N3YXJyb2xzcWx1cmRzaGFyO2lub2R1aGJsa0ZvdXJpU3VjY2VlRERvdHJhaHRyaXRpbURvdWJsZUxvbmdMZWZ0UlRpbGRlRnVsbEVEaWFtb25kUmV2ZXJzZUVsZW1lbnQ7dmFya3JhcnJzaW07bnJ0cmllTm90SHVtcERvd0dhbW1hO2J1bXBlO2VmRG90c21hbGxzZXBhcmFsbHJkbGRoYXI7YnNvbGhzdWJyYW5nbGU7eHNxcGVybWlsO0NvcGY7T3ZlclBhcmVudGhlc2lzb3RpbWVzO3NzbWlsTGVzc0V0cmlhbmdsZXJpZ2h0O0xhbWJkdHJpbWludXNDb3VudGVyQ2xvY0xlZnRyaWdodGdyYU5vcGZuZ3NpbTtoYW1pbHQ7Tm90UmV2ZXJzZUVsVXBwZXJMZWZ0QXJyb2N1clZmcjtTdWJzZXQ7c2ltZVJpZ2h0VGVlVmVjYW9wU3VjY2VlZHNFaGVsbGlwO3RyaXNtYXBzdG9sZXZEUHJpbWVndm5FO2xhcnJzaW07endqO25lYWthcHBhdnZhcnN1cHNwbGFuY2s7RG93bkFycm93VUNlZGlzZXh0O21wbGFuZ2xlYW5kZDtoYWlkYXNodjtkb3duaGFzdXBzZXRuZWVxY2lyYztvcGVybnZEYWJydmJhWmVyb0xlZnRBdXRpbGR4bWFwTWVsaHNsRG91YmxlVmVydGljYWxOb3RMZXNzRXFEY2Fyb25Ob3ROZXN0ZWRMZXNzTGVzcztyaXNpbmdkb3RzRmlsbGVkVmVyeVNtYWxsU3FOb3RUaWxkZUZ1bGxEb3duUmlnaHRWZWN0b3JCYXI7bGFyck5lc3RlZGRvd25kb3duYU5vdFN1Y2NTYWN1bmFjdXR1cmNvcm5lYW5nbXNkYWQ7RWNpcmM7U3VjY2VlZHNyYWN1T3RpbGRlZ2VzbGVzO0Rvd25BcnJvd1VwQXJyb3c7bGVmdHJpZ2h0YXJyb3dzZWxzZHJpZ2h0YXJyb05lZ2F0aXZlVGhpY2tTZ2JyZXZlY2NlZGlsc3RhcmZpbjtyaWdodGxlZnRhcnJvd3M7UmlnaHREb3VibGNvbmdkdnN1Ym5lRG91YmxlTG9uZ0xlZnRBQmVjdHJpYW5nbGVsZWZ0ZXFSY2VkWmVyb1dpZHRoU3BhY2Nhcm9uZG90c3F1YXJlbmVhcmhvcmRmbmN5cmFycnBsY3VydnZsdHJpO3N0cmFyaWdodGhhcnBvb25kTm90RG91YmxlVnRoa2Fwc3RyYWlnaHRlcHNsZHNoQ2NlZGlsO0RvdWJsZUxlZnRSaXVwYXJyb3c7ZG90ZXFkb3Rsb3BmRERvdHJhaGRjYXBjdXA7Z25lVmVydGljYWxTZXBhck5vdExlc3NTbGFudENsb3NlQ3VybHlEb3VibGVRdW90ZUdzY3I7VmVydGlzcXN1YmVndHJzYnVtc3FzdXBzZXRlcTtHYnJuc3BhcjtZYWNEb3VibGVDb250b2JzaHlidWxsO3plZXRyZnZhcnN1YnNib3d0aWU7ZUREbG90aW1lc1NxdWFyZTtOb3RMZXNzO3BpdjtPcGVuQ3VybHlEb3VibGVEaWFjcml0aW5yYWJicmt0Yk5lZ2F0aXZlTWVkaXVxdWF0aW50O05vdFNxdWFyZVN1cGVyc2V0RXF1YUJyZXZlO3dzY3I7bGVmdGxlZnRhcnJvd2F1bXBybnNob3J0cGFyTm90R3JlYXRlckZ1bGxFcXVWb3BmYmxhY2t0cmlhbmdsZWRvd247TmVzdGVkR3JlYXROb3RTdWNjZWVkc1NsYW50RXF1YWxSaWdodEFycm93TGVmdEFycm93TG93ZXJMZWZ0cm9wbHVzRG93bkxlZnRWZWN0b3JCYXJTcXVhcmVJbnRzaG9ydHBhcmFEb3duUmlnaHRWZWN0b3JCZG90bWlMb3ZlcmJhcnN3bndlZkRvdDtMZWZ0Q2VQcmVjZWRlc1NsYW50RXFaYWNsc2ltZztkb3duYXJzdWJuU3F1YXJlU3Vic2V0RXF1bHJoYXJwcm9kO2JveHRpbWVzO2NpcmNsZWRhc3RzdW5nbGNlZGlBbnVsdHNwbGxhcnJMc3RycmFycmh0aGtzaUxlZnRVcFRlZVZlY1RhdTtsdmVydG5lcXE7VmVyYmFycmlnaHRsZWZ0aGFycHJuYXA7bnJpZ2FjdGF1YXJyTmVnYXRpdmVNZWRjcm9zc25nc25taWRSaWdodENlaWxpZGlzcnRocmVlO05vdExlc3NFcXVDYWN1dGVsRXhkdHJpO2RkYWdnZVJpZ2h0VXBUZWVWZW5yaWdodGFycm9ubGVxc2xCb3BmZGllbWVhc3VyTGVmdEZuc2NlO25jZWRpbDt1cGRMZXNzU2xhbnRFcXVnbmFwO2xtb3VzdGFjaGU7RG91YmxlTG9uZ1JpZ2h0QXJyb3c7c3N0aGtzaW07U2hvcnREb3dubGN1Yk90bGVmdHJpZ2h0aGFycG9lbnNwO29ib3hIdTtSaWdodFVwRG93blZlRGlmZmVyZW50aWFsRDt1ZGhhcmxvYW5kcmV0aHlhY3V0ZW50cmlhbmdsZXJ0cmlhbmdsZXFzcXN1cHNybW91c3RhY0Nsb3NlQ3VybHlEb3VibGVRdW90aXVrY3lsZXNzZXFndFVuZGVyUGFyZW50aGFjaXJjO2hBcnJicmFjTmZyO0Rvd25BcnJvd0JzdWNjbmFwTmVnYXRpdmVUaGlja1NwYWNrY2VkT3NsYXNodERpZmZlcmVuTm90TmVzdGVkR3JlYXRlckdyZWF0ZUVsUW9wZkpjcmlnaHRoYXJud25lYXI7TGxvcmFycjtibGFja3RyaWFuZ0RvdWJsZURvdDtiZW1wdHl2O0FyaXNwYWRlc3VpbnBhcnNtaWxlO05vdE5lc3RlZEdyZWF0ZXJMZWZ0UmlnaHRBcnJvd0xhY3VDb3VudGVyQ2xvY2t3Z3RjaWRvdG1pbnVzO0RvdWJsZUNvbnRvdXJJbnRlZ3JhZ2VzY3RoaWNrYXBuYXBwcm9uUmlnaHRhcnJvdztyZGxkaHVvcGY7UUhmcjthd2NvbnRyaW1pbnVuc3VwZTtuZXNGaWxsZWRTbWFsbFNxdWFyZTtleHBvbmVmYWxsaW5Ob3RDdXBDc3VicmFOZXN0ZWRHZnJhYzU4Z2FtbWE7c3VjY25QYXJ0RG93bkxlZnRUZWVWZWN0b3I7VW5pb25QbHVzO092ZW90aW1lc2d0cmRrZ3JVcFRlZUFyc3BhZGVzO3Nxc3VwZTtWZGFzaGxybERvd25CcmdlcXNHYW1jZW5jaXJjbGVkZGNoY3k7YWJzaW1nO21sZHI7VFNIY3lyaWdodHRub3RpbnZjO25hbmd0YXVBYWNPY2ltc3Rwb3M7b2hiYWJveGRMTGVmdERvd25WZWN0b25wb2xpbmRzb2w7Q2xvY2t3aXNlQ29udG91ckludGVncmFsO3N0YUVzY2xjYXJvbjtsb3BsdXNTdWNjZWVkc1RpbGRlU3F1YXJlU3Vzd2Fycm93O0RTcmJhcnJhbmdtc2RhZTtob3BmO2RmaXBvcGZJbWFmZnI7cHJlY3NkaXZpZGVvckF0YWlsO2xlc3NlcXFndHI7ZGVsQWNpcmNsYXJyYmxvd2JhaGFyZGNjaXJjbGVkUlVhcnJvY3ZhcmthcHBhbG1pZG90O0dyZWF0ZXJTbGFkemlncmFjY2lOb3RMZXNzR3JlYXRlcjt1cGhhcnBvb25sVmVyeVRoaW5TcGFjZTtOb3RHcmVhdGVyRnVsbHJsYXJndHJhcHByb21pY3JvbGJya3NsdTt5ZnJleHBlY3RhdGludGlsSW9nb247dmRhc2h2RGFzaGNvbG9zcXVhcmVpaW9wcmVjY3VybHllVW5pb21hbHRlc2U7Q2xvc2VDdXJseURvdWJsZVFEY3k7ZHpzdWJlam9uc3VwYm94Vmg7SW52cnRyaWV4cG9uZW50aWFsbnN1YmVOZXdMaW5lO1JpZ2h0VmVjdG9yY2lyY2xlZFNVZGJuZ3RyO3NpbWRvdDtlcXNsYW50bGVOZWdhdGl2ZVZlcnlUaGludGdsZG90cGx1Z3RsUGFjb21tYXQ7bEFjY3VidW1wO3lhY1pudGlsZGVVcGRvd25hcnJvdGltZXNiYXI7am9wZjtBZmduYXBwcm94O2xzcWJ1bWxiaWdjaXJjO3ByYXA7ZmVtYWxlO01pbnVzUFN1Y2NlZWRzVGlsZGU7c3ViZTtVb3BmO3Jtb3VzdDtyc2FxcmlnaHRhcnJMZWZ0RG93blRlZXJtb2NvcHJvSHVtcERvd25IdW1wZ2c7Q29uaW5TdGFuZHNseGN1cDtyaWdodGhhaWpEb3VibGVSaWdodFRlZG93bmFycnRoZXRhdmxvbmdyaWdodGFVbmlvblBsdWlxc3VwbXVsdDtkb1VuZGVyQnJhTGVmdEFuZ2xlQnJhY2tOZWdhdGl2ZVRoaW5TcGFjRG91YmxlVXBEb3dlcGFyc2xzdWJyYXJyYW5nc3BzdWNjc2lndHJkb3ljaXJjQ2NvbkRvd25MZWZ0VmVjeHVmZmlsaWc7ZGl2aWRlb250ZHVkYXJyO2RlbXB0eWRhcnJQcm9wb3J0Q2lyTGVzc0VxdWFsR3J1b2dvbmJsYWNrdHJpYW5nbGVyaWdodDtwbHVzYWNpcjtjdUVOTGVmdEFycm93UmlkaWxyYXJyO2d0cmVxZXNjcmN1cGRvUmlnaHRVcFZlY3RvRG91YmxlTG9uZ0xtaW5tb3BubGVmdHJpZ2hOb3RTcXVhQWxwaGE7enNjcjtOb3RTcXVhcmVTeGhhcnVvYmxvbGVzc2VxcWR6Y3lEb3duUmlnaHRUZWVWUHJlY2VkZXNFcUxlZnRUZWVWZWNkb3duaGFycG9vbktjZWRpbDtSZXZlcnNlRWxlbWVuZ3NpbWVTcXVhcmVJU09GTm90U3VibGVzc2VxcWdQcm9wb3J0aW9uO3ZlcnQ7c3dhcmhrT21hTGVmdGFycm93dXRpbGV4cGVjdGVERG90aWpsaWc7YXN5TG9uZ3JJdWt2YXJzdXBzZXRuZXFxO2xlZnRhcmJveERMZ2xFO2N3aW50dmFyc3Vwc2V0bmVxO0tIY3VwaGFycG9vbnJpZ2h0O0JhcndlZDtOb3RDb25ncnVlbnNob3J0cGFyYWxsZWxjaXJjbGVhcnJvd3JpZ2hsbGNyYXJyc2ltb2NpcmVEb3RpbWFncERvdWJsZUxvbmdMZWZ0QXJycmFlbXB0eXY7VkRhbndBcnJuZXNlTmVnYXRpdmVWZXJ5VGh1d2FmcGlwbGFycmJmcztOb3RUaWxkZUZ1bGxFZWNvbG9scGFyO21lYXN1cmVkYW5nbGU7dWJyZVVwQXJyb3dEb3duQXJ1cHVwYXJlbXB0eXZ2YXJlcGFmO250cmlhbmdsZXJpcnNjcmthcHBhdjtHcmVhdGVyU2xhbnRFcWlmaW50cHJvZDt1cHNpbG9tYWx0aW50bGFyUHJlY2VsZWZ0aGFydGhpY2thcHByb3g7Rm9wRG91YmxlVmVydGljYWxCYXJnY2FsZWZzeW1FbXB0eVZlcnlTbWFsYm94RGxjdXBiam1hdGg7Tm90RXF1YWxUaWFwb3M7Zm5vYW5nbXNkYWI7TGNlZGlsO0xlZnRBcnJvd2xvb3BhcnJvd3JpZ0RvdWJsZUxlZnRSaWdodEFycm93c3VwbXV5Y3lwZXJjbnRMb25nTGVmdEFybnRyaWFuZ2xlbGVmdGVxcmRsZGhhQ2FwaXRhbERpZmZlclVjeWZub2ZWY3k7Tm90RWxOb3ROZXN0ZWRHcmVhdGVyR3JidW1wZXE7UVVPVDtzdWNjc2ltbWFwc3RvZGZjeTtOb3RMZXNzVGlnbDtsb25nRG93bkxlZkNvdW50ZXJDbG9ja3dpc2VDb250b3N1Ym5lO0NpcmNsZURvdHJhcnJscExlZnREb3VWZXJ0aWNhbFRVcGRvd1RSQUl1Z2NpcmNOb3RQcmZudXJjb3JuO3NoY2hjeVVwcGVyUmlnb3VtdWJyY3k7Tm90TGVzc0dVdW1sO0xvbmdsZWZ0cmJveHZMO0NheWxleXM7ZUR6ZnJzd253YU1lbGxpbnRyZmF3aW50O1phU3F1YXJlU3VwZXJzZXRFbGVxO2V4cG9uZWNpcmNubGVmdHJpZ2h0YXJybmN1Q2VudGVyRG90c2NhUmlnaHRhcGhvbmVsbHRyaTtpZWN5O0RvdWJsZVJpZ2h0VGVlcmFycnNpY2x1ZW1wdHlzZXRsbmV4dXBsdXNTT0ZUY2ptTm90TmVzdGVkaG9va3JpZ2h0YXJyb01mcm9kYlJpZ2h0VXBUZWVWZWN0b3I7Y29sb25lU3F1YXJlVW5pb2JubmhBcmFwcHJveGVxeWFBc2N0d29oZWFkcmlnaHRMZWZ0YXJyUmFuVkRaZXRhTm90VmVjdWRhcnJyO3VhY3V0ZUtzY3I7dW1hY3JQb2luY2VzZG90O092ZXJCYXI7Tm90VGlsZGVUaXVtbDtZQWN5O3JpZ2h0aGFycG9vbG9uZ2xlZnRhcnJvdztpaWludEFNUEh1bXBFcW5leGlzdG5sZWZ0YWxtb3VDb3VnRWw7TG9uZ1Jib3hETDtvZ3JhdmVubGVzSXRpbGRlbGVmdGhhcnBvZnJhYzE0a2Fac2NvbXBsZW1lbnQ7dHdvaGVhZHJpZ2h0YXJyb3dib3htb3NjYmFja3NpbWV5Y2lpcmZsb29CZXJub3VsbGlzO3JsbTt0b3B0aG9yamN5O2RjYXJyc2xvb3BhRW1wdHlWZXJpZXhjbDtwb2lubnZnVFJBREU7ckJhcnNpbW5lcmJyYWNrO3N1cHNldG5lcXF0YnJyQXJyO29kb3ROb3RQcmVjZWRlcztpdGlsZGU7R3NjT3NsYXNoO3NicXF1SGNpcmM7SXNjcmRvbE5vdEV4aXN0c3JpZ2h0aGFycG9vbnVwRmlsbGVkVnhkdHJ2YXJzaWdnbGE7RG91YmxlTGVmYmxvY2t0cmlhbmdsZWxlc21lcFN1YnNldEVxdWFsQ29uZ3J1ZW50YmFja2Vwc2lsamN5O0xlZnRWZWN0b3JCYXJOb3RIdW1wRG93bkh1dmFybm90dW1hY3I7RGlhY3JpdGljYWxUaWxkZW5sZXFzbGFmcmFjMjM7YnNjT2FjdXRMZWZ0QXJyb3dScmlnaHRzcXVpZ2Fycm93bG9uZ2xlZnRyaWdodGFycm9uYW9zb05vdFRpbGRlRnVsbEVxdWF0b3Bmb3JrO0xlZnREb3FpemREb3duUmlnaHRWZWN0b3JpZ2h0cmlnaHRhcnJ1aGJwYXJzaWxlZnRyaWdodHJpZ2h0bGVmdGhhcnBvb25zcHJlY2N1cmx5bGhhdGNlZGlsRXBzaWxvbjtzY2VkaWxtdW5jYXJMZXNEb3VibGVEdGhldGFzeVNpZ21hVGhpU3F1YXJlU3VwZXJzZXQ7Tm90RG53bG5lcWJlcGJsYVN1Y2NlZWRzO2RpZ0ludmlzbm90bnZhcm5vY2FwYW5TaG9ydFVwQXJuYWJsb3ZiYXBvc05lZ2F0aXZlVGhpblNwbG5hcHByb3g7Wm9wZnZsc210ZTtsdHF1ZXN0O05vbkJyZWFraW5nU0xvbmdyaWF3Y29uaW52c3VwbmViZXR3ZWVnYVJpZ2h0VHJpYW5nbGVFcXVhT21pY3JvbmxzYXF1ZG90bWludXZzYmVtcHR5Q2xvY2t3aXNlQ29udG91cklOb3ROZXN0ZWRMZXNzTGVzc25pdjtBRWxpZztVbmRlckJhcjtmcmFjNURvd25MZWZ0VGVlVmVjdG9zdHJhaWdodGVkdWF1ZGhTaG9ydFVhbmRzZ2xqO3JlY3Rjb21zcGFkZXN1aXQ7YmFja3NpbXJjV29wU2hvcnRET3ZlckJyYWNrZXQ7UG90b3Byb2ROb3RMZWZ0b3JpZ2ZyYWMxNXh2RG91YmxlQ29udExlZnRVcFZlY3RvaW1hdGg7dUhhVWFjdXRlO3ByZWNucmlnaHRzcXVpTGFjdXRhc2NyO0Rvd25UZWU7ZmN1cGhhcnBvb25sZWZ0RG93blJpZ2h0VmVjdG9yQmFJbWFnaVRTSENlZGlsbmNvbmdkbnduZWFBb2dvZ2VsO0NvbmlzdXBzZXRuZXFxO25wcmN1ZTtPdGlsaW5vZG9kb3RlcWRYc2NFbXB0eVNtYXJjZXJicmFjZTtmaURvdERvdGRIYmlndHJpYW5nbGdzaW9nb3N1cGVkb3RndHJlcWxlc3NzbXRlcztmbGxpZzt2YXJlcHNpbE5vdEdyZWF0ZXJGdWxjaGN5WmVyb1d5ZkxhcGxhY2JibnVtc21hc2JlY2FSaWdodFRyaWFuZ2xlQmFyO1VuZGVybW9wZnZhcnRyaXJpc2luZ1dzcXVhdGVybm92YmFyTm90U3VjY2VlZHNsb25nbGVmdHJpZ2h0YXJyb3dlcXZwYXJzRm9wZjtiaWdjdXA7YmVtcHRpZ3JhdktIR2dyc2FxdW9EaWZmZXJVdGlPbWljcm9uO0Vkb2xlcXE7VWFycm9jaWxmbHRzY3lMY2VkaWV1bWw7SmNpcnZvVXBhcnJubHNpT3BlbkN1cmx5RG91YmxlUXVvdENPUFk7Ym94SGRzdXBoc2FvZ29uO0xzdHJvTmVzdGVkTGVzc0xlc2ZsYXRpbWFnbGl3cmVhdGh2YXJwTm90UHJlY2VkZXNsYnJrc2xkZ3RyZXFxbGVzc3pzZ2Vxc2xhbmxlcXNsYW50Tm90R3JlYW5sZHI7YmlndHJpYW5nTGVmdFJpZ2h0QXJyY2xmaWxEb3VibGVMb25nTGVmdFJpZ2h0b21hY3JUaGluU2dqYXN5bXBlVmVydGljYWxTZXBhcmF0b3I7SW52aXNpYmxlY3JhcnI7RXVhbmdtc2RhY05vdFJldmVyc2VFbGVtYWJyZXZVYWNMZWZ0RG93blRlZVZlY3RvdWxjb3JuZXJvbGNyU2hvcnREb3duQXJyb3dVcHBlckxlZnRBcnJvd0JjeWFhY3V0ZTtPb3B1Y2lybGRxdURpZmZlcmVudGlhbERsYWdJbWFnaW5hcnlJQ2xvY2FuZ3phcnI7TGVmdFVwVGVlbGFycmZzY3NhcGlEb3VibGVMb25nTGVmdEFyZXFzbHNjcG9saWxvbmdyaWdodGFyclNoY2Fwc0ludmlzaWJsZVRpbWVzO2FlYmFja3NOb3RQcmVyYnJhY2VDbG9ja3dpc2VDb250b3VySW50ZWdyRXRhO3NpemFjdXRMZWZ0RG91YmxlbHNpbWU7c3NldHN1cGhvbWFjZWdzYnF1bztsQXJyO3NlYXJyb3dBb3VoYXJOdGhpY2thcHByb2xvd2FzbGx0TG9uZ0xlZnR4b3BsdXNsb29wYXJyb3dsZWZ0YXN5bXBsdXN0VXBBcnJvd0RvU2NlcmlnaHR0aHJlZXRpbWV1bHRyYmxhY2t0cmlhbmdsZWRvbGVmdHJpZ2h0aGFycEdyZWF0ZXJHcnN3QWZyYWM1NjtsZXFzbGFudDtuZUFyaGVhcnJpZ2h0dGhyZWV0TGVmdERvd2Vsc3pzY2NhY3V0ZTtyY3VyaWdodHJpZ2hwb2ludGludFNvcHVncmF0cmlhbmdsZWxlZm1hcHN0b2Rvd0xvbmdyaWdodGFybm90aW5kVW1hY3JDbG9ja3dpc2VDb250b3VySW50Y29tbWF0VXBFcXVpbGlicHJvZnN1cmZnZGxzY1VwVGVlQXJyYXRpbHJpZ2h0c0tKY3k7Z3RyZXFsZXNzO3hoQXJyRG91YmxlVmVycW9TcXVhcmVTdXBlcnNlc2JxdWRzdHJvbWVhc3VyZWRhbmdOb3RUaWxkcHJlY25lSW50ZXJzZWN0ZGRhQUVsaWdSaWdodFRyaWFuZ2xlVWRibGFjO3RyaXRpbWU7bEJhcnI7bEJNZWRpdW1TcGFjZWN1cGJyY2FjdGRjZW50ZXJkTWVkcmRHYnJldlJldmVyc2VFcXVpbGlicml1bTtGb3JBbGFicnJob3Zhbmdlb3JpZ29MZWZ0VGVlQXJsdHJpZjtPYWN1VXVtcm90aW1Eb3VibGVDb250b3VySW50ZWdDaXJjTG9uZ2xlZnRyaW5sZWZ0YXJyb3c7bG1pZG9BRUludGVncmFWZXJ1cmNvcm5lcnNwYWRlbG9vcGFycm9Ob3RTdWJzZXRFUHJlY2VkZXNFcXVhbGxhZXNjYXBFY3k7cmxhcnI7YmlnY2lydHN0cm9uZWFycjtvbWVnYTtTc2N6b2djeW5sdHJpZXpvcGZ2YXJlcHNpYmVjYXVpZWN5dW1hbnRyaWFuZ2xlbFVwYXJoYWlyc3BsdGNpVGhpY2tTQ2FjdXRlO0RlbHRhO3ZzY3JSaWdodFVwVGVlVmVjdG9mcGFydHJvYXJMZWZ0VHJpYW5nbGVCYXI7YXVtbG5wYXJhbGxlbEZpRG93bkxlZnRUZ2JyZXZlO3ZlZWVxO1Nob3J0VXBBU3F1YXJlU3VwZWlpaWlzdWJFO05zY3I7Tm90RXF1YWxUR3JlYXRlckVxdWFsTGVzc3JjYXJGaWxsZWRWZXJycHBvbGludDtvZVVuZGVyUGFyZW50aGVzaXM7RG91YmxlTGVmdEFycm93O2dzaW1lO2ZwYWVmcjtiZWNwaW9taW5sQXRhZ2FtbXdlZGdjaERvdWJsZVVlbXB0eXY7ZnNjbmxlZnRyaWdodGFycm9MZWZ0VGVyaW50cmlhbmdsZWxlZnQ7cmlnTm90R3JlYXRlckZ1dmFyZVNIVWFZQWNsb2FycmNvbXBsZXhlc0Vwc3Nob3J0cGFyYWxudnJ0cmllO092ZXJCcmFjZTtUY2VkYmlnb3BsdXNQc3JvYnJjd2NvbmlQcmVjZWRlcztub3RuaXZhaG9yYkRmYW1hY0xvbmdMZWZ0QXJyb3dtb3BmO2NvbG9uZXE7UHJvZEVjRXF1YWxUaWxkd29wZnNpZ21nZXNsZVNjYXVyY3JvdXJjb3JuZXI7b2htSU9MZXNzVHByY3VlRG93bkFycm93O3ZsdEludmlzaWJsZUNvUmV2ZXJzZUVsZW1lbnR3cE9zbGFzYm94VXI7U3F1YXJlSW50ZXJzZWNpcnNjaXJucmFycmM7dHJpZG9yYnJrc2Vzd2Fsb3didHJpbWludXM7Y3VwY2FwO2dhcG5hcHByb3g7RGlhY3JpdGljYWxEb3VibGVBY3V0ZU5lc3RlZExlc3NMRGFyTGVmdEFycm93QmFUaWxkZTtOb3RMZXNzU2xhblljbkxscXVlR29sakxlZnRDU3VjY2VlZHNUaWxucnRybndhcnJyYXJycE5vdFNkaXZpZGlnZWNpcmM7ZWFMb25ncmlnaHRhcnJvd1JpZ2h0QXJyb3dMZWZ0QXJyb0dyZWF0ZXJTbGFudEVxdWFOb25CcmVha2luZ3JvYXJyO0RvdWJsZUxlZnRSaWd2YXJ0cmlhbmdsZU5vdEdyZWF0ZXJFcXVhbE5vbkJyZWFraWRhc2g7UHJlY2VkZXNTbGFudEVxdWFsYmxrMTQ7WXNsYWVtUmlnaHREb3VibGVCcmFja2JsYW5iZHF1b1VwYUJhY3RwckJvcFJzaDtMbWlkQ291bkNhY3VTcXVhcmVTdWJzZXRFcXVhVXRpbGRhcGFyYnJrc2xkYmV0YTtSaWdodFZlY3RvckJhcjtibGFja2xvemVuZ1VwcGVyUmlnaHRnZWxMZWZ0VHJpYW5nbGVFcXVhbGxsaGFyZDtTaWdtYTtFY2lydGhrRWFjdUlvZ29SaWdoTm90TGVzc0VxdWFsO2RibGNlaWFuZ3phcnJlYWxwYXJ0c3ViZWRvdEJhY2tzbGFvc2xhbkxlZnRhbG9uZ3JpZ2h0c3FzaW5jYW9hY3VzcXN1YnNldDtudmxlRGlhY3JpdGljYWxHaHlwaXByZXhwb25lbnRpc2NhcnN1YnJhcmVxc2xhbnRsZXNzZXFjb2xvbk1lZGl1bVNwaEFycjtOZXN0ZWRMc3NtaWxlO3VyaXZhcm5vdGhpbkNvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWFscGhhO1VyaW5nTGVmdERvd25UTG93ZXJSaWdodEFycm93eGZyO0xlZnRWZWN0b3I7VmVyeVRoaW5TcGFjZURpYWNyaXRpY2FsRG91YmxlQWN1dGU7SG9ySWdsZXNkb3RvclBvaW53QXJtb3VzZG93bmhhcnBvb25sc3VwZHN1YjttZWFzdXJlZG53YXJyb3doZWFDZEh1bXBFcXVuTHROb3RMZXNzU2xhbnRFcXJ0cmJsYWNrdHJpYW5nbGVyaWdoZmZpbGlnZGZlbXNwMTM7TGw7YmFja2Vwc2lsb090aWxkZTtyaWdodHRoclN1Y2hUaGF0Y2FyZXRmaWxpZ1lvcFVicmN5TGVmdFRyaWFuZ2xlRXF1YWw7RGlhY3JpdGljU3VjY2VlZHNTbGFudFVuZGVvbWFDYWN1dEZpbGxlZFZlcnlTc3RyYWlnaHRwaGduYXBwck5vdEVsZW1lbnQ7bmNvbmc7RHN0cmRsY290c2NyO2RhbGVWZXJ0aWNhbExpbm5sZXNzZHJvcE5vdFRpbGRlRnVsbEVxdWFsO2FuZ3NwaHdjaWJveEhEO3V1bWxUaWxkZXVicmV2ZW5sdHJkY3llc2RvcmlnaHRhcnJvd3RhaVNob3J0UmlnaHRBVmVydGljYWxMTGVmdERvd25UZWVWZWNib3h2cmZvcGY7b3JkZW5wb2xpbnRkYWxldGg7Y3VybHllcVJpZ2h0RG93blZlY3RvcjtMb3dlckxlZnRBcnJubGVmdGFycm93bGVmdHJuYnVtcDtOZWdhdGl2ZVZlcnlUaGluU2JveGg7ZXFzbGFudGxlc0xjZWRhd2NvbmludDtiYWNrZXBzbmxBckNsb3NlQ3VybHlEb2RpYW1mZnJjdXJ2ZWFycm93cmlnaHQ7c3VjY25lcXE7dGJNZWRpdW1udmx0cmluZUFycmxjYXJvdHN0cm9rO2xlc2RvdG87cmxoYXJDb2xvbHNpbWVwYXJhbGxlZnRoYXJwb29udXBVcFRlZUFycm9hbmdydHZuY2FtZVJFR05lZ2F0aXZlVGhpY2tib3hIZDtHckxlc3NUaWNvQ2xvc2VDdXJseVFJYWN1dGU7VGlsZGVGdWxsRXF1YURvdERvdDtib3h1bDtjdXJseWVxcHJlY3djb25pbnQ7VXBkVm9wcHJzaW1jY2Fyb2JldHdlZW47R2NlZGlsbGJyYWJveFZscmlnaHRhZGZpc2hydGltZXM7aGtzd3NpbWw7bG5zaW1PcGVuQ3VybHlEb3VibGVRdW9vbGlkb3duZG93bmFyT3BlbkN1ZGl2aWRlb250aW1lc3JoYXJ1bDtyZHNyb3BhcjtzZXN3YXI7c3Vic2ltbm90O0VncmF2ZTtVbWFyb3RpbWVkb3duaGFycG9vbmxlZnRFcXhvdGlsb3BmO2xhbWJkYWRvd25kb3duYXJyb1ZzY0Fzc2lnbnpoZnJhYzM1O2Rvd25kb3duYXJyb3dzckFhb3J2O0VtcHR5VmVyeVNtVW5kZXJQYXJlbmN1ZXNMZWZ0QXJyb3dSaWdocmlnaHRyaWdodGFyZGNhcm9uO05vdERvdWJsZVZlcnRpZXBhcjtkYWdnZXI7bGVzc2VxUGx1c01Ob3RTdWNjZWVkc1NsYW50YmxsYWVtcHR5QU1wbGFua3ZmamxpbGVmdHRocmVldERKY0Rhc2JzaVVwQXJIYXJOb3RSaWdoZWFydHN1aXR1ZmljeWxjdHluYnVtcGU7c2RvY3lsYm94SDtyYXJyY2x2bkVoa3NlYXJyZmxMZWZ0QXJyb3dSaWdodEFycm93O250cmlhbmdsZWxlZlNxdWFyZVVpbnRlcmNhbDtndHJhRGN5cG9wTm90TGVmdFRyaWFuZ2xlQmFyO2xyaGFyZDtFb3BmO3V1bWw7YmlndXBpcXVlc2JveHBsdXM7VnZkYmlndmVlO0RhcnJubGRHZG90O2RoYXJsO1BjeTtEb3VibGVEb3duQXJyb3c7Tm90Q3VwZW1zcDtuZ3Q7bnNpbWVxO2x2ZXJkb3VibGViYXJ3ZWROb3RTcXVhcmVTdWJzZXRFcXVzZXRtSW9wZjtUU0hjYmFjTG9uZ2xlZnRhQ2xvc2VDdXJseVF1b3RldGNhTFQ7VnNjcjtVc3ByZWNjdXJseWVxYmxhY2tsZXNzZXFxZ3RyeGhBRXF1aWxpYnJpc2VBZWN5O0h1bXBEb3dGY3k7YW9wZjt4aERpYWNyaXRpY2FsR3JhdmViaWd0cmlhbmdsZXVwO25yaWdodGFycm93O1BOYWxkcXVvY2lyZU1hcG5zdXBzZXRlcXVlc3RlcUxlZnRSaWdodEFyeGxBcnI7bHVydW53bm50aWxkZTtQcmVjZWRlc1RzdXBtdWx0aWpsQ2FwRGViaWd3ZWRnZTtjcm9zcztjdGN1cnZlYW51bWVybztzZXN3c3RybmJOb3RSYWNub3BzYWN1dGVjY3Vwc3NtUkJhbGJya2VDaXJjbGVUaW1lc0JhY2tEb3VibGVWZXJ0aWNUaXVwbHVVdE5vQnJlYWtOb3RTcXVhcmVTdXBlcnNldEVxdWZhbGxpbmdkb3RzZU1pbmFuZ21zZGFmO3dvcERvd25BcnJvd0JhckdyZWF0ZXJMTmV3TGlubmxhcnJzaW1kb1NxdWFyZVN1YnNldEVxdWFsO2dhY3V0ZVJhcnJ0R3JlYXRlckVxdWFsTGVzYm94bWlhYWN1Q291bnRlckNsb0ZvdXJVcG5pdmJpZ3VwbHVVcGRvbG5FQ291bnRlckNsb2Nrd2lGaWxlcXVlc3Q7bmdlcXNsYW50O0lKbGlmcm9zbGFzRG91YmxlTG9uZ1JpZ2h0Q2xvY2tEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3dzaG9ydG1pZDtVcFRlZUFycm93QmFja3NsYXNoTm9uQnJlYWtpbmdTcGFjZTtOb3RHcmVhdGVyU2xhREpjeTtubGVmdHJzdWNjY3VybHllbkxlZnRyaWVsc2RvdHFwcml0b3NhY3NrY2VkaWxMYXBsYWNldHJmaGtzd2Fyb3c7S3NlcWNpendqc2JuTERvdWJsZUxvbmdMZWZ0QXJyb2NpcmU7UmNhcmRBcnI7ZmZsaWc7QmV0YVRoaW5TcGFjZWpmcjtHcmVhdGVyU2xhbnRFcXVhbDtVcGFycm9Ob3RHU3VjY2NvbXBsZXhIb3Jpem9udGFsTGluYmlndGxicmFjRGlhY3JpdGljYWxUaWxkY3VybHl2TG93ZXJSaWdodEFycm9Eb3RFcXV1cGFycm9Pc2xhc3Vic2V0O3RoaWNrc2ltO2VxdnBhcnNsYWxlcGhMZWZ0QW5nbGVCcmFwcm9wdExvbmdMZWZ0UmlnaHRBcnJvbnNob3J0bWluYXA7U21lcXVhbHNuYWNhdFNzY3I7bGVmdGFyaWdodHNxdWlnYXJyTGVmdGFycm93O2NlbnRlckZvdXJpZXJMb25nTGVmdFJpZ2h0QXJycGx1c2xBYXJyO3Jpc2luZ2RvdHNldHJpYW5nbGVkY2FwY2FwO0RpYUVUbXVtYXA7Z2VzZG9Eb3dubGVzc2VxcWd0YmxhY2t0cmlhbmdsZXJpZ2h0bG9uZ2xlTXVSaWdodFRyaWFuZ2xMZU1jeTtlY2JpZ2NpcmNiYWNrY29uZ2RkYXJyO3NtYWxsc2V0eG5pU21hTm90U3VjY2VlZHNTbGFudEVxcHJvZnN1cmY7RXhpZ3NVcERvZXhpQ2FwaXRhbERpZmZlTGVzc0Z1Z3RyYXBwcm94O2JldHdsdmVydG5ndGNpcjtzdW07ZXhmcmFjMjNVc2NwcmVjZWdydXJpbmZvcmFsbnJpZ2hwcmNDb25ncnVsZWZ0dGhyZWV0aWRkb3RzZXE7YmlndmVDYXBpdGFsRGlmZmVyZW5lbWFTaG9ydFJpZ2h0QXJyb3dib3BmZGlnYW1tYTtldXJvO0ZpbGxlVmVyeVRoaW5TcFZkYXNoO3N1cHNpbXZsdHJpZG91YmxlYmFyd2VkZ3VsY3JvcDtSaWdodFRyaWFjd2ludDtmc2NyO1JpZ2h0RG91YmxlQnJhY2tlc3NldG1uO1J1bmxlZnRhcmJrYXJSaWdodERvd25UZWVWbGhibGs7dHJpYW5nbGVkb3duc21hbGxzZXRtbGJhcnN1YnNldG5vcmlBcnhkdG50cmlOb3RMZWZ0VHJSaWdodERvd25UZWVWZWN0b3I7bnN1YkU7bnN1cHNldGVxcWV4aXNOb3RFbGVtZW5iaWdvcGx1VW9iaWd0cmRzTGVmdFRlZVZlT2RibGF0c2hjeXN1Y2NjWWFjdXRpbnRlcmNPcmJveERMb3dlckxlYmlnc3FVcHNpVW5kZXJCcmFja2V0ZGRlcHNoZWxsaUxlZnRUcmlhbmdyaG92O1N1Y2NlZWRzU2xhbnRFcXVhbENmcjtyYW5SYXJydGxuc2NlRG90RXFJdW1sO25zdWNjZXByb2ZsaW5lc3VwbGFmaWxpR2FtbWhjaXJ3b2FvZ29uZGllO2l0aWJhcndldGltZUxvd2VyUmlnT3ZlclBhcmVudGhBbWFjcllVY3pkb250cmlhbmdsZXJpZ2h0ZXFkcmNvcm5sZWZ0YXJyb3d0cGFyU3VwZXJSZnN1cGVtaWNyUnNoY2lyY2xlYXJyb3dyaWd0aW50cGhtbUREb3RDbG9zZUNtYXBzdG91cDtJZ3JhdmVrY3lOYWN1cmhhcmQ7QW9nb247UmlnaHRBbmdhY3V0R3JlYXRlckZ1bGxkdXRycHJlY2FwcHJveDtsb2FydXBsdXN2YXJzaWdtYTtydGlob29rbERvd25hcmxlc2d4bnN1cGRzdW9yRGlmZmVyZW50aWFBYWN1ZGVhdW1sO2xiYnRyaWRyZmlzaHQ7TGVmdFRlZVJ1bGVEZWxMb25nTGVhbmdtc2RhZztyYXJyd2d2ZXJ0bmVCZXJub3VsbGl1YWN1dGU7UHJlY2VkZXNUaWxkZTt2cnRpZWNYaTtOb3RWZXJ0aXJuc2Nwb2xpbnQ7Tm90VGlsZGVUaWxkZXBpdGNoZm9ya21jb21tYTttZlJpZ2h0RG93blRVbmRlclBhcmVudHRzdHJkZG90c2VUc2NyO2N1cmx1cHNpbG9udXRpc3VjY25hcHByb3J0aW1ldnByb3Boc2lhY2lvdGFwbHVzZHVQcmVjZWRlc1NsYW50RXF1YWw7dXBscmRzaDtjYWNnZ2dkemlncnN1cHNldG5lcTtjdXJseWVxc3VjcmZsb29yRGlhbW9ucmlnaHRhcnJvd3RhaWxSaWdodENlaWxlbXNwMTNOb3RQcmVjZWRlc0VxdWFsO2d0ZERvdWJsZUxvbmdydHJpZjtkYXNoTm90U3F1YXJlU3Vic2V0aG9va3JpZ2h0YVhmZ3RyYXJyZWFsaUxlc3NHcmVwaG1tYXdlZGdlRG91YmxlTGVmdEFyT3BlbkN1cmx5UXVuaHBhcjt3Y2lyYzttbGR6YWN1TG9wZmN1ZGFyeG9wbGhlbGxpcHBsdXNlO2xBdGhzdHJIb3Jpem9udFVwQXJyb3dEb3duQXNxdTtxcHJ4bGFyc3VjY3ZhcnRyaWFuZ2xlcmlnaHRwcmVjbmVxdXRsdHJQYXI7dXBoYVN0YXVBcnJibG9jaztzdWNjbmVxcmFjdXRydHJpbHROb3RMZWZ0VHJpYW5nbGVFcXVhbDtNZWRpdW1TcGFscGFybHRpYWN1dHNob3J0cGFyYWxsZWw7bHN0Y2x1Ym52Z3Q7YmlndHJpYW5TYWN1dFpkTm90UmV2ZXJzZUVsZW1lbnQ7Um9wZmNvbmdkb2N1cnZlYXJyb3dyaWdoaW50ZWdlcnNiaWdzcWN1cE5vdFRpbGRlRXF1Z3RyZXFxbGVFbXB0eVNtYWxsU3F1YXJlVGN5O3BsdXNkbnNjO2ludGxhcmhrO05vdFRpbGRlVGlsZGU7RG93blJpZ2h0VGVlTGVmdFVwVGVVcEVxdWljaXJjbGVkY25oYXJybGF0YWlsO05vdE5lc3RlZEdyZWF0ZXJHcmVhbmxzYmlndHJpYW5nbGVkb3dubWNvbWduYXBwcm94WG9wZjtsZmlzaHRyaWdodHNxdWlnc21pbGVjb25pbnQ7bXVsdGltYVplcm9XaWR0aFNwYWNlO0Rvd25BcnJvd0JhY2VudGVzYWN1Y3Vwb1lVY3k7UmlnaHRBbmhhbUxlZnREb3VibGVCcmFja2V0ZHdhbmdFeHBvbmVudE9wZW5DdXJ0cmFkZWVuc3B4Y3VndHJlcXFJbnZpc2libGVDb21tYXJhZGlEb3duTGVmdFZlY3RsZWZ0bGVmdE5lZ2F0aXZlVmVyeVRoaW5TcGFjZTtEb3duTGVmdFJpZ2h0VmVjdG9yQ29wTmVnYXRpdmVWdHByaW1lO3VwaGFycG9vbnJpZ2h0VEhPUk47aXRzdXBzZXRubHNhbHBQcm9wb3J0aWFjZDtyY2VkaWx1d2FuQ2FwaXRhbERpZmZ1bWFjaGtzZU5vdE5lc3RlZEdaY2FEWmN5R3JlYXRlclNsYW50RXBvdW5zcXN1Ymhvb2tyaWdodGlub2RvdGJvdDtTcXVhcmVTdXBOb3RQcmVjZWRlc0VxdXNldG1pbnVzO2ZhdGhrc2ltcmhhcnU7YnNlbWd2ZXJ0bmVxeWVuO2xjYXJvbnRyaUFzY3I7T3Vtc3VjY25hcHByb3g7bWludXNiO0VtcHRQb2luc2ltbmU7RG91YmxlTG9uVWFySHVtcERvd25IdUVzY3JrZ0NhcGl0YWxEaWZmZXJlbnRpYWxtaWNybztyaWdodGxlZnRhcnJvd1VnckxlZnRVcFRlZVZlY3RvRW1hY3I7cnhuc3VjTGVzc0Z1bGxFcWVhY1BoaXJzYXF1bzt5Y2d2ZXRyaWFuZ2xlcmlnaHR3b2hlYWRyaWdodGFOb3RTcXVhcmVTdWJzZXRFcXVhbDt0d29oZWFkbHJicmtzbHU7UmlnaHRVcERvd25WZWN0ZXFvcmRVZGhlbHVwdXBhcnJvRmlsbGVkU21hbGxTcXVOb3B0cmlhbmdsZWxnYWN1dHVsY3JvcEludmlzaWJsZVRpbXBlcnR0ZnJzcGFkZXN1TGVmdENlaWxpZ2VzY2NRZm9yZDtudGdsO2xlZnRyaWdodGhhcnBvb3ZhcnNpc3Vwc2V0bnBhcmFsbG1pZGFOb3RQcmVjZWRlc1NsYW50RXF1YWxia2FVbmRlclBhcmVudGhlc3N1Y2NjdXJseWFyaW5nTGVmdHJpZ2h0YXJyb3dud0FybmNhcDtCZnJQb2luY2FyZXBsYU5vdFNxdWFyZVN1cmFycnRsTm90SHVtcEVxdWFyYnJhZGlhbW9uZHN1aXRJbWFnaW5hcmlmcm5WRGFzc3Vwc3VwRmlsbGVkU21hbGxTcXVhcmVOb0JyZW5hdHVyYWxzeGxsbW91c3RhY2hlSmZybnZkYXNoO0ljeW52SHhzY3I7R3JlYXRlckZ1bGxFcXVhc3Vwc2V0ZXFxO3JhcVByb3N0UnVsZWZhbGxpbmdkb3RzbnZydHN3YXJwcm9mc2lhY3V0ZTtySHVjaWFwYWNEaWFjcml0aWNhbFRpbGNhS2FwcGF1ZnJib3h2Umhvb2tsZWZSaWdodFRlZVZlY3RvT2dyYXZlTG9uZ2xlZnRyaWdodEJhcnY7UmlnaHRVcFZlQ29udG91ckludGVncmFsdmVyYmFyO2xsY29ycGhubHRyaTtkb2xsbnNjY3VkaXZpZGVvbnRpbWVOb3RSZXZlbnBleHBvbmVudGlhbGVDaXJjbGVNbGhlYXNMZWZ0VmVjdG9yT3ZlclBhcmVudGhlc2xvYXJyO3JlYWxwYXJzdXBzZXRlcTtFeHBvbmVudGlhVXBwZXJSaWdodEFycm9Ob3RMZXNzU2xhY29uZ2RvdDt1dXZlcmJhYWxlZk5KY3k7UVVGaWxsQ29wckFyaW5nc3RyYW1Tb3BmO2F3aW51bHRyaTt0aG9ybjtib3hoVXNjbnNpRG91YmxlVXBBTm90VmVydGljYWxCYWlwcm9kO25vdG5pdmJ0cmlhbmdsZWRvd247bnZsQXJyVGNhcm9uWXNjcjtDbG9zZUN1cmx5RG91YmxlUXVvZWxzZG90O3JhdGlvbmFsTm90VGlucG9kamN5O0dyZWF0ZXJUaWxUaWxkZUZ1bGxFcXVhbG9kb3Q7bHRpbWVpY2JsYWNrbG96ZVplcmxvb3BaZWRvdHNxdWF0cmltZ3RybGVzczthbmRzbG9wZXV1YXJyY2VudGVyZG90O05vdFN1cGVyc2V0RXF1T3ZlckJhcGFydDtiTm9waG1zaWdtYWY7bGVzc2FwcHJvTm90TmVzdGVkR3JlYXRlckdyZWF0ZXI7bHN0cm9rO2F0aU5vbkJyZWFraW5nU3BhY0FyaW5nO3RvcGJMZWZ0bGVmdGhhYnJ2YlRzRm9wZnRjZU5vdFRpbGRlUHJvcG9yZG07Tm90U3F1YXJlU3Vic2V0O0xvbmdsZWZ0cmlnaHRhcnJvdzt4dXRtaW51c2JvaXJtb3VzdGFjaE9ncmFycmJmcztWZnJHZztlbmdzY2VkaWw7dGRvdHhvcGY7TGVmdFRlZVZlY3RUc3Ryb2s7dUh0aW1lcztzZW1pO05vdFN1Y2NlZWRzVGlhbGVwaDtyYXRpb2RhckNlZGlsbGFMZWZ0VXBWZXBsdXNzTm90TGVzc1NsYW50RXF1Tm90R3JlYXRlclNsYW50RXF1YWw7bGhibmN1cGduc2ltcmFyQ3VwQ2FwO09FbGlyaWdodGhhcnBvb25kYWd0aW1lc2Q7aGFpckpvcGZzZUFycjtSaWdodEFuZ2xlQnJhY05jYXFmcjtyZWFscGFydDt6ZWV0cm1jeXNicXVvTm90UmV2ZXJzZUVsZW1lbkdjZUhBUkRjeTtOZXN0ZWRHcmVhdGVyR3JldGlsZGU7dWRhTm90TGVzc0xlc3M7UmlnaHRBcnJubHQ7aG9tdGhiY05vdExlZnRUcmlhbmd0YXJnZW5zaW1lcVJpZ2h0Q2VpTGVzc0Z1bGxlcXNpbTtkd2FuZ2xlO25wYXJzT3ZlckJkb3dubmdlcXFFTkc7Y2lyY2xlZGNpcmNOZXN0bnByZWNleHNjcnNzdGFycXVhdGVybmljc3VibHRkb3Rob2FycjtkaWFtb25kc3Vpc2hvcnRtbnRsZztob29rbGVmdGFycm9XZnJMZWZ0RG93blZlY3RvckJhcjtmZmlSaWdodFVwVnNldG1uO0hpbERvd25BcnJvd1VwQXJuTGVmdHJpZ2h0YXJyb0xlc3NMZXNzVXBzaTt0cnBlemlzdWJuRTtzcXN1YnNldGVxZnJhYzE0O2lmZjt2ZU5vdERvdWJsZVZlcnRpY2FsQmFyO2xjZWlsO2V1bUh1bXBEb0RvdWJsZUxvbmdMZXJpZ2h0aGFycG9vbmRvUmV2ZXJzZVVwRXF1aWxpYnJpdWRvdGV4cG9vbGluZU5lc3RlZExlc3Nsb25nbGVmdGFycm9SaWdodERvd2ltYWNyT3BlbnJoc2NlZGlMb25nTGVmdEFycmxhcGlqbGlyb3BsdW5hcHByc2VtaUNvcHJvZHVuaTtwaG9Ob3RSaWdodFRyaWFyYWVtZW1wdHk7c3dBcnJzcXVhcmU7dWRibGF0d29oZWFkcmlnTG9uZ1JpZ2h0QXJyb2RibGFucmFycnduc3FzdXBlO3RjeWJpZ290aW1lc2VzY1NpZ21WdmRhcGx1c3R3b2Vnc2RvdDtjdXJ2ZWFycm93cmlnZ2Vxc2xhbmxlZnR0aHJlZXNmcm93bjtoY2lyY2N1cnJlbnN1cHNldDtMZnI7bmdFO1VuZGVyUGFEb3VibGVMZWZ0QXJycmlnaHRoYXJwb29uZG93Y2VudGVyZG90Tm9uQnJlYXZlZWJhcjtrb3BmTmVnYXRpdmVNZWRpdW1tc3Rwb3N2YXJ0aGVMb25nbGVmdHJpZ2h0YWxiRG93blRlZUFycm93O0V1bUxlZnRWZWN0b3JCYXI7bnZIYXJTdXBlcnNldEVxdW5wcjtzdXBoc3ViO2pjaXJjO2RyY29ycmVhbHN0YXJnZXRwaXRjaGZvcm11bHRpZXBzaTtkc2NydG9wYm90bnZyY2lyY2Vxc2VzUHNjcmhvb2tyaWdobGNlZGRhZ2dnbmFwRWZyO1VuZGVyQnJhY2tsZHJkaGFjaXJjbGVzbXRlb2ZjaXJuZ3NpU3VjY2VlZHNTbGFudEVxdWFsO25leFVkYmxVYmhlcmNvbjtSZXZlcnNlVXBFcXVpbGliclByb3BvcnRpb25hbGxhcmFwRUN1cExvbmdSaWdodEFycm93dnN1cG5lO1JpZ2h0VWhmckRvd25hcnJScmlnaHRhVGlsZGVGc3VtY2FwZHZhcnN1YnNldG5ud2Fycm9SaWdodERvd25WZWNuc2ltO2RpdmlkZW9udGltblJpZ2h0YXJyb2lvY2xuYXA7Y3VyYXJySGNpYXBhY2luc3VjYztyb3BscmFycnNib3hib09wZW5DdXJseVF1b3RlblZEYU5vdFJpZ2h0VHJpYW5nbGVFcXVyaWdodGxlZnRhcnJTdGFydmFyc3Vic2VvdGlsZGJhY2tzaW1lcTt2YXJwaGk7Q2FwaXRhbERpZmRIYXI7b2d0Tm90RVRoZXJlTm90VmVydGljYWxib3hWSE5hY3V0ZWNhcGFuZFN1cGVyc2V0RXFiZXBzaWRlZztTdWNjZWVkc1NsYW50RW9tZWdWb3JkZXJvbmVxdWl2O3BlcnRlbnRvc2E7Tm90RG91YmxlVmVydGljYW5yaW9mY0VtcHR5U21hbGxTcXVhcmU7bW9kZWxzO3ByZWNVcHBlclJpZ2h0QXJyU3F1YXJlVW5pb247bEFyTm90TGVzc0dyZWF0bGF0Tm90Q3JwYVVwYXJyb3dsamNTdWNjZWx0Y2lyO25WRGFzaFpvcFJpZ2h0RG93bnJhdGlvbmFic29saHN4dXRyaTt5ZW5Fc2ltO21hbGU7cGl0Y2hzZWFyaGt1ZmlzVm9Eb3VibGVVcEFycnByb2ZhbGFyaWdobnNob3J0bWlkO2JsYWNrdHF1b1lVY3lpZXhjY3VybHl3ZWRnZWxpbnRlcnNkdWhhTGVmdFRyaWFuZ2xlO25nZXFzbFlJY3NoYURvd25MZWZ0VGVlVmVjdG9yRG93blRlZUFycnVsY3JvbGRydXNoYXI7dXNjcjtzaW1nRW5MZWZ0cmlnTG93ZXJSaWdodEFycm93O3Vyc3Vic2V0bmVxcTtVY3N1cGRzVWdyYWltb2ZlbGluc3Vic2V0bmV6aXJhcnJoa0Fmck5vdEdyZWF0ZXJHcmVhdGVyO0NvbG9uc3NtaWxlTm90SHVtcEVsZWNhcmhvcGx1c2J0d29oZWFkbGVmbGVmdGxlZnRhcnJvd3NWZXJ0aWNhbFNlcGFyYXRkb3VibGViYW5SaWdodGFyVmVydGljYWxTZXBhcmF0b1RjdXJ2ZWFycm93Ym94dUw7Ymlnb3BsU2hvcnRVcEFycnN1Y2NuZXFxbmxFO1VjeTtJdGJpZ29wbHVzO2JpZ3NxY25zaG9ybXN0cG9TY2Fyb2Vxc2xhbnRnaG9va2xlZnRhcGx1c3NpbW52bEFycjtMZWZ0VXBEb3duVmxlZnRsZWZ0YXJyb3dzO0Rvd25MZWZ0VGVlVmVjYmlnc3FjdXF1ZXNiZXRoZXBhcnNyaWdodGxlZnRoYXJwb29ucztjbHVic3VpdFVwREV4cG9uZW50aWFscHJlY2NsYWdyYW54dXRyeGlkb3VibGVvZGJsYWM7YWNpckRhZ2d1Z250cmlhbmdsZWxlZnRucnJhbmdsUmlnaHRDZU5vdExlZnRUcmlhaGFsZXFzbGFudGd0cjtjdXZlZTtOb3RQcmVjZWRlc1NCb3BmO0xlZnRWZWN0b3JCendib3hkcm5taWQ7RG91YmxlTGVWZUxlZnRSaWdodFZlc3VjY2FwcHJsYWduYXBwbGVzZG90b2xhcnJiO2FjdVVuZGVyUGFyZW50aGVndGltZXNmbm9mO2toY3k7bmlzZDtsc2NySWFjdXRlcmlnaHR0aHJlZXRpbXB1bkZpbGxlZFZlcnlTbWFsbFNxdWFEb3REb0ltYWdpbmFyeWZvc3ViclZlcnRpY3JicmtzbHNtYXNobWFsdGVaZXJvV2lkdGhTaHN0cm9rO3ZhcnN1TmVnYXRpdmVUaGluU3JjYXZhcm5vdGhpbmdSaWdodFRyaWFuZ2xlQnJjZWRpcGl0bGVzZ2VVbmRlckJyYWNlO2VjaXI7Tm90UHJlY2VBc3Njb21wZm5wcnVyc3VwbGFycnNpbXJwb2ludGludDtIb3BDY2FpdGlsZGV0cmlhbmdsZXJpZ25idWxlc2NEb3duQnJlUm9oYXJybmU7YW5ncmthcHBhZG93bmRvd25hcnJvd25zaG9ydG1VY2lBdW1hcmtpb3Rsb25ncmlnaHRhcnR3b2hlYUxlZnRBcnJuY29uTHNjcm52aW5maW5jb21tYU5vdFByZWNlZGVzU2xJZG9uZ2U7RG93bkxlZnRSaWdodFZKc2NyaXByb2RoYW1pbEZzY3I7aWNpcmNyYXJyO2xoYXJ1O3dlaWVycHRyaWU7TmVnYXRpdmVWZXJUaWxkZUVib3hVbHByc3N1cHNlbmZydmFyZXBzT3ZlclBhcmVudGhlSnVrY0FncmF2ZTtvbWFjcjtzdWJzdXA7Q2lyY2xlUGxvYW5nO2ZyYWMxcGVybXJBdGFpbGRpYW07TG93ZXJMZWZ0QXJzcXN1YnNqb3BzdXBkb3RuZXNlYVJpZ2h0VmVjdHBlcm1pbGxtb3VzdGFjYm94aGRVbmRlckJyYWNrZXQ7TGVmdERvd25UZWVWZWN0b3JSZXZlcnNlRXF1aWx0ZnI7Y3V3ZWROb3RMZXNzU2xhbnRFY2lyY2xlYXJybWludWxkcmRSQmFyTGVzc0VxdWFsR3JlYXRlTnVvcmRlcm9mSnNlcmN2YXJzdXBzZXRuZWJsYWNrbG96ZW5nZTtzbGFycjtsY2FyUmV2ZXJzZVVwRXF1aWxMZWZ0VGVlQXJyb3duZ2Vxc2xhbnRVb2dvbjthbmdtc2RhYzt2RGFkb3duaGFycHN1YjtqdU5vdFByZWNlZGVzRXF1YWxkaXZvbm1hcmtlcHJvcHRvcm90aW1lc0lncmF2ZTtWYmFyO2Jub1JpZ2h0Q3BlcmlvZGV4cG9uZW50aWF1cHNia2Fyb3VydHByb2ZsZnJhc1RpbGRlRnVzdWJzdXBIc2NyO1ZzY3JsZHJ1bEF0YWlsO2N1cmx5ZXFzdWNjQmFyU2hvcnRVcEFycm92Y3k7Ym90dG9tO05vdFZlcnRpY2FsQmFySGFjZXBsdXM7ZXJEb3RMZWZ0VHJEb3VibGVMb25nUmlnaHRBc3NldG1ub29wZjt6aWdycXVvdE5jZWRpbGFuZDtMb25nTGVmdEFycm9sYnJrc2x1SW9wZkJlY2Fsb25nbWFwc3RvO25yQXJyZHJia2Fyb3c7c3VwaHN1YmNvbXBsZW1lbkhjY2FCZXJubmpjeTtzY3BjdXJseXZlZTtjaXJmbmludEZpbGxlZFZlcnlTbWFsbFNxdWFybWFwc3RvWmV0RXhwb25lRGVsQ2xvY2t3aXNlQ29udG91ckludGVwcmVjYXBwcm94TGNlZGlsT3RpbGRJbXBsaWd0Y2M7aG9va3JpZ2h0YXJyb3c7c3VjYztFcHNpbG9uS2N5aWluZmludXBkb3duYXJzY3NpYmxhY2t0cmlhbmdsZXJJY3k7VkRhc2hndmVydG5lcXFOb3RQcmVjZWRlc1NsYW50RXFaZG90O29kaWxkcnVzaGFDZW50VXBEb3d0aGVyZTQ7YmFja2VwbG9uZ21hcExlZnRVcFRvdGlsZGVyaWdodGFycm93dGFpbDtMZXNzRnVsbEVxdWFsO3VmaXNodFJldnZlZWJhcnJpZ2h0YXJyb3d0bmVBc3VwRUxtUVVPb21pbnV3Y2xBdGFpbHNkb3Q7cnJhcnJhbmdydHZiYW5nO1RSQURFSHVtcERvd25hbmdtc2Q7S29wZlVwZG93bmFyeHJBcnRoZXJIdW1wRXF1YWw7c2ltZTtMZWZ0VXBWZWN0b3JCYXJiaWdvdGltY2FwZG90Q291bnRlckNsb2Nrd2lzZXVkYmxhYztubGVmdHJpZ2h0YUdyZWF0ZXJFcXVMZWZ0VHJpYW5nbGVFcWxlcXFMb25nbGVmdGJsYWNrdHJpTm90R3JlYXRlckdyZWFlcXNZSXN1YnBsSXVrY1JjZWRpYnNvbGhzdXJ0cmlmcHJlY3NpbXN1YnBsdXM7Tm90U3VjY2VlZHNFcXVhbHZhcmVwc2lsb247aHN0cGx1c2NpcjtUaWxkZUZ1bGxFcXVlbHNkb0ZvckF1cGhhcnBvb25sZWZjYXBicmN1cDtsc2FxdW9vZGF1aGFycmZhbGxpbmdkb0xlZnRhVGhpblNwYWNlO2JkcXVzdWNjYXBwcm9KdWtjeXpjYXJIb3Jpem9udGF2YXJyaG87ZmZsaWdsdHJVcEFycmhrb2d0O2RpYU5vdExlc3NURG93blRlZUFycm93U3F1YXJlU3VwZXJSc2NDcm9zY3V2eG90YW5kc2xvSEFSSWFjbmNhcm9ubnJBcmJsYWNrdHJpYW5nbGVsZWZ0O0l1bWxvb3BhcnJvd2xlZnQ7YmFja3ByaW1lcXVhdGVybmlvbk5lZ2F0T29FbXB0eW9yc2xvcGVjdXJ2ZWFycm93cmluc3VwRXNlbWhhaXJzcDt1ZGFycnRyaWFuZ2xlcmlnaHRlbGVnZGxjcm9sb25nbWFwc2lpaWludDtnZ2c7UmNlZGlsO0xlZnRST3RpbG90cmJicmt3c2NyRWZycGxhbmNrc3VibXVsdDtraGNuc29sdGF0aWxkZTtuTGVmdHJibGsxMjtnZWRvdWJsZWJhcndlZGdlUm91bmRJbXBsaWVzY2FyZVZlcnlUaGluU3Bhc2NFUmlnaHRWZWN0b3JCYXhjYXBVcHBlclJpZ2h0QXJyb3c7YWxlZnN5bTtFb2dvbmR0ZG90U3FydDtMb25ncmlnaHRhcnJOb3RDb25ncnVlSW52aXNpYmxlQ1ZlcmJOdGl4Y1pkb3ByZUV4cG9uZW50aVFzZGVnb2ludDt0aGluc3BOb3RSaWdodFRyaWFuZ2xlO3JicmxjeTtOb3RTdWNjZWVkc1NsYWJldHdlRG93bkxlZnRWZWFwaWR2YXJ0ck5vdFNxdWFyZVN1cGVyc2V0RU5vdFN1Y2NlZWRzVGlsZGU7b2RpdkRpYWNyaXRpY2FsRG9MZXNzTGVzcHJlY25hcHByb253YXJocHJFa2NldXBkb3duYXJyb3RvcGNpcjtyaWdodGxlZnRhTmN5T3NsUmlnaHRGbGxlcXNsYW52ZWxsaXA7ZWdyYWxyY29ybmVyO1ByZWNlZGVzVGlsZGVTcXVhcmVJbnRlcnNlY3Rpb25uZGFzanVrY3lnZ3NvcGZOY3k7Y3VkYXJyZ2N5O0VxdWFsVGlvbWlkO1ZlcnlUaExlc3NFcXVhbFN1Y2NlZWRzU2xhR1Q7bWVhc3VOb3RHcnNpbXBsdXM7aWN5O3JiYnJEb3duUmlnaHRUZWVWZWN0b3I7WWZpZXhUcmlwbGVDb3Byb2R1Y3Q7Tm90R3JlYXRlclRpbGRlO2xlc3NzaW1ub3RpYWxlRGFzaERpYWNyaXRpY2FsRG91Ymx2YXJ0cmlhbmdsZXJpZ2RjYXJvYmJya3Ricms7bmlzZEVsZW1ub3RuaTtlZ3M7UHJlY2VkZXNDSGNnZG90O2hiYVJpZ2h0RG91YmxlQnJhbHBoYVJpZ2h0Q2VpbGluZ2hvbXRUcmlwbGhhcmRjeTtkb3BmUmV2ZXJzZVVwRXF1aWxpYnJpdW12eml6c2NyQ09Qc21hc2hwO3VsY29ybjtsZWZ0cmlnaHRoYXJwb29uU3FsdHJQYVJpZ2h0VGVlQXJybGVmdGxlZnRhcnJvb3RpbWVzYW9wZXJwO2ZvcmFSc2h5VGlsZGVFcWlzaW52YmlnY2FwO1VjaXJDY2Fyb25Eb3VibGVMb25nUnN6bGlGaWxsZWRTbWFsbFNxdWFsdGltZGJrYXJvbHVsZWZ0aGFycG9vbnVVbmRlclBhcmVudGhlc2lOb3RSaWdodFRyaWFuZ2xlQmFyYm93dGlCYWNrc2FuZ21zZGFVY2lyYztWdmRhc2hob2FndHJhcHBycmlnaHRoYXJwb29uZG93bk5vdE5lTm90TmVzdGVkTGVzc0xlc3NzdGFpbmZEb3duUmlnaHRWZWN0b3JCYXJuc3FzVW5lb3BmdmFycHJvcHRBcHBseUZ1bmN0aW9DbG9ja3dpc2VDb250b3VySW50ZWdyYWxEb3duUmlnaHRUZWVWZWN0bkxlZnRhck5vdEdyZWF0ZXI7Z3NpbWZmbGxpZztndkRvdWJsZURvd25kaXZpb2xjcm9UZnI7b21lY2lyY2xlYVJpZ2h0RG93blZlY3RvT3ZlckJyYWNrTGVmdFVwVlVuaW9uUEZzUmV2ZXJzcng7QmFyd2VkbmlzO3ByZWNzaVJpZ2h0Rmxvb0l0aWxHcmVhdGVyVGlsZGU7bGFycnRsO3N1Ym5lZGhhcmxOZWdhdGl2ZVRoaWNTcXVhcmVJbnRlcnNlY3Rpb25wYXI7QmFja3Nsa2NlZGlkaGFycjtVcERvd25BcnJsZHF1b3I7dkJQY3licnZnbGFydWxvbmdyaWdodGFycm9lZG90O2xiYXJyO3Byc2lpc2luZG90QmN0cnBleml1ZWdzdW9nb3NldG1pa2hjeVNjZWRpdXVtcHJvZnN1ck5vdEVxdURvdWJsZUNvbnRvdXJVcEFycm93O0xhbnJoYXJ1bGN1cmx5d2VQcmVjZWRlc1RpbERvdW53YXJoa3dlZGdlcXBhcnNpbTt1dHJpTmNlZGlsO2VhY3V0ZTtybGhhcjtSaWdodEFudkRhc2ZyYWM0VHNjcmJhcnZndHJhcFlhY3V0ZTt1YWNEb3VibGVMb25nTGVmdFJpZ2h0QXJOb3RTdXBlcnNldDtpaTtzcXN1YnNldHJzcWI7Y2lyc2NpbnZzaW1ucnRyaTtkaWdhbW1hbGVmdHJpZ2hhbmd6YXJyZnJhYzE2O3V0ZG5hYmxhTm9uQnJlYWtpbmdTcGFjZVJpZ2h0VXBUZWVWZWN0b3JyYXJyYztub3RuaXZiO1hvbGVmdGFycm93dGFpbDtmcmFjNDVDbG9zZUN1SGlsYnVwaGFycG9vbnJpZ0xvd2VyUmlnaHRubGVxc1JpZ2h0VXBWZWNzdXBzZXRlcWxlZnRsWXVtbnZzaXZzdXBuRTt4cmFycjtzc2NyO3NvbGJhcmNvbXBmcmlnaHRyaWdodGFycm93bGJicms7RGlmZmVyZW50aXNvZ3RjY25hdHVyYWxJYVljaXJjO0RhZ2dlQ2xvY2t3aXNlQ29udG91ckluTmVnYXRpdmVNZWxlZnR0aHJlZXRpbWVzTGVmdFRyaWFuZ2xlQlNxdWFyZVN1YnNldEVvcm9yO2RhcnI7Y2N1cHNzb2Rhc2g7WVVmYWxmcmFjMTJkb3RtaW5MZWZ0QXJyb3dSaWdodGFtYWNyTm90U3F1c3Vic2V0ZXE7Q2VudGVyRG91YmxlTG9uZ1JpTG9uZ3JpZ2h0YXJyb2JicmtwZmxlcXNsYW50c2VhcnJ2c3ViRXF1aWxpYnJuYnNwO2JrYXJvdzttaW51c2R1SnVuYXR1ZnJhYzEyO25zdWJzZXRlcXE7QXNzaWdsZWZ0cmlnaHRhcnJvd3Nob3J0cGFybGVmdHJpbnJBcnI7cmhhdXBocnBwb2xucGFOb3RHcmVhdGVyU2xlcmFycmRvd25kb3duYXJycGVybWlsc2ltO2Ria2FnY2lydHdvaGVhZGxlZnRhcmNjZWRyc3F1bztEb3VibGVMb25nTGVmdFJpZ2h0QXRwcmltYXN5bXA7cHJlY3NpbTtubGVzcztJc05vQnJlYUNjb0RDdXBsdXNjaXJ1cFVuZGVyQnJhY2Vob3BmYmFydmVlYW1hY3I7c21hbFVwRXF1aWxzZG90YjtCdW1wZXFDZWRMZWZ0VE5vdFJlbGN5cXN0cmlhbnlVZ05vdFN1Y2NlZWRzU2xhbnRFQ3NwcmVjY3VyS3NjRXhpc3RzO2x0cmljdXBicmNMZWZ0cmlnaHRhcnJvY2N1cHNzbTtFZG90O05vdFN1YnNldDtuc2hvcnRwYXJhbEVtcHR5VmVyeVNtYUNvbnRvdXJJRm9yQWxsO2luZmludGllO1ljeTtsZWZ0cmlnaHRzcXVpUmlnaHREb3duVGVlYXdjb25pdGhpY2tzaVJvdW5kSW1kb3duYXJyb3dsZHJkaE91Z3ZuRXRyaXRpVW1hY3I7Q2F5bGJhcndlZGdlQ291bnRlckNsb2Nrd2lzZUNvblNxdWFyZVN1YnNlcnRyaWx0cmlMZWZ0UmlnaHRuYWN1dGU7Tm90U3VjY2VlZHNFbGJiclhvcHJ0aHJlRWNpcmNMc2hwcmVjYXBwTGVmdFRyaWFuZ2xlQmFyUmlnaHRhcnJvd0NoRGFnZ2VybnN1YnNlR3JlYXRlckVJb2dvbmxuYXB5c2NybGJyYWNrO0RmcjtnZXNkb3R2cHJvcGxhbmt2O0RvdEVHZFJlUmV2ZXJzZVVwRXF1aWxpYnJpUGx1c01pbnVpaW5mc3VwRTtlbXNwUmlnaHRVcERvdXBkb3duYXJyb3dxc2NyY3JvcXVlc3Q7dWxjb3J2emlnemFnO3RoZXRhc3ltO1VvZ29uRGFnQ3JvemhjbWlkY2lyO250cmlhbmdsZWxlZnRlcTtlcHNpbG9ueHVwbGJpZ3ZlZWN1cGNhZXhwZWN0YVNob3J0bmxlZnJhbmdlRmNVcHBlclJpYmlnY3VwTm90Q3VSZXZlckxlZnRUcmlhcmFycmJ2YXJwck5vdFN1YnNldEVxdVVSYXJydGw7TmVnYXRpdmVNZWRpdW1TcGFHZG9FZ3Jhdm5MZWZ0cmlnaHRhcnJvdztkb3duaGxhcDtTcXVhcmVTdXBlcnNldEVxdWFsO0ZmcjtkaWFtb25TdWNjZWVkc1NsYW50RXFpbWFncGFySXVrY3lsYXJycGw7QW9nbm90bml2YTtzdGFyO3NpbXJhcnI7TFROb3RQcmVjZWRlc0Vuc2hvcnRwYXJhbGxlbG11bXNkb3RlcGl0Y2JpZ2N1Y29tbWd0cXVlRGlhY3JpdGljYWxBY3V0ZTtsb29wYXJyb3dyaWdodDtsYXJybHNtdGVzYW5nbXNkYWRzcmFycjtQbHVzTWludXM7dm5zTHByb2ZsaUVhY3V0ZHdhU3VjY2VlZHNUaWxlc3NndHJlYXN0ZUlvdGFEb3VibGVSTGVmdEFuZ3JobztSZXZlcnNlRXF1RG93bkFycm93VXBBY3VsYXJyO2x1cnVoYXJsZXNzZXFnU2NhcmN1ZXByYmNvbmdkc292YW5ncnF1YXRpSnNlcmN5O3N1cGhzb2xSaWdodFRlRG91YmxlTG9uZ1JpZ2hidWxsZXRDY29uaW5MZWZ0YXJyb3h3ZWZsaG9yYmFDYXBpdGFsRGlmZmVyZW50aXJzcXVzcGFEb3duTGVmdFZlY3RvckJhcjtOb3RTcXVhcmVTdWJzZXRFcXVhbGJveEhMZXNzR0NvbnRibGszcm9hd2NOc2NyVGZFbXB0eVZlcnlTbWFsbFNxdWFydGhlcmVmb3JlVG9wZmV4aXN0O2RkO2xmbG9vY2FwYm5zaG9ydEltO1Jhcmx0cXVMYVZiYXVwdXBVcEVxdWlsaWJyaVNob3J0RG9uZWFyaGtyYWNlcGx1c2FsdGxhVWNpcmNSaWdodFVwRG93blZlY3RvcjtIaWxiZXJ0U3BhY2U7cmlnaHRhcnJvdztQcm9kdWN0YnByaW1SaWdodFVwVGVCYWNrc2xhc2g7bWNvZHVhcnI7RmlsbGVkVmVzaGNoY3k7Y2lyY2xlYXJyb3dyaWdodDtjdGRvdGdlcXNscmVnVEhDb25ncnVlYW5nbXNkYnNjcjtsZWZ0dGhyZWV0aW1lcztsYXF1YmxhY2t0cmlhbmdsZWxlZnRsYXF1bztndHJlcXFsZXNzO3BybmFZZnI7SHN0cm9raW1hY3I7SUVmaWxpZztzdWJzZWZyYWMxNTtudTtsYXJybHA7ZGFsZXRoTm90UHJlY2VkZUxlZnRBcnJvd0JhckRvdERMb25nbGVmdGFyV0NjZWRpbWFsZUxlZnRUZWU7cmZsb1JpZ2h0VmVjdG9yO1VwQXJyb3dEb3duQXJyb3d2ZWVlcXBhcmE7Y3V2ZVNjeWNlbnRzdXAxVHNjdXB1cGFycm93cztkd2FuTm90UmlnaHRUemZOb3RTcXVhcmVTdWJzZXRFcWxkc2g7VGlsZGVUbHJjb1plcm9XaWR0aFNwYWNMZXNzRXF1YWxHcmVuZ2Vxc05vdFNxdWFyZVN1cGVyc2VzcXN1YjtVcFRlbGhhcnVsY2N1cHM7U3VwZXJzZXRFcXVhbEF1bWw7Ym94SFVIYXRwc2NyO2hzY3I7Y3VydmVPdm5sdHJpZTtsb25ncmlnaHRhcnJvdztTdWNjZWVkc1Rib3hkUlNxcm9sY0dUbmFuZztuc2NyO25vdG5pdmVmckdyZWF0ZXJFcXVhbGN1cmFjdXJseXZlUmV2ZXJzZUVxdWlsaWJyaWJhY2tlcHNpbGxvbmdsZWZ0cmlnaHRhT3VtbExjYXJvYmxhY2t0cmlhbmdsZWRvd3RpbWVzYmxhcnJ0bFN1YnNldE5vdFRpbGRlRXFjdXJ2ZWFycm93bGVmdHNsQ2xvY2t3aXN5c3RoaWNrYXBwcnhvZG90bmxlZnRyaWdodGFycm93O2NjaXJjO3JkcXVvYmFsc3Ryb2tjb21wbGV4ZXM7Tm90UmV2ZXJmcmFjNzg7Z2ltR2JyZXZlQ2NlZXFzbGFudGd0cmx0aHJwbHVzbW47WmNhcm9ub3JzbG9wZTtzaG9ydHBhTG9uZ2xlZnRyaWdodGFycm11bHRpbUNsb3NlQ3VybHlRdW9vdW1sO0NvdW50ZXJDbG9ja3dpc2VDb250b3VySWx0aHJlRG91YmxlQ29udG91cWZyZWNpTmVnYXRpdmVWZXJ5VGhpblNwYWNTaG9ydFJpZ01lZGl1bVNEaWFjcml0aWNhbEdyYXZUcmlwbWFwc3Rndm5Mb25nTGVmZ3RyZXFxbGVzTm90SHVtcEVxdXVjeTticmV2ZU5lZ2F0aXZlVGhpblNwYWFlbGlnRXhwb25lbnJhbmdkO2hiYXI7U3VwZU5vdExlZnRUcmlhbmdsZUVxdWFub3RpbkU7YW5nbXNkYWF4d3VvZ0xvbmdSaWdodEFycm9FdW1sO2JhcndlZDtSaWdodENlaWxpbm50cmlhbmdsZXJpZ2h0ZVJldmVyc2VzdWNjc2N1cGN1cHl1YW5Eb3duUmlnaHRUZWxhcnJodXVhcnI7bWRhc3BsdXNhY2lOb3RUaWxkZTtiZERvd25MZW5sSGlsYmVkdHJpO2dseWVuZXFvbGNpYmFja3Npb3JkZXJzcXVmO3RyaWFuZ2xlbGVmdGVxO0xvbmdsZWZ0cmlnaG9sYXJyO0RpYWNyaXRpY2FsRG91YmxlQWN1dHJmaXNpZ3JhdmV0aG9MZXNzR3JlYXRlckNsb2Nrd2lzZUNvbnRvdXJJbnRlZ1JhcnJucGFyYWxMZWZ0cmlDY2Fyb2FuZ2xlcnNhb3VMZWZ0UmlSZXZlcnNlRWxlZnRoYXJwb29uZG93ZWRiTW9kc2N5O1JpZ2h0VXBWZWN0b3JCb21pY3JvbjtkdHJpZjtibGsxNGFjRTtUc3RyZXF1ZXhjYXA7bWFsdDtuZ2Vxc2xhbnduZXF1aXZIc2ZsbE1lbGxpbkF0aWxkdm5zdXA7cGxhbmNraFNxdWFyZG90cGx1cztudkhhcnJCbW5wbGJveFZoUmlnaHRUcmlhbmdDaXJjbGRjYU5vdEdyZWF0ZXJTTm90U3Vic2V0RXFsdGhyZWVMZWZ0RG93bnN1cHBsSW52aU92ZXJCcmFja2V0c3VjY2N1c3VibkVDaXJjbGVQbGxlc3Nkb3RpbmNhcmU7bG5FO2VuSW50ZWdyYWw7UHJlY2VkZXNTbFBoTGVmdFRyaWFuZ2xlRXF1YURpYWNyaXRpY2FsRG91YmxlQWNmZmxsbWRhUmlnaHREb29nb25pdWtjeTtoZWFydHM7RG91YmxlUmlnc29sYjtlc2ltaW50ZVBzY2JveGhEO1JpZ2h0Rmxvb3JNZWRpdW1TcGFjZTtpbnRlcmNhbExzY1BvaW5jYU5vdEdyZWF0ZXJMZXNzbWl2cG5mcjtEb3VibGVMZWZ0UmlnaHRBcnJPZ3JhdmRqY21ERG90O21zY1N1cHNldGV4cGVjTm90U3F1YXJlU3VwZXJzZXRFcXVhbG1sY3A7Q2NlZGlsTGVmdFRyaWFubkxlZnRhcnJvdztEWmNEaWFjcml0aWNhbEFjdXR3ZW5jb25nckF0YUFtYWNvdGltU3VjZ3RybExlZnRhckF1bWxib3hWbm90aW52YmJpZ29kb2Jicmt0YnJraWlvdGE7WHNjcjtyaWdodGxtc3RwQ2xvc2VDdXJseURvdXRkb3Q7eHVwbHV4ckFaZXJvV2lkdGhCdW1waW9nb250cmlhbmdsZXE7UmV2ZXJzZUVxVFNvdGlUYWJyb2JyaztOb3RTcXVhcmVTdWJzZXRFaXVtcnBVbmRlclBhcmVudGhlc2lzRXF1YWxUaWxkZW5zdXBFO2JveHZIO3htYXA7c2VhcnI7bWNvbW1hTm90TGVzc0dyZWFwcmltZTtJbnZpc2libGVUaW1lemN5Tm90R3JlYXRlclRpbGRtbnBsdXNsYXJyZnM7bG1vTmVnYXRpdmVUaGlja1NweXVjeTtsZXNzc2ltO2pmZGl2b254Ym94ZFI7aGtzZWFyb0xlZnREb3VibGVCcmFja2V0O2ZyYWMzOGdhbWFmbnNob3J0cGFyYWxsZXVwdXBhcnJvd2V4Y2ZwYXJ0aW50O3hzcWN1RG93blJpZ2h0VHR3b2hlYWRsZWZ0YXJyb3dwZnJQbHVOb3RFeGlzdHM7bGRxVXNjcjtpc2NyZGl2b254O3NvcGY7SW1wbGRjeTtjbHVic3VpY2lyO0xlZnRVcFZlY3RvckJhcjtzdXBoc3VvZnI7ZGlzaW5sZXFzbGFUY2FyTWludW5yaWdodGFycnZzdURvd25SaWdodFZlbHRxRm9yQWxsTm90SHVtcERvd25IbWFya2VyO2V1cm9VcERvd25BcnJvdzt5dW1sYWdyY3V3ZWQ7ZG90c2dlcXNsYW50O0NhcDtoa3NlYVVtYWNlY2Fyb0NvdW50ZXJDbG9ja3dpc2VDb2xhY3V0ZTtib3hWclZ2ZGFzaDtsZkp1a2ltYWdEb3VibGVMb25nUmlnUmlnaHRBcnJvdztOb3RTcXVhcmVTdWJzZVN1Y2NlZWRzRXF1YWw7RGFsb25nbGVmdHJpZ2h0YXJyb3c7TW9wZlJvdW5kSW1wbE5vdFJpZ2h0VHJpYW5nbGVFcW53YXJyO092ZXJQYXJlbnRoZXNpczt6aWdyYXJyO0RvdWJsZVZlU2M7dXBzaWhQcmVjZWRlc1NvcGFyO2x1cmRzaGFycWludGVwYXJzbDtOb3RMZXNzTGVzWW9wZlJjeTtIaWxiZXJ0U3BhY2xyY05vdFRpbGRlRmludGxFdGFjeWxjdGVtYWNyTm90VmNzdWI7ZXBhcmxvcGFyO2VzaXN1cGRzdWJyYmF5dWNCYXJ3ZXBhcmFsbGVvcmlnb2Y7cHJlYztOb3REb3VibGVWZXJ0aWNhbEJHcmVhdGVyR3JlU3Vic2VuTGVmZmNyYXJOb3RTdWNjZWVkc1RpbGRpbmJhY2twUmlnaHRUZWVWZWN0b3I7c21pZFRjZWRpbDtOb3RDb25ncm5zcHRvcGZvcnRyaXRpbWV4bEFyZ3RybGVzY3BvbFhmcmVscztndDtsb25nbWFwc3RvcmlnaHRsZWNoZWNrbWhzbGFzaDtxdWVzdGVxO3hvZGduZXFxO250aW1DbG9zZUN1cmx5UXVvdEZpbGxlZFNtYWxsVmVydGljYWxyZHF1b3JsYWN1dGVQcmltZTtSaWdodFRlZW11bHRpbWFwO2N1cnZlYXJyb3dsSXRpbGRlO1NIY3lLb3BQcm9wb3JOb3RQcmVjZWRlc0VxdmFydHJpYW5nbGVsZWZ0O3lvcGZsQmFMb25nUmlnTm9uQnJlYWtpblpvcGY7ZGl2aWRlb250dGhlcmVmb3JlO0VncmFZdURvdWJsZUNvbnRvdXJJbnRleHBvbmVudHJzcVRoZXRoa3N3YXJvaWNpcm51bTtleHBlY3RhdGlvbjtzaW1PRU9tZWdhO3h1cGx1cztvc2NyVGFiO2dFO3N1cHN1Yjt2QmFyZHdhbmdsZWxkcnVzb3RSaWdodERvdWJsZXByaW1lc3dhcnI7T3ZlckJyYWNrZW52ckFyckxzdHJva0h1S0pwZXJ0ZW5rO0ZpbGxlZFZlcnlTbWFsbFNxdUxlc3NTZWxsTm90R3JlYXRlckZ1bGxFcXVhY2VkZnJhYzEzO0V1bWxYbmxlcXNsYW50O2Rvd25oYXJwb29ucmlkb3RwbHN0cmFpc3FzdXBzZXR4c2NMZWZ0RG93blZlY0xhcGxMZWZ0VXBEb3dSaWdodERvd25WZWN0aXNpbmRvdDtiZXRhcmFycnc7d2VpZXJzdXdmTm90U3VjY2VlTm90R3JlYXRlckVxR2FtbWFkbnNtaWQ7c3Njcll1bWw7Z2VzZG90b2w7cHJFO05vdExlc3NTbEFncmN3Y29uaW50TGZVcEFycm93RG93UmlnaHRhcmV0YURvdWJsZUxvbmdMZWZ0QXJyb3d0ZWxhc0xlZnRUZWVBUmlnaHRBcnJvd2VxdWlmcmFjMTg7c2VjZHN0cm9rSGlsYmVydFNwYWNlZ3Ryc2lOb3RQcmVjZWRIb252bHRyaWVOZXdMYmFydmVlO0Rvd25MZWZ0bGRyZGhhcmN1cGN1RXBzaWxMbWlkb3Q7c3RhcklvdGE7Ym94VkxuY2VkaWJsYWNrbG96ZW5nZW1pZGRvdDtscnJhdE5vdFN1YnNmZmxkZmlzcnVsdWhhclVwRXF1aWxpc2hjaHhjdXBzcXVhcmY7WWFjYXBjdWFjdXRlUmU7dXNjZG91YmxSaG9SaWdodFVwVGJveGRsO25zaW1lO1BvaW5jYXJlcGxhbkxlZnRSaWdodEFOb25CcnNzdGFyZjtTY2VkaWw7Q29udG91cmNmTm90UmlnaHRUcmlhbmdsZUJhcjtSaWdodFZDYXBpdGFsSW90UmlnaHRWZUx0O3RzaHpIZlJvcGFuZ3J0dmJkSGFjZWtuYXBvS2Zydm5zdWI7YW5nc3R4Y2lob29rbGVmdGFycldlZGdzaW1wbHVzYm94VWZyb1JpZ2h0VXBWZWN0b3JCYXJDZWRpbGxhO2xuYXBwbGVmdGhhcnBibGFja2xEb3VibGVVcERvd25BcnJvcnRyaWxQYXJEc3Ryb2tOZXN0ZWRMZXNtY25wb2xpbnQ7cXVlc3RiaWd0cmlhbmdsZWRvcmNhcm9uO21hcGtoT3Bhc2NDaXJjbGVQbHVzO0xvbmdMZWZ0UlBjc2Nuc2ltc2ltZ0U7bnRyaWFuc3FjYXBzO3NpbXBsdVN1Y2hjbHVic3VlckRvYmV0SnNjU2hvcnREb3duQXJyY3JhcnJiYWNrY0RpYWNyaXRpY2FsRG91YmxlQVRoZXJlZm9ya2FwcERpYWNyaW5wcmN1dWJyY2xlZnRyaWdodHNxb3JhcnJvdGlsZGU7Tm90UmlnaGN1ZXNjcm9wYU9taWNyYXJyYXA7Tm90R3JlYXRlckdyaWdodHJib3h1TENhcGl0YWxEaWZmZXJlUmlnaHRUcmxjZWRpbE5vdFN1cGVyQ2xvc2VDdXJseVF1aWFjdXRlVWFycm9jaXI7dUhhcmxoYXJ1bDtkaWFtb25kc3VpdDtTcXVhcmlnaHRyaWdodGF6aWdyYXJyc21hbGxzZXRtaW51c0xvd2VyTGVmdEFlcHNpbG9Ob3RWZXJ0aWNhbEJhcjtmbHRPQXNjcmNvbXBsZW1lbnRvZGJsWm9TcXVhcmVVbmlvbk5vdG1zTWNsZWZ0YXJyb2JhY2twcmltTm9ueGZsYnJhY2t6aGN5O1dlZ3RxdWVzdDtsb2JSZXZlcnNlRXF1aW9mckdjaXJjO0thcFJzY3JzdWNjbmFwcHJveGdyYXZlO3hoQXJlY29sb25nb25vdG5pdmM7blJpZHJia2Fyb0ltYWdpbnVkYXJOb3RSZHJjb3JuO05vdFN1Y2NlU3F1YXJlU3VwZXJzZXRFcXV0aW1lc2JhSHVtcEVxdWFBdEdyZWF0ZXJGdWxsRXJvcGx1cztwc2NyYm94ZHI7bGVmdHJpZ2h0c3F1aWdhcnJvd0Nmcnpkb3Q7aGFJT2NMZWZ0VXBWZWNjaXJjbGVzc3NpdXBoYXJwb29ucm5wYXJzbExlZnRBbmdsZW1hcHN0b3VwUmlnaHRBbmdsZUJyYWNrZXQ7Ym94dXI7dWNOYWN1dGU7RG91YmxlTGVmdEFycm93Y29weXNkaXNpbjtQaGk7Tm90VGlsZGVFY2lyc2NsZXNjY0NheWxlS2NlZHB1c21hRG93bkJyZXZlcnNxdW9yO3NvZnRjaWlpaW50YWN5O2NvcHlzcjtvaG07ZmVTdWNjZWVkc0VxdW5lZGJzZW1pO2JuZXF1aXY7VGhpY2tTcGFVYXJyb25jYXBDY2lOZWdhdGl2ZU1lZGl1bVNwYWN1cGRvd25hcnJvdztudnNpbTtib3hWcjtsb25nbFNPZm9ya3ZXY2lnaW1lbDtuc3Vwc2V0O2xhY3V0ZG91YmxlYmFyd2VkZ2U7UGx1c01pbnVzamNOb3RHcmVhdGVyU2xhbnRFcXVhbE5vbkJyZWFrdnppZ3pPdmVyUGN1d0Nsb2Nrd2lzZUNvbnRvdWJsYW5rU21hbGxDaXJvcnNsb3NsdXdvcmFwbHVzZW1hbHRlc2VzdWJzZXRVcHBlckxIQVJEY0VtcHR5U21hbHNtYXNocENyb3NzVXBwZXJMZWZ0QXJzdXBuRTtidWxsO2V4cGVjdGF0UmV2ZXJzZUVxdWlsaWJybG9uZ3JpZ3V1YXJkb3duaGFycG9vbnJsRTtwaG1tYXRzbWFsbHNldG1pbnVzO2JveGRyUmFuZztuc3ViZTtlRERvY3N1bGFtYmRzaW1kb3Rjb21wbGV4ZWFscFJpZ2h0RG93blZlY29uaW5zZWN0VXBUZWV5c2NyO1lJY3k7ZXJEb3Q7TGVzc0xlTmNhcm9uO29wZXJwVXBkb3duYXZub3JhckpvcGY7aGtzd2FzdHJhaWdocHNpO2dkb0licHJpbWVOb3RHcmVhdGVyR3JlYXRlcmFncmF2ZXRjYXJvZXF2cGFyTm90RXF1YWxhc3RScmlnTGVmdFJpZ2ZhbGxpbmdkb3RzZXFLYXBwYTtzb2w7VmVyeU5vdEdyZWF0ZXJUcm1TdWNjZWVkWUFjeW52ZGFzaE5lZ2F0aXZlVGhpdm9wZkxsZWZ0YXJyb3c7Z2RvdExlZnRUZWVWZWN0b3I7cHJlY25zYmxhY3N0cmFpZ2h0ZXBzaWxvZnJhYzM0O25lc2l0aGljbmxhcnI7Q3NjZGxjcmluZmluTGVmdEFuZ2xjdXJ2ZWFycm93bGVmdDticHJsZXNzYXBiaWd0cmlhbmdsZWRvd1VhY3V0cmlnaHRhcnJvd2FsZXBQcmVjZWRlc1NsYW50RU1lbGxpSnNlcmxsaFVmcnJjZWl0d2l4Q2FwaXRhc3FzdXA7c2NjbXVsdGltYXBvZHNvbEdyZWF0ZXJTemV0c3JhdW9nb247RmlsbGVkVmVyeVNtYVJvdW5kSW1wbGllcztjdXJyZW47Q29uZGJrYXJvd25hdHVyYWw7ZG90bWludXNPRWxpZ2lmcjtscmNvcnNjc2ltO21vZFRoaW5TcGFjYXBlO2RmcmRvd25kcmRxdWxtaWR2cnRyaTtMb25nbGVmdHJpZ2h0YXJyb0Jlcm5vdWxwcmVjbmVxcUJzY3I7Ym94SERMb3BkZnI7aW9wZlNob3JwcmU7dnNjaW50cHJ0Tm90TmVzdGVkTExlc3NGdWxsRXF1YmN5bnZpbmZuZXNpbTtkaXNpQ2FScmlnaHRhcmNjaXJsYXRlc3J0cmlsdHJpO0VtcHR5VmVyeVNtYWxsU3BsdXNhY2lyTGVzc0xlc3M7VGlsZGVUaWxuZXhpc3RzO2xvbmdsZWZ0cmlnU2hvcnREb3dOZXN0ZWRMZXNzTGVzc05lZ2F0aXZlTWVkaXVtU0VtbGVmdHJpZ2h0c3F1aWdhcnJ1cmNvcnN1cG5FTm90U3VjY2VlZHM7bGVmdGFycm93dGFpdXB1ZXBOb3RSaWdodFRyaWFuZ2xlTEpjUnVsZ3RyZXFsZXNTaG92clJ1bGVEZWxheWVkbndBcnI7amZycmNhcm9uTm90RG9Eb3VibGVSaWdodFRlZTtMYXB1YnJjeWJvY2lyY2xlYXJyb3dyeGNpcmN4b2RvVWdyYXZndmVydmFya2FwbnN1dkJhcjtib3hEcnBhcnNsSGlsYmVydFNwYWxlc2RsdmVMZWZ0QXJyb2lpaURvd25UZWVBTGVmdFZlY3RvT21lZ2FsZGNhO2xlZnRoYXJwb29kaGxlZnRhcnJvd3RhdHdvaGVhZGxlZnRhUmlnaHRUYmxhY2tzcXVhcmV1Z3JhdmVjaXJtaURpZmZuc3Vic2V0O3R3b2hlYWRyaWdodGFybnNob05vdFN1Y2NlZWRzVGlsZGVEWmN5O3VyY29MYW1jb21wO1N1cHNlZXBsdXNMZXNzRnVsY2FwY2N1cGRpbXBzcXN1cE5mcmhrc3dhcm93SW1hY2xlc3NlcWd0cjtTdXA7YmlnY2l0cmxwYXJscnVsbmxlZnRyaU5vdE5lc3RlZExlc3NscGFybHQ7TG93ZXJSaWdodEFHcmVhdGVTaWdtYUdvcGV0dWhhc2hrZ3JlZW5HcmVhdGVyRnVsVXBFcXVpbGlicml1bWJjb2x0Y2lybXNjcnBlTm90R3JlYXRlY3Vkc3F1ZmFwcHJveDt6aGN5dmFyc3Vwc2V0bmVxbGxhcnI7bGFuZ2Ryb3RpbWVzO2xhdGVIb3BmbmxBVXBFdGVscmVscmNvcm5PbWljckFzc2lnbjtsZmlzaHQ7YmxhY2tzbmV4aXN0O2ZvcGZOb3RMZWZ0VHJpYW5nbGVCTG9uZ2xlZnRyaWdjdXJ2ZWFycm93bGVmbWlkZG90cnRyaWx0cm1ucGx1czt1aGFybDtSb3VuZEltcGxpZXJpZ2h0YWZyc2ltO05vdFJldmVyc2VFbGVtZW50d3JlcGFyc2w7cmFjZTtGaGFsZkRvdWJsZUxlZnRzbXQ7bnNxc3VCZXJub3VsbHNlY3Q7S3NjcnZhcnJoZ2FjdXRlO3JlY3Q7Tm90U3FsZWZ0aGFycG9vbmRvd250aGlja3NUaGVjY2VFc05vdFJpZ2h0bGZsb29yQ2lyY2xlTWludXNiZHF1bztJbnZpc2libHJhcnJFb3BmdWxjTGVmdFVwVmVjdG9yQmFtZWF2Y3lEc2NlcmF0cmlhbmdsZXJjdXBkb3R4bEFycmVxc2xhRGVsdGRIYXJEb3RFcXVhcnVsdWhLSmN5bnNob3J0cGFyYWxsZWw7dG9wZmRpdmlkZW9udGlOb3RIdVJpZ2h0RG93blZlY3RvckJhcjtuYXByaXNpbmdkb3RzZXFuYXR1cjtOZWdhdGl2ZVZlcnlUaGluR3JlYXRlclRpRGlmZmVyZW50aWFsbG9uZ2xlZnRVcEFycm93RGF0aWxkV2NpcmM7dmFyc3Vwc2V0c2ltcGxMZWZ0QXJyb3dSaWdodEFycm9Eb3duVGVlQXJtYWNyO0Rvd25MZWZ0VmVjdG9yQkRvdWJsZUxvdHNjU3F1YXJlSW50ZXJzZWN0aW9uO2FjdXRlO25yYXJyO0Nsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhQ2lyY2xlRG93bkxyY3VidGhlbHRpbWVzTGFtYmRhSG9yaXpvbk5vdENvbmdydWVudG9ncmF2YWVsaWp1a1N1cHNFQnVtcGVyaW5nTGVmdERvd25WZWN0b3JCYXJBYWN1dGU7Ym90dG9tY3VybHllZGRvdHNyZGNhO0JhcndEY2F0d29oZWFkbGVmdEludGVyc2VjdGlsbnNUaGlja1NwYWNlb2xhbHZuRTtsc3F1bGVmdHJpZ2h0aGFycG9vbnNsYXJydGlxdWVzdHRoZXJlNHRmTm90SHVtcERvd25IdW1wO3l1bW5vdGluRXF1YXRlcm5pb25MZWZ0eW9wZjtOb3RMZXNzVGlsZGJsazM0O0xjYVRoZXRhaW50cHJ0cmlkb3Q7bGNzdWNjYUNsb3NOb3RTdWJzZVJvdW5kd3I7c2ltZ2xzcXVvO05vdEVsZUNvbGRpYW1vbmRzdmFyc3Vwc2V0bmVxcU5vdFJpZ2h0VHJpYW5nbERvdWJsZVZzdWNjbmFwcE5KY29zbGFzaHV3YW5nbGVsb29wYXJyb3dyaWdodFVuZG9kb1phY3VJc2NyO29vcE9wZW5DdXJseVF1b3RlO2hlcHNpbE5vdEdyZWF0ZXJMZXNFcXVhbFRjeW5zcGFhZ3JhdnJvYW50YXJQb3Bmc2lndXB1cGFyclVncmF2ZXN1cEpmR3JlYXRlckdyZWF0ZXJyZWN6b3BmO01hSWNsRWdmamxpZztOb3REb3VibGVWZXJ0aWNkb3VibGViYXJ3ZU5vdFN1Y2NlZWRzU2xhbm53YXJyb3c7UmFjdXRlZ25zaW07YW5nbXNkYWZTaG9ydERvd25BSW52aXNpYmxlVGltZXNtbnBsdWJyY2lyY2x4b2x0cmlmdXBoYXJwb29ucmlTcXVhcmVJbnRlcnRyaWFuZ2xlbGVmdGVJbnZpc2libGVDb21zdW5nO3ZhcnRyaWFuZ2xlcmljZnJob29rc3FzdXBzZXN1cDM7bGJicmtWZXJ0aWNhbFNDaXJjbGVNaVJldmVyc2VVcEVxdWlsaWJQcmVjZWRlc1RpdXBkb3duZGFsb3NvbDt0b3Bmb1N1cGVyc2V0SW52aXNpYmxlQ29tbWJveFZSO2N1cmx5d2VkZ2VsbW91c3Rib3RMZXNzRnVsbEVmcm93bm5ic2xlc3Nkb3Q7bmxlcVpIY3ljZG90bmFwaWRleGNsO21ERGNpcmM7SW1wTGVmdEFycm93UmlnaHRBcnJvd0xlZnRVcFZlY3RzZnJvd2RvbGxhcjtkZG9MbGVyQlZlcnlUaGlwcmVjY3VybEl1a2N5O2FlbG52bGU7c2V0bWluTGVmdFVwRG93blZlc3NtUnVsZURlTm90Q29uU3Vic2V0RUNlbmNpcnNnZXNkYXN5bXBvbXlpY3lUU0hjeTtPcGVuQ3VybHlEb3VicGl0Y2hmdGhlcmV0aG9ybnN1Y2Nuc2ltZG91c3dhY2hjU3Vwc2V0O0RvdWJsZURvd2RvdHBsdXNyQXNhRGlhY3JpdGljYWxHckxlc3NTbGFudEVxdWFsY2VtcmF0aW87UG9pbmNhckNybG96ZW5nZTtTc0RpYWNyaXRpY2FsR3JhckhhcjtzdHJhaWdodHBoaXJiYXJsb29wYXJyb3dyRG93blJpZ2h0VGVlVmVjU2hvcnRMZWZ0QXJTdXBuTHR2RFNjTGVmdEFycm93QlZlcnRpY2FsTGluZTtndmVydGZhbGxpbmdycGFyZ3Q7dmFyZXBzaWxvbm5ndHJRb2RlbXB0RXNpbWVsO0ZvdXJpZXJ0b2RzQmVybm91Y29weTtuY2V2YW5ncHJvZmFsYXJzcGFkbGdEb3duUmlnaHRWZWN0bnZsdHJpZTtsZWZ4c3FjdXA7ZW1zcDFBbmROb3RFbGVtZXZhcnBoaURhcnI7bmNhcm9uO2RlbHRhVmVydGljYWxUaWxkZTtSaWdodFVwVmVjdG9yWXNjdHBjaGlzcGFkZXN1aXRsb2FuZ3NjdHdpeHQ7UmlnaHRWZWN0b2JhcndlZGdQcmVjZWRla29wUmlnaHRhcnJvdztjdXBicmNhcHNoYXJ0aGV0YTt4b3RpbURvdWJsZUxvbmdMZWZ0Umllc0ltYWdpbmFDb3VudGVyQ2xvY2t3aXNlQ05vbkJyZVJpZ3N1YnN1Yk5vdEh1bW9wbHVzSGlsYmVydEVtcHR5U25MZWZ0cmlnaHRhZWNhclVwQXJyb3dCYXJOb3RMZXNzVGlsZGVVcERvd25EaWZoYXJkY3libGFja3NxdWFyZTtHY3lvZ3JvbWljcm9ucmhhcmFuZ3J0O0tvcGY7RGlhbURvdWJsZURvZG9wZjtFYWN1dGVMZWZ0VXBEb3duVmVjdG9yO29jaXJjO1pjYXJvZGFic29saHN1Yjtwc2lyZHF1bztsZnJTcXVhcmVTdWJsb2Fqc2VyY3k7b2FjdXRlO2N1cmx5RWNhcmhvb2tyaWdodGFyclNob3J0TGVOb3RFcXVhbDtGc2NIQU91bWw7UmlnaHRBcnJvd0Jhck5lZ2F0aXZlTWVkaXVtU3BNaW51c1BsdUd0O2JpZ2NhcE9FbGd0cmRvdDt3cmVhdWN5VXBwZXJSaW5maW50aWVzd253YXI7U2hvcnRSaWdodEFyckVtcHR5VmVyeVNtYWxsU3F1YXJlO3ByZWNuc2lwcmVjbmFwcHJEY2Fyb247YW5nbXNkYWJlcXZhcFByZWNlZGVzU2xhbnRFcXV1cnRyY2Fyb25vZHNvbGRSaWdodFVwRG93U2Npc1ZlcnRpY2FsQmFTYWN1dGVDYXBpdGFsRGlmcmFjNDU7aGFycnduYXBpZDtVb3BmeGhhcnJidW1wRTtuTGVmdHJpZ2hHcmVhdGVyU2xhbnRFcXVjbHVicztTaXVicmdlc2RvdG9jb3BFbWFjcnJBck1vcGY7TGVmdERvd25UZWVWZUxlc3NFcXV0d2lPZGJsYWM7bnNxZ3ZlcnRuZXFxO3Byb3A7RG91YmxlVXBEb3duTGVzc1RpbGRMZWZ0VGVlQXJyZEFybnByZWNsZXNnZXM7YmxhY2t0cmlhbmdsZWxlZnRyaXBsdWhvbXRodEFuZDtsY3ViO0xlZnRyaWdodGFycmxsYUludGVncmFsbm90aW52b3JzbHRpVmVyeVRoaW5Ob3RSaWdodFRyaWFuZ2xlQmFEb3VibGVMb25nTGVmdERpZmZlcmVudGJvcGY7bGRjYUhBUkREb3duTGVmdFJpZ0Rvd25MZWZ0VGVaZXJvV2lkdGhTcGFjZWxuZTtSaWdodFVwRG93blJpZ2h0VXBUZWVWZWN0c3NlaW1hZ2xpblFzY3I7ZGRhZ2dlcjtOZWdhdGl2ZU1lZGl1bVNwYWNlO21hcHN0b2RvR2FXZWRnZTt4Y2lybHRsYXJzdXAxO3huaXNybW91cmFjbGxhcmJwbnNwYXJOb3RUaWxkZUZ1bGxFcXVhbExhcGxhY2V0cm5zdXBlbmV4aXNoc2xhc3ZhcnRyaWFvZGJsYWNibGsxMnJwcG9saW50ZnJhYzEzYm94dmxsc2FxTmVzdGVkR3JlYW5nbWRmaXNodGJzY3JudkhhcnI7bnZhcHN1cG1uc210aGV0YXJubWlkc2hhcnBScmlnaHRhcnJwcmltZXM7b2Fjbmdlc2NvbG9ucmRjYUxvbmdMZWZ0UmlnaHRBcnJvd0VUSDtscmhhcmlnaHRoYXJwT2NoY2lscnRyaWVxdnBhcnNsO0Nsb3NlQ3VybHlEb3VibGVRdWNvcHJvZGdlc0RzdHJvQ29wcm9UaGVyZWZveGxhcnJhYWN1dGVucHJEb3VibGVMZWZ0VGVMZWZ0VGVlQXJyb3c7c3VicGx1SW1hY3JRb3BlbXNwMTRib3h1bHNpZ21hO09wZW5DdXJseURvdU1vcHhkUmlnaHRUZWVWZWN0b3ZiYXBpdGNoZm9PcGVuQ3VybHlEb3VibGVRdW90ZXVwaGFycG9vbmxlZnQ7Tm90TmVzdGVkTGVDY29uaW50bnVtZXJvemFjdXRlO1JpZ2h0RG93blRlZVZlUm91bmRJSlphY3V0ZTtnbmVxO25MZWZ0cmlnaHRhcmJrdHdvaGVhZHJpZ2h0YXJyb2hvb2tyaWdlYWN1TWN5UmlnaHRhcnJvTGNhcm9uO25lYXJyUmlnaHREb3VibGVCcmFja2V0SGlmZmRvd25oYXJwb29ubGVic2VJbXBsaWVzO2xicmtzbGNpcm1pZEN1cENFY3lwcmVjbnNpbWd0cmFycm5MZWZ0cmlnaHRnbkJhY2tzbGFzbG5hTmNhcm9uQ291bnRlckNsb2Nrd2lzbGRxdW87bG93YmFycm9hcmlnaHRzcXVpZ2Fycm93O2ZyYWMyNWJjb252c3VibkVsdHJQYXJsdXJ1aGFyO01lbGxpbnRyZjtzdW5Ob3ROZXN0ZWRMZXNtRERvaW1vTG9uZ2xlZnRhcnJvdztudkRzcXVhcnN1cGxhcnI7Y2lyY2xlYXJyb3dyaU5vdFN1Y2NlZWRzU2xhbnRFcXVhbDtucnRyaW52ckFycjtibGszNHZhcnRyaWFuWmNhcnVwc2k7VHJpbW9kZWxzbWVwYXJzbDthbmdtc2RhaDtsbVVwZG93bnZhcnRoZXRhO2Rvd25kb3duYXJyb3dzO3ZlbGxkakRvdWJsZURvdFJpZ2h0RG93blRldGhrc0hvcml6b250YWxMaW5lZWc7RG93bkxlZnRSaWdodFZlRW1wdHlWZXJ5U21hbGxTcXVhcmVsYXJyYmZpb3JsaExhcGxhY2V0RG91YmxlVXBzdWNOb3RMZWZ0VE5vdEdyZWF0ZXJUaWxOb3RDb25nTm90TkVsZW1lbnQ7cmlzaW5nZG90c2VxO1NxdWFyZVNUc3RaZG90bGVmdHJpZ2h0YXJUaGlja1NwYWNFcHNpbGVzc2J1bXBlcVljaXJjYWdyYWVxY29Eb3VibGVVcEFycm9UcnhjYVJhUmlnaHRBcnJvd0JhU2hvcnRMZWZ0Z2JEb3VibGVDb250b3VySW50ZXBvaW50aXZBcmhlYXJ0c3VOb3RHcmVhdGVyR3JlTGVmdEFycm93UmlnaGFyY3JhUmlnaHRUcmlhbmdsZUVxdWFsO2NhcGJyY3RyaWFuZ2xlO1BhcnRpYWxEbGVmdGFyckRKRmZyWW9wZjt1cmNvcm5ucmFycnBzcmZyaXNpbjtBcHBsc21lcGFyc2xwdW5jZGlhbW9uZDtsYnJrc2xkO2VxdWxvbmdyaWdodGFycm93Ym5vdDtHbG9uZ2xlZk5KY2RDaXJjbGVNaW51RW1wdHlWZUxhcGxhY2V0cmY7Y3N1cDtMSmN5O2xvbmdsZWZ0YXJyb3djZWRpc3ViZWRvdDtsb3BhRG91YmxlTGVmdFRsb3plbmdlTm90TmVzdGVkR3JlYXRUUnZkYW50cmlhbmdsZXJpZ2hMb25nbGVmdHJpZ2h0YXJ2YXJyZWFzdGxlZnRyaWdodHNxdWlnYXJyb2JveGJob29rbGVmdGFycm93O2NpcmZuaW9lbGlzdXBsYXJuYnVtcGVOb3RMZXNzRXF1YVNxdWFyZUludGVyc2VjdFJpZ2h0QXJyb3dMZW1wdHlzZXJhcnJwbDtWZGF4b3RpbWV0YXJneXVjeXRoZXJlZm5vdGluZG9oeXBoZW47U29wZmRyYmthckJzb3Bhck92ZXJCcmFjbGVmdGhhcnBvb25kb3duO0Rvd0FvcGY7cHJvcHFpbnQ7aGFpcnNnRWxibm90TGVmdFVwVGVlVmVudHJpYW5vdGludmI7Z3RyZXFsZXplZXRjdXBzO3N1cHNpbTtVc2NyTG9uZ3JpZ2h0YVBvaW5jYXJlb3I7VXJpVWJyZXZkaWFtcztaY2lzaW5FO2xzaXZmcjtud25ld3NMZXNzR3JiaWdzdG9taWNycHJpbWVzdmVsbGFycnBpc2ludjtEb3VibGVSaWdodEFycm5nZXFlcXVpdkRzb2Z0Y3k7blJpZ2hqc2VyY3lSYW5nYXdjb1VwcGVyUmlnaHRBcm9yaWdvZm5MdDt1ZmlzaGxhbmdWZXJ0aWNhbExpU2NlZGxvb3BhcnJvd3JpbHQ7bnZpbmFjdXRldWJyZXZlO1ZlZVlhY3V0ZWduc2lkd2FuZ2xMY3lPcGVuQ3VybHlEY2FwYmxhY2tzcXVhc3Vwc3VwO2xvemY7TGVmdFVwRG93blJpZ2h0RG91YmxlQnJhY2tldDtyZWFscGF6b3BMZWZ0Rmxvb3JpZ2h0cmlnaHRhcnJvd3NjaGVja21hcmtzaG9ydHBhcmFsbE9kYmxhY05vdFByZWNlZGVzU2xhbnRFcXVhbDtkb3RlcWRvUnJpZ2h0YXJyb2hvYXJyRG90RXF1YWxiYWNrc2ltO2ZyYWM1NkxlZnRWZWNsZWZ0aGFycG9vbmRvd09kYmxUaGVybmJzcHBhcmFsbGVsO01lZGl1cHJhcGJsYWNrbG96TGxlZnRhcnNtc3Bhcjttc3RBYm11bHRuYnVtdmFya2FMZXNzR3JlYWVtcHRpbmN4cmFyQ2NpcmNiZXBza3NFcXVpbGlicml1dUhhcjtwbHVzbWNzdXBlO1RyaXBsZURpbWFGaWxsZWRTbWN1cmFybnRyaWFuZ2xlbGVOb3Q7cmFycnRTSENIZ2ZyO2xvc29sTm90U3VjY2VlZHNTbGFudEVxdWVyRGdpbWVsU3F1YXJlVW5Eb3duYXJyb3c7ZGlhbW9uZGFsY2VtcHRhcmluRXhpc3VwZG93bmFycnN1YmRMZXNzRnVsbEVxdWFsYXdjb25pbnRsb29wYXJyb3dsZWxsQW1hWWNpblJpZ2h0YXJyb3d0cmlwTGVzc1NsYW50RWxoYmxycHByaWdodGxlZnRoYXJwb3djaXJjc3VjY2FwcHJveFVwcGVyTGVmdEFycm93O3JhY3V0ZWVsaW50ZXJCZXJhcnJscDtydGhyYXRpb25hbHM7Ym94ZGxBY2lyYztnb3BmO2p1a2NTdW1mZmlsaVdm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JyB0eXBlPSkAAADvVBQABgAAAPVUFAAHAAAA/FQUAAEAAAAvaG9tZS9iLWZ1c2UvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9zdHJpbmdfY2FjaGUtMC44LjIvc3JjL2F0b20ucnMYVRQAYAAAAAcBAAAfAAAAGFUUAGAAAAAFAQAALwAAAFNvbWVgAAAABAAAAAQAAABhAAAATm9uZXN0YXRpY2lubGluZWR5bmFtaWNBdG9tKCcnIHR5cGU9KQAAAMNVFAAGAAAAyVUUAAcAAADQVRQAAQAAAC9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3N0cmluZ19jYWNoZS0wLjguMi9zcmMvYXRvbS5yc+xVFABgAAAABwEAAB8AAADsVRQAYAAAAAUBAAAvAAAAe306AGxWFAABAAAAbVYUAAIAAACwVRQAAAAAAFF1YWxOYW1lcHJlZml4AABjAAAACAAAAAgAAABkAAAAbnMAAGUAAAAIAAAACAAAAGYAAABsb2NhbAAAAGcAAAAEAAAABAAAAGgAAABBdHRyaWJ1dGVuYW1lAAAAaQAAABgAAAAIAAAAagAAAHZhbHVlAAAAZwAAAAQAAAAEAAAAWwAAAGlubGluZW93bmVkc2hhcmVkVGVuZHJpbDw+KDogAAAAHVcUAAgAAAAlVxQAAgAAACdXFAACAAAAKQAAAERXFAABAAAAb25lLXRpbWUgaW5pdGlhbGl6YXRpb24gbWF5IG5vdCBiZSBwZXJmb3JtZWQgcmVjdXJzaXZlbHlQVxQAOAAAAE9uY2UgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZAAAkFcUACoAAABjYWxsZWQgYE9wdGlvbjo6dW53cmFwKClgIG9uIGEgYE5vbmVgIHZhbHVlL3J1c3RjLzkwYzU0MTgwNmYyM2ExMjcwMDJkZTViNDAzOGJlNzMxYmExNDU4Y2EvbGlicmFyeS9zdGQvc3JjL3N5bmMvb25jZS5ycwDvVxQATAAAAJUAAAAyAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvbGF6eV9zdGF0aWMtMS40LjAvc3JjL2lubGluZV9sYXp5LnJzAABMWBQAZgAAAB4AAAAQAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvcGFya2luZ19sb3RfY29yZS0wLjguNS9zcmMvcGFya2luZ19sb3QucnMAxFgUAGsAAABTAQAAFwAAAMRYFABrAAAAbgEAABcAAABrAAAACAAAAAQAAABsAAAAbQAAAG4AAAAIAAAABAAAAG8AAABQYXJraW5nIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybS9ob21lL2ItZnVzZS8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL3BhcmtpbmdfbG90X2NvcmUtMC44LjUvc3JjL3RocmVhZF9wYXJrZXIvd2FzbS5yc5pZFAByAAAAGgAAAAkAAACaWRQAcgAAAB4AAAAJAAAAmlkUAHIAAAAiAAAACQAAAJpZFAByAAAAJgAAAAkAAACaWRQAcgAAACoAAAAJAAAAL2hvbWUvYi1mdXNlLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTZmMTdkMjJiYmExNTAwMWYvcGFya2luZ19sb3RfY29yZS0wLjguNS9zcmMvcGFya2luZ19sb3QucnMAXFoUAGsAAAAyAQAADAAAAFVURjhWYWxpZGF0aW9uRmFpbGVkT3V0T2ZCb3VuZHN0ZW5kcmlsOiBvdmVyZmxvdyBpbiBidWZmZXIgYXJpdGhtZXRpYwAAAPdaFAAmAAAAdQAAAAQAAAAEAAAAdgAAAHcAAAB4AAAAdQAAAAQAAAAEAAAAeQAAAHoAAAB7AAAAdQAAAAQAAAAEAAAAfAAAAH0AAAB+AAAAAGFzc2VydGlvbiBmYWlsZWQ6IG1pZCA8PSBzZWxmLmxlbigpdQAAAAQAAAAEAAAAfwAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWUAcFsUAAAAAABsaWJyYXJ5L3N0ZC9zcmMvaW8vYnVmZmVyZWQvbGluZXdyaXRlcnNoaW0ucnMAAADYWxQALQAAAAEBAAApAAAAdW5jYXRlZ29yaXplZCBlcnJvcm90aGVyIGVycm9yb3V0IG9mIG1lbW9yeXVuZXhwZWN0ZWQgZW5kIG9mIGZpbGV1bnN1cHBvcnRlZG9wZXJhdGlvbiBpbnRlcnJ1cHRlZGFyZ3VtZW50IGxpc3QgdG9vIGxvbmdpbnZhbGlkIGZpbGVuYW1ldG9vIG1hbnkgbGlua3Njcm9zcy1kZXZpY2UgbGluayBvciByZW5hbWVkZWFkbG9ja2V4ZWN1dGFibGUgZmlsZSBidXN5cmVzb3VyY2UgYnVzeWZpbGUgdG9vIGxhcmdlZmlsZXN5c3RlbSBxdW90YSBleGNlZWRlZHNlZWsgb24gdW5zZWVrYWJsZSBmaWxlbm8gc3RvcmFnZSBzcGFjZXdyaXRlIHplcm90aW1lZCBvdXRpbnZhbGlkIGRhdGFpbnZhbGlkIGlucHV0IHBhcmFtZXRlcnN0YWxlIG5ldHdvcmsgZmlsZSBoYW5kbGVmaWxlc3lzdGVtIGxvb3Agb3IgaW5kaXJlY3Rpb24gbGltaXQgKGUuZy4gc3ltbGluayBsb29wKXJlYWQtb25seSBmaWxlc3lzdGVtIG9yIHN0b3JhZ2UgbWVkaXVtZGlyZWN0b3J5IG5vdCBlbXB0eWlzIGEgZGlyZWN0b3J5bm90IGEgZGlyZWN0b3J5b3BlcmF0aW9uIHdvdWxkIGJsb2NrZW50aXR5IGFscmVhZHkgZXhpc3RzYnJva2VuIHBpcGVuZXR3b3JrIGRvd25hZGRyZXNzIG5vdCBhdmFpbGFibGVhZGRyZXNzIGluIHVzZW5vdCBjb25uZWN0ZWRjb25uZWN0aW9uIGFib3J0ZWRuZXR3b3JrIHVucmVhY2hhYmxlaG9zdCB1bnJlYWNoYWJsZWNvbm5lY3Rpb24gcmVzZXRjb25uZWN0aW9uIHJlZnVzZWRwZXJtaXNzaW9uIGRlbmllZGVudGl0eSBub3QgZm91bmRFcnJvcmtpbmQAAHUAAAABAAAAAQAAAIAAAABtZXNzYWdlAHUAAAAIAAAABAAAAIEAAABLaW5kT3Njb2RlAAB1AAAABAAAAAQAAACCAAAAgwAAAAwAAAAEAAAAhAAAACAob3MgZXJyb3IgKXBbFAAAAAAAZF8UAAsAAABvXxQAAQAAAGFscmVhZHkgYm9ycm93ZWR1AAAAAAAAAAEAAAAEAAAAbGlicmFyeS9zdGQvc3JjL2lvL3N0ZGlvLnJzAKhfFAAbAAAA6gIAABQAAABmYWlsZWQgcHJpbnRpbmcgdG8gOiAAAADUXxQAEwAAAOdfFAACAAAAqF8UABsAAAD7AwAACQAAAHN0ZG91dAAAhQAAAAwAAAAEAAAAhgAAAIcAAACIAAAAZm9ybWF0dGVyIGVycm9yACxgFAAPAAAAKAAAAIUAAAAMAAAABAAAAIkAAACKAAAAiwAAAGxpYnJhcnkvc3RkL3NyYy9zeW5jL29uY2UucnNgYBQAHAAAANAAAAAUAAAAYGAUABwAAADQAAAAMQAAAGxvY2sgY291bnQgb3ZlcmZsb3cgaW4gcmVlbnRyYW50IG11dGV4bGlicmFyeS9zdGQvc3JjL3N5bmMvcmVtdXRleC5ycwAAAMJgFAAfAAAAkQAAAA4AAABtZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAAD0YBQAFQAAAAlhFAANAAAAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJzKGEUABgAAABVAQAACQAAAGxpYnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnNQYRQAHAAAAEECAAAeAAAAUGEUABwAAABAAgAAHwAAAIMAAAAMAAAABAAAAIwAAAB1AAAACAAAAAQAAACNAAAAjgAAABAAAAAEAAAAjwAAAJAAAAB1AAAACAAAAAQAAACRAAAAkgAAAHUAAAAAAAAAAQAAAJMAAABVbnN1cHBvcnRlZEN1c3RvbWVycm9yAAB1AAAABAAAAAQAAACUAAAAVW5jYXRlZ29yaXplZE90aGVyT3V0T2ZNZW1vcnlVbmV4cGVjdGVkRW9mSW50ZXJydXB0ZWRBcmd1bWVudExpc3RUb29Mb25nSW52YWxpZEZpbGVuYW1lVG9vTWFueUxpbmtzQ3Jvc3Nlc0RldmljZXNEZWFkbG9ja0V4ZWN1dGFibGVGaWxlQnVzeVJlc291cmNlQnVzeUZpbGVUb29MYXJnZUZpbGVzeXN0ZW1RdW90YUV4Y2VlZGVkTm90U2Vla2FibGVTdG9yYWdlRnVsbFdyaXRlWmVyb1RpbWVkT3V0SW52YWxpZERhdGFJbnZhbGlkSW5wdXRTdGFsZU5ldHdvcmtGaWxlSGFuZGxlRmlsZXN5c3RlbUxvb3BSZWFkT25seUZpbGVzeXN0ZW1EaXJlY3RvcnlOb3RFbXB0eUlzQURpcmVjdG9yeU5vdEFEaXJlY3RvcnlXb3VsZEJsb2NrQWxyZWFkeUV4aXN0c0Jyb2tlblBpcGVOZXR3b3JrRG93bkFkZHJOb3RBdmFpbGFibGVBZGRySW5Vc2VOb3RDb25uZWN0ZWRDb25uZWN0aW9uQWJvcnRlZE5ldHdvcmtVbnJlYWNoYWJsZUhvc3RVbnJlYWNoYWJsZUNvbm5lY3Rpb25SZXNldENvbm5lY3Rpb25SZWZ1c2VkUGVybWlzc2lvbkRlbmllZE5vdEZvdW5kb3BlcmF0aW9uIHN1Y2Nlc3NmdWx0aW1lIG5vdCBpbXBsZW1lbnRlZCBvbiB0aGlzIHBsYXRmb3JtM2QUACUAAABsaWJyYXJ5L3N0ZC9zcmMvc3lzL3dhc20vLi4vdW5zdXBwb3J0ZWQvdGltZS5ycwBgZBQALwAAAA0AAAAJAAAAY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXigZBQAIAAAAGxpYnJhcnkvc3RkL3NyYy9zeXMvd2FzbS8uLi91bnN1cHBvcnRlZC9sb2Nrcy9tdXRleC5ycwAAyGQUADYAAAAUAAAACQAAAG9uZS10aW1lIGluaXRpYWxpemF0aW9uIG1heSBub3QgYmUgcGVyZm9ybWVkIHJlY3Vyc2l2ZWx5EGUUADgAAAAQAAAAEQAAABIAAAAQAAAAEAAAABMAAAASAAAADQAAAA4AAAAVAAAADAAAAAsAAAAVAAAAFQAAAA8AAAAOAAAAEwAAACYAAAA4AAAAGQAAABcAAAAMAAAACQAAAAoAAAAQAAAAFwAAABkAAAAOAAAADQAAABQAAAAIAAAAGwAAAA4AAAAQAAAAFgAAABUAAAALAAAAFgAAAA0AAAALAAAAEwAAAPVeFADkXhQA0l4UAMJeFACyXhQAn14UAI1eFACAXhQAcl4UAF1eFABRXhQARl4UADFeFAAcXhQADV4UAP9dFADsXRQAxl0UAI5dFAB1XRQAXl0UAFJdFABJXRQAP10UAC9dFAAYXRQA/1wUAPFcFADkXBQA0FwUAMhcFACtXBQAn1wUAI9cFAB5XBQAZFwUAFlcFABD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CzEEewE2DykBAgIKAzEEAgIHAT0DJAUBCD4BDAI0CQoEAgFfAwIBAQIGAQIBnQEDCBUCOQIBAQEBFgEOBwMFwwgCAwEBFwFRAQIGAQECAQECAQLrAQIEBgIBAhsCVQgCAQECagEBAQIGAQFlAwIEAQUACQEC9QEKAgEBBAGQBAICBAEgCigGAgQIAQkGAgMuDQECAAcBBgEBUhYCBwECAQJ6BgMBAQIBBwEBSAIDAQEBAAILAjQFBQEBAQABBg8ABTsHAAE/BFEBAAIALgIXAAEBAwQFCAgCBx4ElAMANwQyCAEOARYFAQ8ABwERAgcBAgEFZAGgBwABPQQABAAHbQcAYIDwAABBtI7SAAsI8EgQAPxIEAAA3umCgAAEbmFtZQHT6YKAAIoFAANub3cBSmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnN0ZXA6OmgxZmEzOTQwZjUwMGM4NTEyAj5odG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+OjpzdGVwOjpoMDlkZmZiOWFlNjNiOWY1OQODATxodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+IGFzIGh0bWw1ZXZlcjo6dG9rZW5pemVyOjppbnRlcmZhY2U6OlRva2VuU2luaz46OnByb2Nlc3NfdG9rZW46OmhhZjRkMmUxYjlhZDNiMWY1BCdjb3JlOjpzZXJpYWxpemVfbm9kZTo6aDA4MGIyYWJiN2JmYzU0NjIFSGNvcmU6Om51bTo6Zmx0MmRlYzo6c3RyYXRlZ3k6OmRyYWdvbjo6Zm9ybWF0X3Nob3J0ZXN0OjpoZjUxODAxMGQ1NmUxNDM2YQY9aHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6ZW5kOjpoZmFlYWFiNjkzYmE3Y2NlZAdFY29yZTo6bnVtOjpmbHQyZGVjOjpzdHJhdGVneTo6ZHJhZ29uOjpmb3JtYXRfZXhhY3Q6Omg2ZTRiMGY5OGE3ZDFjN2RlCFVodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjphZG9wdGlvbl9hZ2VuY3k6OmhhYWM2ZjY2OGQ2ZjljNzk3CTpkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjptYWxsb2M6OmgyMWNkMDgyMzk2NTIzZDkyCjR0ZW5kcmlsOjpzdHJlYW06OlRlbmRyaWxTaW5rOjpvbmU6OmhjOWUyNzkyMGNiZjkzNjUwC4QCYWxsb2M6OmNvbGxlY3Rpb25zOjpidHJlZTo6bm9kZTo6SGFuZGxlPGFsbG9jOjpjb2xsZWN0aW9uczo6YnRyZWU6Om5vZGU6Ok5vZGVSZWY8YWxsb2M6OmNvbGxlY3Rpb25zOjpidHJlZTo6bm9kZTo6bWFya2VyOjpNdXQsSyxWLGFsbG9jOjpjb2xsZWN0aW9uczo6YnRyZWU6Om5vZGU6Om1hcmtlcjo6TGVhZj4sYWxsb2M6OmNvbGxlY3Rpb25zOjpidHJlZTo6bm9kZTo6bWFya2VyOjpFZGdlPjo6aW5zZXJ0X3JlY3Vyc2luZzo6aDVjNjMzMDY4ZDg1ODA2OGYMS2NvcmU6Om51bTo6Zmx0MmRlYzo6c3RyYXRlZ3k6OmdyaXN1Ojpmb3JtYXRfc2hvcnRlc3Rfb3B0OjpoMzJhMTZlYmE4ODcyMjFhZQ1JaHRtbDVldmVyOjp0b2tlbml6ZXI6OmNoYXJfcmVmOjpDaGFyUmVmVG9rZW5pemVyOjpzdGVwOjpoYjJiYzJiNzllNjk1MmI1Mg4wY29yZTo6c2xpY2U6OnNvcnQ6Om1lcmdlX3NvcnQ6OmhjZTQ2NDZmNDc3M2FiOWU0D0BoYXNoYnJvd246OnJhdzo6UmF3VGFibGU8VCxBPjo6cmVzZXJ2ZV9yZWhhc2g6Omg5MWNhOTUzMDdmZjUxZmRiEEpodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6ZGF0YTo6ZG9jdHlwZV9lcnJvcl9hbmRfcXVpcmtzOjpoZDRlMDI2YTExMmQ1ZmFkYhFCY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6OnJjZG9tOjpOb2RlRGF0YT46Omg2YjZiYWU1NjUxMjUwN2E5ElFodG1sNWV2ZXI6OnRva2VuaXplcjo6Y2hhcl9yZWY6OkNoYXJSZWZUb2tlbml6ZXI6OmZpbmlzaF9uYW1lZDo6aGE2YjZhN2EyYzRiOTMwYmITMGNvcmU6OnNsaWNlOjpzb3J0OjptZXJnZV9zb3J0OjpoOTA5NjllODc3ZDQzYmZmYxREbWFya3VwNWV2ZXI6OnV0aWw6OmJ1ZmZlcl9xdWV1ZTo6QnVmZmVyUXVldWU6OmVhdDo6aGQ5NTI4ODY5Y2VjNzQxNTEVazxzdHJpbmdfY2FjaGU6OmF0b206OkF0b208U3RhdGljPiBhcyBjb3JlOjpjb252ZXJ0OjpGcm9tPGFsbG9jOjpib3Jyb3c6OkNvdzxzdHI+Pj46OmZyb206Omg5NjljYTEzMjE2ZmNhZjU3FltodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjphZGp1c3Rfc3ZnX2F0dHJpYnV0ZXM6Omg1ZjQyNTkwZGQ2NWYxZDljFzdjb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk11dDo6Y2FsbF9tdXQ6Omg2OTNkNGFhZjVlMGU1MDVkGDdjb3JlOjpyY2RvbTo6YXBwZW5kX3RvX2V4aXN0aW5nX3RleHQ6OmgwNzQ1ZDE0YWU1MzAzZjQ3GTFjb3JlOjpzdHI6OnNsaWNlX2Vycm9yX2ZhaWxfcnQ6OmgyNzEyOTVjMGY3ODA3YzFmGkdtYXJrdXA1ZXZlcjo6aW50ZXJmYWNlOjp0cmVlX2J1aWxkZXI6OmNyZWF0ZV9lbGVtZW50OjpoY2NmZjI2ZjRmZTBlNjRjMBs+cGFya2luZ19sb3Q6OnJhd19tdXRleDo6UmF3TXV0ZXg6OmxvY2tfc2xvdzo6aDkyYjI3NmRiNTg3ODI2MGYcUHRlbmRyaWw6OnRlbmRyaWw6OlRlbmRyaWw8RixBPjo6cHVzaF9ieXRlc193aXRob3V0X3ZhbGlkYXRpbmc6OmhmZWMzMGMyYTY3OTg0ZTE0HVB0ZW5kcmlsOjp0ZW5kcmlsOjpUZW5kcmlsPEYsQT46OnB1c2hfYnl0ZXNfd2l0aG91dF92YWxpZGF0aW5nOjpoZmVjMzBjMmE2Nzk4NGUxNB5QdGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDxGLEE+OjpwdXNoX2J5dGVzX3dpdGhvdXRfdmFsaWRhdGluZzo6aDk2YjQxYzEwNDAyM2ZhYjQfVGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46Omluc2VydF9lbGVtZW50OjpoZDQ1ZjAwM2UyMTY0MTEyMSBXaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Zm9yZWlnbl9zdGFydF90YWc6OmgxZDkzMzUxMjZhNjhjNmJiIV1odG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojpwcm9jZXNzX2VuZF90YWdfaW5fYm9keTo6aDAyMDRhMmIwMDljYmU4NTgiOGRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmZyZWU6Omg0ZWQ4M2U5M2JkMDc0NDIwIypwaGY6Om1hcDo6TWFwPEssVj46OmdldDo6aGE4NWYyMWY2ZmNlYjlhYWMkQWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0YWdfc2V0czo6c3BlY2lhbF90YWc6OmgzNDFmOWFmNTc3MDU5NjhiJThjb3JlOjpudW06OmJpZ251bTo6QmlnMzJ4NDA6Om11bF9wb3cyOjpoZmQ0MTVhMzY3ZDIxNjEzNCZKaHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6ZmluaXNoX2F0dHJpYnV0ZTo6aGJiODYzYjcyYTUzM2ZkMmInYjxhbGxvYzo6dmVjOjpWZWM8VCxBPiBhcyBhbGxvYzo6dmVjOjpzcGVjX2V4dGVuZDo6U3BlY0V4dGVuZDxULEk+Pjo6c3BlY19leHRlbmQ6Omg0M2FkOTZhZWE4N2VjM2MxKEhjb3JlOjpudW06OmZsdDJkZWM6OnN0cmF0ZWd5OjpncmlzdTo6Zm9ybWF0X2V4YWN0X29wdDo6aGVlYzYzMWMyNTUzNGZjZTApcDxjb3JlOjpyY2RvbTo6UmNEb20gYXMgbWFya3VwNWV2ZXI6OmludGVyZmFjZTo6dHJlZV9idWlsZGVyOjpUcmVlU2luaz46OmFwcGVuZF9iZWZvcmVfc2libGluZzo6aDllMGMwOTQxNDJiZDA0NzcqLGNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpwYWQ6OmhjODY3MGEwOWIyNmU2MjE3KzNjb3JlOjpzdHI6OmNvdW50Ojpkb19jb3VudF9jaGFyczo6aGI0ZTNlNDFjMDZlNjMxMWIsMTxzdHIgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGEzYTAxNjQzZDExNDU0OTItXWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmhhbmRsZV9taXNuZXN0ZWRfYV90YWdzOjpoMTRlNmI1NzkxYzlkYmExMS5QbWFya3VwNWV2ZXI6OnV0aWw6OmJ1ZmZlcl9xdWV1ZTo6QnVmZmVyUXVldWU6OnBvcF9leGNlcHRfZnJvbTo6aDM4ZjliYzc2MDJhYWQ1MjEvSmh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OmVtaXRfY3VycmVudF90YWc6Omg5ZmZmMjk4ZjYxYTFiYjQ5MA1fX3JkbF9yZWFsbG9jMVxodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjpyZWNvbnN0cnVjdF9mb3JtYXR0aW5nOjpoZjk3MGZmMWIwOWZhZTllMzJRPGh0bWw1ZXZlcjo6dG9rZW5pemVyOjpzdGF0ZXM6OlN0YXRlIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhjZmVmZjI5NDFhODVlMWMyM0Jjb3JlOjpudW06OmZsdDJkZWM6OnN0cmF0ZWd5OjpkcmFnb246Om11bF9wb3cxMDo6aDZjOTVhOGZlZDk0MTM0NWI0QmNvcmU6OmZtdDo6ZmxvYXQ6OmZsb2F0X3RvX2RlY2ltYWxfY29tbW9uX2V4YWN0OjpoYjIzNTBiNzMzNTQ0Mjg0NDVIPGFsbG9jOjp2ZWM6OlZlYzxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6Omg2ZmVmNjQxMjEyZWYwZjc0NlZodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjpuZXdfZm9yX2ZyYWdtZW50OjpoNTY0NGExZDAwMDFkMzk1Mzc6Y29yZTo6bnVtOjpiaWdudW06OkJpZzMyeDQwOjptdWxfZGlnaXRzOjpoMjhiOTVlMjBjMjhmZDg3ODg2c2VyZGVfanNvbjo6c2VyOjpmb3JtYXRfZXNjYXBlZF9zdHI6OmgzOTQxYjkxYjBkNWE2M2M0OTVjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjpoNGU5ZDY3YWVjOGQxMTJlZjq6AWFsbG9jOjpjb2xsZWN0aW9uczo6YnRyZWU6OnNlYXJjaDo6PGltcGwgYWxsb2M6OmNvbGxlY3Rpb25zOjpidHJlZTo6bm9kZTo6Tm9kZVJlZjxCb3Jyb3dUeXBlLEssVixhbGxvYzo6Y29sbGVjdGlvbnM6OmJ0cmVlOjpub2RlOjptYXJrZXI6OkxlYWZPckludGVybmFsPj46OnNlYXJjaF90cmVlOjpoZDVkNDE1M2E1MTUyOWJmMjtlaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6YXBwcm9wcmlhdGVfcGxhY2VfZm9yX2luc2VydGlvbjo6aDYzY2I0NjU3OTBhMWVmMGM8MWNvcmU6OnN0cjo6Y29udmVydHM6OmZyb21fdXRmODo6aGU5NzgyZjlkNDZhZTJlYTY9MmNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbW1vdmU6OmhkYTczNTk2NjZiMTk5YjYyPkpodG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+Ojpwcm9jZXNzX2NoYXJfcmVmOjpoZTU2MTQzNmY0ZTdiNzVmOD9UaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Y2xvc2VfdGhlX2NlbGw6OmgxYjhmZmFkZGUxM2FlOTIxQGNodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjpjcmVhdGVfZm9ybWF0dGluZ19lbGVtZW50X2Zvcjo6aGE1MDE4ODAxMzUxNzM2MmJBXGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnByb2Nlc3NfY2hhcnNfaW5fdGFibGU6Omg5Y2Q5ODUxMmYyMmExNDhlQlRodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojppc190eXBlX2hpZGRlbjo6aGY0ZmVlNzlmMDdlMWVkNjFDaDxjb3JlOjppdGVyOjphZGFwdGVyczo6bWFwOjpNYXA8SSxGPiBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46OmZvbGQ6Omg4Njc1NWM1ZjY4N2Y4NTFhREVjb3JlOjpmbXQ6OmZsb2F0OjpmbG9hdF90b19kZWNpbWFsX2NvbW1vbl9zaG9ydGVzdDo6aGE1MDNkMjcxNGM5MmJlYmRFPmNvcmU6OmZtdDo6Rm9ybWF0dGVyOjp3cml0ZV9mb3JtYXR0ZWRfcGFydHM6Omg3NDExYmYwMzZmN2U5ZDczRlg8YWxsb2M6OnZlYzo6aW50b19pdGVyOjpJbnRvSXRlcjxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6OmhhYjdkZGZkMWJkZjU3YTdmRyNjb3JlOjpmbXQ6OndyaXRlOjpoZWMxNTg4YTJmZWNiMzY3NkgvY29yZTo6c2xpY2U6Om1lbWNocjo6bWVtcmNocjo6aGEyN2FjMDgzZTk2YzU2OTlJWmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnJlc2V0X2luc2VydGlvbl9tb2RlOjpoNGZiYTNhZTQxZWQxOWVjYUpAcGFya2luZ19sb3Q6OnJhd19tdXRleDo6UmF3TXV0ZXg6OnVubG9ja19zbG93OjpoY2MwZWJiNmE4NmJkNTg5MUs8Y29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZF9mb3JtYXR0ZWRfcGFydHM6OmhlYzk2ZTdiYmUyMTExNTNkTEF0ZW5kcmlsOjp0ZW5kcmlsOjpUZW5kcmlsPEYsQT46OnBvcF9mcm9udF9jaGFyOjpoZWNmZmJmMDQwOTY5YTMyZE1IPGFsbG9jOjp2ZWM6OlZlYzxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6OmgxNzFkOTM0ZmQyZjdiYzhlTlRjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8W2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0eXBlczo6VG9rZW5dPjo6aDU3OTZjODdmZWE5M2EyNjFPbWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnVuZXhwZWN0ZWRfc3RhcnRfdGFnX2luX2ZvcmVpZ25fY29udGVudDo6aDNhYjdhZWNiZGFmZTE3ZjRQYzxhbGxvYzo6dmVjOjpWZWM8VD4gYXMgYWxsb2M6OnZlYzo6c3BlY19mcm9tX2l0ZXI6OlNwZWNGcm9tSXRlcjxULEk+Pjo6ZnJvbV9pdGVyOjpoODlhNGRmMTNlNGMzZGM4NlFvPGNvcmU6OnJjZG9tOjpSY0RvbSBhcyBtYXJrdXA1ZXZlcjo6aW50ZXJmYWNlOjp0cmVlX2J1aWxkZXI6OlRyZWVTaW5rPjo6YWRkX2F0dHJzX2lmX21pc3Npbmc6OmhiOWQ2MDQ4MTI2NDljN2QxUkFkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjpkaXNwb3NlX2NodW5rOjpoOTFhZmE5ODI4ZDU0NWNkZFNBcGFya2luZ19sb3RfY29yZTo6cGFya2luZ19sb3Q6OlRocmVhZERhdGE6Om5ldzo6aDYwYTU3YjE2ZjM4NDEyZGNURjxhbGxvYzo6dmVjOjpWZWM8VCxBPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aGQzMjBlMzkyZmMyZWRkNjhVRjxhbGxvYzo6dmVjOjpWZWM8VCxBPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDYzNWFlNWY1NzgzMzdjYWVWUmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dHlwZXM6OlRva2VuPjo6aDgzYjg3MDNlYjI1YmVjOTNXTmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxtYXJrdXA1ZXZlcjo6aW50ZXJmYWNlOjpBdHRyaWJ1dGU+OjpoZDg1OWQ3NzE5YWI1NWUwMlhUaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5fc2NvcGVfbmFtZWQ6OmgyZTMxNWY4OTllYzhmYjI2WTRodG1sNWV2ZXI6OnRva2VuaXplcjo6b3B0aW9uX3B1c2g6OmgwNWNlYjI2ZDNhNTZkOTA0WjtoYXNoYnJvd246Om1hcDo6SGFzaE1hcDxLLFYsUyxBPjo6aW5zZXJ0OjpoMTI1NjNlNjg4MWE4ZWQxM1tuPGFsbG9jOjpjb2xsZWN0aW9uczo6YnRyZWU6Om1hcDo6SXRlcjxLLFY+IGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yPjo6bmV4dDo6aGQxYzYxZDYyMjc0MThmMTlcTDxzdGQ6OmlvOjpzdGRpbzo6U3Rkb3V0TG9jayBhcyBzdGQ6OmlvOjpXcml0ZT46OndyaXRlX2FsbDo6aDQ4YzdmMjcxM2Q2YTUxNjhdYTxjb3JlOjpyY2RvbTo6UmNEb20gYXMgbWFya3VwNWV2ZXI6OmludGVyZmFjZTo6dHJlZV9idWlsZGVyOjpUcmVlU2luaz46OmFwcGVuZDo6aDgwNDNkMjYyYjNjNTE0ZjNeMGNvcmU6Omhhc2g6Okhhc2hlcjo6d3JpdGVfdTMyOjpoYjk0MjVhMDRmOWJlOTA5ZV9faHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6YWRqdXN0X2ZvcmVpZ25fYXR0cmlidXRlczo6aGE1ZWI1ZTNiMDg3NDg4NWVgP2NvcmU6OnNsaWNlOjpzb3J0OjppbnNlcnRpb25fc29ydF9zaGlmdF9sZWZ0OjpoMTg1YWVkYmY2YTQ4ODM3Y2E5c3RyaW5nX2NhY2hlOjpkeW5hbWljX3NldDo6U2V0OjppbnNlcnQ6OmhiM2M0OTA0MDE2MjE4YjI4YjNhbGxvYzo6Zm10Ojpmb3JtYXQ6OmZvcm1hdF9pbm5lcjo6aGVhZWMzOGJjZDcyZmMzM2FjbDxjb3JlOjpyY2RvbTo6UmNEb20gYXMgbWFya3VwNWV2ZXI6OmludGVyZmFjZTo6dHJlZV9idWlsZGVyOjpUcmVlU2luaz46OnJlcGFyZW50X2NoaWxkcmVuOjpoZjk3NTk2YTQ2MDA4ZDhhOWRVY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGh0bWw1ZXZlcjo6dG9rZW5pemVyOjppbnRlcmZhY2U6OkRvY3R5cGU+OjpoYTk2ZjFmZDE1MzgzZWFkZGVCc3RkOjppbzo6c3RkaW86OnByaW50X3RvX2J1ZmZlcl9pZl9jYXB0dXJlX3VzZWQ6OmgxMTM1NDQ3ZjViN2Y2OTExZlw8c3RkOjpjb2xsZWN0aW9uczo6aGFzaDo6bWFwOjpEZWZhdWx0SGFzaGVyIGFzIGNvcmU6Omhhc2g6Okhhc2hlcj46OndyaXRlOjpoYTA0NzdhYTZmZDUyYTg5YWdUaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5fc2NvcGVfbmFtZWQ6OmgzNTFhYjY1OTVlNTU2MWRlaFRodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojppbl9zY29wZV9uYW1lZDo6aDgzMjgyZTdmYmZlMmIxOWZpSWh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OnBvcF9leGNlcHRfZnJvbTo6aGJkZjE1MmJiMWQ0ZWQwNDNqQHBhcmtpbmdfbG90X2NvcmU6OnBhcmtpbmdfbG90OjpIYXNoVGFibGU6Om5ldzo6aDYzY2I3MTgzNzBhZWIwYWZrNGNvcmU6Omhhc2g6OkJ1aWxkSGFzaGVyOjpoYXNoX29uZTo6aDY4ZTAyN2I0MDZmMTViYmZsOGhhc2hicm93bjo6cmF3OjpSYXdUYWJsZTxULEE+OjppbnNlcnQ6OmhkMGJkNjY5YjYwYjgxODZhbTZoYXNoYnJvd246OnJhdzo6UmF3VGFibGU8VCxBPjo6ZmluZDo6aGRhNGQ0ZTY3MGMxYzVlYjBuaDxhbGxvYzo6c3RyaW5nOjpTdHJpbmcgYXMgY29yZTo6aXRlcjo6dHJhaXRzOjpjb2xsZWN0OjpGcm9tSXRlcmF0b3I8Y2hhcj4+Ojpmcm9tX2l0ZXI6OmgwODUyMmYwZmYxMWI5MWVlb2g8YWxsb2M6OnN0cmluZzo6U3RyaW5nIGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6Y29sbGVjdDo6RnJvbUl0ZXJhdG9yPGNoYXI+Pjo6ZnJvbV9pdGVyOjpoNWEzOTBlOTZiYmZlMWJjNXBhaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Z2VuZXJhdGVfaW1wbGllZF9lbmRfZXhjZXB0OjpoMjY0NTU1YWY0MjVjMDk1ZnFJc3RyaW5nX2NhY2hlOjphdG9tOjpBdG9tPFN0YXRpYz46OmVxX2lnbm9yZV9hc2NpaV9jYXNlOjpoYzNhNzdkZTIzZDc4ODI5M3JDdGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDxGLEE+Ojp1bnNhZmVfcG9wX2Zyb250OjpoNjQ0NzY2MTU3NjU2MzRjY3NDdGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDxGLEE+Ojp1bnNhZmVfcG9wX2Zyb250OjpoOWNlOWNiZDFjNzZmZWY1ZXQ3Y29yZTo6cGFuaWNraW5nOjphc3NlcnRfZmFpbGVkX2lubmVyOjpoMmFhNWU4ZTdmZTIwMWM2ZXVQaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6dW5leHBlY3RlZDo6aGY1OGZjMDJmMzI1ZmRjNDJ2UGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnVuZXhwZWN0ZWQ6OmhiYjA0MjAzY2Y2OWRjYzk1d1VodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjpleHBlY3RfdG9fY2xvc2U6OmgxYjkzMGM4MmQyNWIxOWYweDBkbG1hbGxvYzo6RGxtYWxsb2M8QT46Om1hbGxvYzo6aDc4ZDRiNGQ4YzEzYWJiNDJ5T2h0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OmdldF9wcmVwcm9jZXNzZWRfY2hhcjo6aGUzNDlmN2M4ZmU1ZWQyOTJ6STwmc3RkOjppbzo6c3RkaW86OlN0ZG91dCBhcyBzdGQ6OmlvOjpXcml0ZT46OndyaXRlX2ZtdDo6aDZmZjY5ODMyNDkxOTQ1ZDB7WGNvcmU6Om51bTo6Zmx0MmRlYzo6c3RyYXRlZ3k6OmdyaXN1Ojpmb3JtYXRfZXhhY3Rfb3B0Ojpwb3NzaWJseV9yb3VuZDo6aGUxNWFlYjMyNTdhMjNjMDV8MjxjaGFyIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgyNjVmYzI1OWJjZmQ2ZWJmfVNodG1sNWV2ZXI6OnRva2VuaXplcjo6Y2hhcl9yZWY6OkNoYXJSZWZUb2tlbml6ZXI6OmZpbmlzaF9udW1lcmljOjpoZTEwYjU2NjczYTc2MjU3Zn5TPGNvcmU6OmZtdDo6YnVpbGRlcnM6OlBhZEFkYXB0ZXIgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDM0M2ExNzNhODBhZmExMjl/RTxzdGQ6OmlvOjplcnJvcjo6RXJyb3IgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoNDJjODEzMDdjODEzYTYxY4ABSmFsbG9jOjpjb2xsZWN0aW9uczo6YnRyZWU6Om1hcDo6QlRyZWVNYXA8SyxWLEE+OjppbnNlcnQ6OmhjM2ZkNWI5MjljYTZmNzBkgQE4Y29yZTo6bnVtOjpmbHQyZGVjOjpkaWdpdHNfdG9fZGVjX3N0cjo6aGU0MmM3Y2EyYjhjMzE0NziCAVJjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8KG1hcmt1cDVldmVyOjppbnRlcmZhY2U6OlF1YWxOYW1lLCgpKT46Omg4YzcyNDQzZjVhODhkNDMzgwFNY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPG1hcmt1cDVldmVyOjppbnRlcmZhY2U6OlF1YWxOYW1lPjo6aGEwMzI3YTEzNzY3NTUwNziEAU1jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8bWFya3VwNWV2ZXI6OmludGVyZmFjZTo6UXVhbE5hbWU+OjpoMTc3ZDM4MzUyNTgxMWJhZIUBI2NvcmU6OnBhcnNlX2ZyYWc6OmhkOGFhMWVhZGIxNzBlNjg0hgFWaHRtbDVldmVyOjp0b2tlbml6ZXI6OmNoYXJfcmVmOjpDaGFyUmVmVG9rZW5pemVyOjp1bmNvbnN1bWVfbnVtZXJpYzo6aDA2YjZkM2I3YmQzYWI2MTWHAVFjb3JlOjpzbGljZTo6Y21wOjo8aW1wbCBjb3JlOjpjbXA6OlBhcnRpYWxFcTxbQl0+IGZvciBbQV0+OjplcTo6aGY5ZWY1ODc5ZGIzZjA2NGOIATJjb3JlOjp1bmljb2RlOjpwcmludGFibGU6OmNoZWNrOjpoZmJmY2VkMjY4MmM0YjlhNIkBZ3N0ZDo6aW86OmVycm9yOjo8aW1wbCBjb3JlOjpmbXQ6OkRlYnVnIGZvciBzdGQ6OmlvOjplcnJvcjo6cmVwcl91bnBhY2tlZDo6UmVwcj46OmZtdDo6aDY4YjU3ODJiMGVlMTdkNWGKATA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGU1MjcyNDdlZjk0OGRkMDmLATA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGU5MjlhYjM0OWQxNjE0ZTWMAUdjb3JlOjp1bmljb2RlOjp1bmljb2RlX2RhdGE6OmdyYXBoZW1lX2V4dGVuZDo6bG9va3VwOjpoNTUyNTgxZmE5ZDI1ZDIyOI0BPWh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46Om5ldzo6aDY4MDczNGY3OWZlYzc1ZWWOATpjb3JlOjpmbXQ6OmJ1aWxkZXJzOjpEZWJ1Z1N0cnVjdDo6ZmllbGQ6OmgyMzM1NDI0MTM4YzUwNDVkjwE9aHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6ZWF0OjpoNGEzMjFlYTgxMzRlMWVhNJABVGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmNoZWNrX2JvZHlfZW5kOjpoYWFmNmM5NjU3NDcxYjU5OJEBL2NvcmU6OmZtdDo6V3JpdGU6OndyaXRlX2NoYXI6OmhhNTExODMzYTJkYTNlMmU3kgFnaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Y2xlYXJfYWN0aXZlX2Zvcm1hdHRpbmdfdG9fbWFya2VyOjpoYzk5NGNhMWU4ZmUxYzM0M5MBaGNvcmU6Om9wczo6ZnVuY3Rpb246OmltcGxzOjo8aW1wbCBjb3JlOjpvcHM6OmZ1bmN0aW9uOjpGbk11dDxBPiBmb3IgJm11dCBGPjo6Y2FsbF9tdXQ6OmhhNjU4ZjAwYWM3ODYyYzg5lAE7PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfY2hhcjo6aDQ3MTQ2OTM5M2QxMWIwNTeVATs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoZGVlYzA2YTA2MWNhZDU3NpYBNGh0bWw1ZXZlcjo6ZHJpdmVyOjpwYXJzZV9kb2N1bWVudDo6aGIzZTZkODY0MTk1ODZiY2KXAR5jb3JlOjpwYXJzZTo6aDkyMGE2MDY3M2E3ODlhYzSYAUo8YWxsb2M6OnN0cmluZzo6U3RyaW5nIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoZDY3YzMyNWM1ZTQyYmYyZZkBLmFsbG9jOjpzdHJpbmc6OlN0cmluZzo6cHVzaDo6aDgyMzliNzU5YzE2NzdmMGWaAVVodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojpwb3BfdW50aWxfbmFtZWQ6OmhlZWU3Zjg2MmVmNjE1MzE5mwExY29tcGlsZXJfYnVpbHRpbnM6Om1lbTo6bWVtY3B5OjpoY2JiOTljZTc5NTdmOGYyOZwBM3N0ZDo6c3lzOjp3YXNtOjpvbmNlOjpPbmNlOjpjYWxsOjpoMzM5YTUwOGY5YjkxN2QwZZ0BL2NvcmU6OmZtdDo6bnVtOjppbXA6OmZtdF91NjQ6Omg0ZWZkZmUyZTI5MTBjOGJhngEKcGFyc2VfZnJhZ58BPmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjphbnlfbm90X3doaXRlc3BhY2U6OmgxZTk2ZjQxNmE3NjAwN2RjoAFGY29yZTo6Zm10OjpudW06OjxpbXBsIGNvcmU6OmZtdDo6RGVidWcgZm9yIHU4Pjo6Zm10OjpoNDBhYTg5NGJjMjM2YjQxZKEBR2NvcmU6OmZtdDo6bnVtOjo8aW1wbCBjb3JlOjpmbXQ6OkRlYnVnIGZvciB1NjQ+OjpmbXQ6OmhjYTg3YmRhZmRmYzRmMDc3ogE2Y29yZTo6c2xpY2U6Om1lbWNocjo6bWVtY2hyX2FsaWduZWQ6Omg5NmFkNzZjZmUxYjI4ZDBmowFHY29yZTo6Zm10OjpudW06OjxpbXBsIGNvcmU6OmZtdDo6RGVidWcgZm9yIHUzMj46OmZtdDo6aDAwNGViZjA2YmMwODhjMDekAUVtYXJrdXA1ZXZlcjo6dXRpbDo6YnVmZmVyX3F1ZXVlOjpCdWZmZXJRdWV1ZTo6bmV4dDo6aGIxYWZjZmEyYTQxMjRkOTmlAUNodG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+OjplbWl0X2NoYXI6Omg1ODJhNzNiZGNjNDMwMjZmpgE0Y29yZTo6cmNkb206OmdldF9wYXJlbnRfYW5kX2luZGV4OjpoMmY0MTU5MjQ4MWExMWNlNqcBRmRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OnVubGlua19sYXJnZV9jaHVuazo6aGE5ZjI5N2ExMzNhZTBhMTmoASlzdGQ6OmlvOjpzdGRpbzo6X3ByaW50OjpoZTZlZGE1ZjEwZGQwMDlkNakBPWh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OnJ1bjo6aDA3ZWU2MDJhOTY1ODNkM2aqAVI8bWFya3VwNWV2ZXI6OmludGVyZmFjZTo6RXhwYW5kZWROYW1lIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg2MjRjYjA0OTFhZDkwZWE3qwE5Y29yZTo6Zm10OjpidWlsZGVyczo6RGVidWdUdXBsZTo6ZmllbGQ6OmgxNDFhODkyNjJjMTVlZjJlrAE7PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfY2hhcjo6aGY3MWIyMDI3NjViM2M5MjStAUZkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjppbnNlcnRfbGFyZ2VfY2h1bms6Omg0ZDAzNGUxNGIyYTQ4MDJmrgEvY29yZTo6Zm10OjpXcml0ZTo6d3JpdGVfY2hhcjo6aDcwMDY1NTE1MTdjNTAwYTmvAS9jb3JlOjpmbXQ6OldyaXRlOjp3cml0ZV9jaGFyOjpoYThlZTY4YTM1OTkyMTUxNbABRW1hcmt1cDVldmVyOjp1dGlsOjpidWZmZXJfcXVldWU6OkJ1ZmZlclF1ZXVlOjpwZWVrOjpoMjBmMjViNjYwOWI0MDcwNLEBQmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0YWdfc2V0czo6YnV0dG9uX3Njb3BlOjpoMDI5MGY1NDMyMjU4MTgyNrIBS21hcmt1cDVldmVyOjp1dGlsOjpidWZmZXJfcXVldWU6OkJ1ZmZlclF1ZXVlOjpwdXNoX2Zyb250OjpoYmYzNDNjZWNlMGRlNDBlYbMBS2RsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OnJlbGVhc2VfdW51c2VkX3NlZ21lbnRzOjpoMTFkZjgyNDExNWM4ZmEwMLQBOWNvcmU6OmZtdDo6YnVpbGRlcnM6OkRlYnVnSW5uZXI6OmVudHJ5OjpoYTY5N2MxMzdlMzA5ZmM3YrUBNDxjaGFyIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGM5NTZiZTc1OGI5Y2FkZDm2AUw8c2VyZGVfanNvbjo6ZXJyb3I6OkVycm9yQ29kZSBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6Omg5MWY5MDZjMDQ2NTI0OWM5twFKbWFya3VwNWV2ZXI6OnV0aWw6OmJ1ZmZlcl9xdWV1ZTo6QnVmZmVyUXVldWU6OnB1c2hfYmFjazo6aGNkNTliMmNiNmI5MDRiOWK4AUVodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6Omxpc3RfaXRlbV9zY29wZTo6aGI3ODYwZDBmZDEwMmE0N2G5AWZodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojp0b2tlbml6ZXJfc3RhdGVfZm9yX2NvbnRleHRfZWxlbTo6aDU5ZTU3Njk0NzU5MDEwYze6ATJjb3JlOjpyY2RvbTo6cmVtb3ZlX2Zyb21fcGFyZW50OjpoMGQwMDI4ZGMxMmI1ZWNjZbsBNGh0bWw1ZXZlcjo6ZHJpdmVyOjpwYXJzZV9mcmFnbWVudDo6aDkwZjBhNDcyMTc1NWQ4ODS8AUpodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6OnRob3JvdWdoX2ltcGxpZWRfZW5kOjpoMGM3Y2IwNzgxMDFmN2U5Yb0BU2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmVudGVyX2ZvcmVpZ246Omg2ZjcwZjFiYjQ2ZGMyNjY4vgFEaHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6Y3JlYXRlX3RhZzo6aGM3OGNjNzRhMmVhY2Q0YzG/AT9jb3JlOjpzbGljZTo6c29ydDo6aW5zZXJ0aW9uX3NvcnRfc2hpZnRfbGVmdDo6aGJiYzkzMTk1Y2Y0NWUwNjbAAUVwYXJraW5nX2xvdF9jb3JlOjp3b3JkX2xvY2s6OldvcmRMb2NrOjp1bmxvY2tfc2xvdzo6aDk5ZmE5ODQ5OGYzYWVlODjBATs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoMTI2YjNlNDk3OTkxYjFhMsIBXmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmFkanVzdF9tYXRobWxfYXR0cmlidXRlczo6aGJiZDJlMzhhZTVhMjliMDjDAUpodG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+Ojpjb25zdW1lX2NoYXJfcmVmOjpoZmYwODI0YTQ5OTAzM2I5Y8QBSmh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OmNyZWF0ZV9hdHRyaWJ1dGU6Omg5NTMwMzAxMDc5MTE2NjlhxQFFaHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6ZGlzY2FyZF90YWc6Omg2MzRkZDBjZWExMjgwZTU1xgEvY29yZTo6Zm10OjpXcml0ZTo6d3JpdGVfY2hhcjo6aDQwY2U3YjFjYmRhYTlkZGXHAVg8YWxsb2M6OnZlYzo6aW50b19pdGVyOjpJbnRvSXRlcjxULEE+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6Omg1ZDUwMzhiMGY3MjRmOWVhyAFhaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Y2hlY2tfYm9keV9lbmQ6OmJvZHlfZW5kX29rOjpoMDMyNTY1NGMwY2U5YzdmYskBOWNvcmU6OnVuaWNvZGU6OnByaW50YWJsZTo6aXNfcHJpbnRhYmxlOjpoNTMwZTk2YzI4Y2E2Yjg2McoBMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYmI4OTcyMWJkNGM0OTMxNMsBTmh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OmVtaXRfY3VycmVudF9kb2N0eXBlOjpoNmI4ODAzNTZjMWU0MDhiOMwBRjxzZXJkZV9qc29uOjplcnJvcjo6RXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDY3MjFkYTE4NTg1YmQ4ZmXNAVRodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojppbl9zY29wZV9uYW1lZDo6aDAwZDk3Y2E3YWNhNjlkNmTOAVRodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojppbl9zY29wZV9uYW1lZDo6aDFlNmViNDc2Yjk0Nzc4MTLPAU5odG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojppbl9zY29wZTo6aDQ2ZmE1YTNhYTQyZGE0ODnQAQVwYXJzZdEBJmNvcmU6OmRvbV90b19zdHJpbmc6Omg5YzlmNTA0NjUzYWZjMjcx0gFIaHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6YmFkX2NoYXJfZXJyb3I6OmhjNjgxYjRiODRhNjQwMmRj0wFPPG1hcmt1cDVldmVyOjppbnRlcmZhY2U6OlF1YWxOYW1lIGFzIGNvcmU6Omhhc2g6Okhhc2g+OjpoYXNoOjpoNmY0MDU1M2I2OWE5ZGEyNdQBM2luc3RhbnQ6Ondhc206OmR1cmF0aW9uX2Zyb21fZjY0OjpoMDk5OGQzMmRlYmVmZjA5ZdUBN2NvcmU6OmNoYXI6Om1ldGhvZHM6OmVuY29kZV91dGY4X3Jhdzo6aDI4NWYxMmFmNDBlMDRjY2LWAVBodG1sNWV2ZXI6OnRva2VuaXplcjo6Y2hhcl9yZWY6OkNoYXJSZWZUb2tlbml6ZXI6OmVuZF9vZl9maWxlOjpoODQwMjQwODI2Mzg4NmZjZdcBTmFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZTo6ZG9fcmVzZXJ2ZV9hbmRfaGFuZGxlOjpoOGQzNWIzMjdmYTk1YTg3YtgBTmFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZTo6ZG9fcmVzZXJ2ZV9hbmRfaGFuZGxlOjpoOTBiMWEyN2RhNzkwMDQ0MNkBTmFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZTo6ZG9fcmVzZXJ2ZV9hbmRfaGFuZGxlOjpoOWIwMmIzMTQzZjFlYTliM9oBTmFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZTo6ZG9fcmVzZXJ2ZV9hbmRfaGFuZGxlOjpoZWQzNTg5NmE4YTQ5ZWRkY9sBTmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmluX3Njb3BlOjpoNWRhNDg0MDQyMWU0MzViY9wBTmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmluX3Njb3BlOjpoNjdkNzhmMzA3YzcwYWUxNt0BaDxjb3JlOjppdGVyOjphZGFwdGVyczo6bWFwOjpNYXA8SSxGPiBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46OmZvbGQ6OmgyMzY0NGM3M2M0MTYxMGFl3gFAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoMDdlN2MxZjhlMGIwMTczNN8BQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDVjMDA1Y2Y1MjQ4ZjYxNTjgAUBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6Omg4YjM5ZDI3NDRhZGUwN2E44QFAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoYWNlZWMwZWU3OWYxNWRjN+IBQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aGRkY2QxNGJkNjcxNGY3ZDHjAUBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6OmhhMWYxNjkxOTJkNGJmZDc25AFAYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlX2Zvcl9wdXNoOjpoOTc4ZjE5NmI5NmRkYjljMeUBfHN0cmluZ19jYWNoZTo6dHJpdmlhbF9pbXBsczo6PGltcGwgc2VyZGU6OnNlcjo6U2VyaWFsaXplIGZvciBzdHJpbmdfY2FjaGU6OmF0b206OkF0b208U3RhdGljPj46OnNlcmlhbGl6ZTo6aDFlOThhZWExYTBjNTZjODLmAVFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8aHRtbDVldmVyOjp0b2tlbml6ZXI6OmludGVyZmFjZTo6VGFnPjo6aDQ0ZGJkYmZjZmI2NWVmZjTnAVRodG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+Ojpwcm9jZXNzX3Rva2VuX2FuZF9jb250aW51ZTo6aGY1M2NlYmIwMWI1MWI3MGPoAUpodG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+OjpjbGVhcl9kb2N0eXBlX2lkOjpoOTVkY2U5YmRiMmQzYzEyOOkBJmNvcmU6OnJjZG9tOjphcHBlbmQ6OmhkYjdmZWExNmMwOTgwZDBm6gFOYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlOjpkb19yZXNlcnZlX2FuZF9oYW5kbGU6OmhkYWEwMDY3MDJhYmQ5YWNh6wFOYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlOjpkb19yZXNlcnZlX2FuZF9oYW5kbGU6Omg5Yzc0NDMyNGE4Mzk2ZmI07AFOYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlOjpkb19yZXNlcnZlX2FuZF9oYW5kbGU6OmgyYzMwYTlmZTg5ZTE2NWRl7QFOYWxsb2M6OnJhd192ZWM6OlJhd1ZlYzxULEE+OjpyZXNlcnZlOjpkb19yZXNlcnZlX2FuZF9oYW5kbGU6OmhhM2Y5ZDNkZmIxMDU5NGEy7gFDY29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3N0cnVjdF9maWVsZDRfZmluaXNoOjpoZTQ5ODAyZTNjMGQ5NGEyNu8BQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDFiOTcwODY3OTJiZGEzMjbwAUBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6OmgwMWVjYWEyNGE1Nzc5Zjhj8QFPaHRtbDVldmVyOjp0b2tlbml6ZXI6OmNoYXJfcmVmOjpDaGFyUmVmVG9rZW5pemVyOjpnZXRfcmVzdWx0OjpoMzIwYzkzN2YzYjFhOTkyMvIBQGFsbG9jOjpyYXdfdmVjOjpSYXdWZWM8VCxBPjo6cmVzZXJ2ZV9mb3JfcHVzaDo6aDkwZGU4ZGU2YTk0NWYyMmPzAUBhbGxvYzo6cmF3X3ZlYzo6UmF3VmVjPFQsQT46OnJlc2VydmVfZm9yX3B1c2g6Omg5NTUxYWNkMDdjZmRmZGEx9AFCY29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3R1cGxlX2ZpZWxkMl9maW5pc2g6OmhmOThkZGUxMTU2ZTlhZTRm9QF8Y29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0eXBlczo6UHJvY2Vzc1Jlc3VsdDxhbGxvYzo6cmM6OlJjPGNvcmU6OnJjZG9tOjpOb2RlPj4+OjpoYmQ3Y2JjODZmNzkzZDQwNvYBUGh0bWw1ZXZlcjo6dG9rZW5pemVyOjppbnRlcmZhY2U6OlRhZzo6ZXF1aXZfbW9kdWxvX2F0dHJfb3JkZXI6OmhiN2ZhNDg5NmMzZWVhN2Q19wEzc3RkOjpzeXM6Ondhc206Om9uY2U6Ok9uY2U6OmNhbGw6OmhjZmJkMGEyNDdkYzg4NjZi+AFoPHN0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19oYW5kbGVyOjpQYW5pY1BheWxvYWQgYXMgY29yZTo6cGFuaWM6OkJveE1lVXA+Ojp0YWtlX2JveDo6aDRjNTM2MTcwYzdkNTZlNGL5ATdzdGQ6OnBhbmlja2luZzo6cnVzdF9wYW5pY193aXRoX2hvb2s6Omg4NWI3ZjY2MjhjMjkxZTEy+gFJPGNvcmU6OnN0cjo6ZXJyb3I6OlV0ZjhFcnJvciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoODQxMjgxOWE0MzdlOGVkY/sBRDxhbGxvYzo6cmM6OlJjPFQ+IGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6Omg5MGY3MGRmOGI5ZWRmMTE1/AFOaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5fc2NvcGU6OmhiY2E2ZmFjM2ViMzE0YTk3/QFCY29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3R1cGxlX2ZpZWxkMV9maW5pc2g6Omg1ZjRjYWEwN2Y0NjY4NmY2/gEuYWxsb2M6OnJhd192ZWM6OmZpbmlzaF9ncm93OjpoZjYxMGJkZjcyNDU2YmNkMf8BQ2NvcmU6OmZtdDo6Rm9ybWF0dGVyOjpkZWJ1Z19zdHJ1Y3RfZmllbGQzX2ZpbmlzaDo6aDUxNzViZDY0MGNjMGJjNzeAAmVodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjpjbG9zZV9wX2VsZW1lbnRfaW5fYnV0dG9uX3Njb3BlOjpoNWM5Mjc4NThlYzcxZWVmNIECV2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnBvcF91bnRpbF9jdXJyZW50OjpoMDc2N2FlMzMwYTZjYmIyMYICV2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnBvcF91bnRpbF9jdXJyZW50OjpoODA4YjVkOWY4OGNkZTRkZoMCV2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnBvcF91bnRpbF9jdXJyZW50OjpoZjZmZTc2OGE3OTRkYzFlMoQCVWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46Omh0bWxfZWxlbV9uYW1lZDo6aDQ4NGVjMDFmNzQ5MzcwNGKFAlxodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjphcHBlbmRfY29tbWVudF90b19odG1sOjpoZTVlZDhkMjUzMGMxNDY2MoYCMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYThmMzAwMzdhN2UyY2JhNIcCMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZTJlYTdjMzk1NjhkZjllZYgCMWNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbXNldDo6aGVkZjJkZGRjMTlmYTI5NDOJAk48c3RyaW5nX2NhY2hlOjphdG9tOjpBdG9tPFN0YXRpYz4gYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDYzNjNmN2YzYTAyYjFlMzGKAk48c3RyaW5nX2NhY2hlOjphdG9tOjpBdG9tPFN0YXRpYz4gYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDQ4MTNjNjgyODEwM2IyMTGLAilsb2c6Ol9fcHJpdmF0ZV9hcGlfbG9nOjpoZjNkY2NmMDBlNDY3MDk4MowCTjxzdHJpbmdfY2FjaGU6OmF0b206OkF0b208U3RhdGljPiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNGViMTY0Y2MwZjlhODEzNY0CXDxjb3JlOjpjaGFyOjpFc2NhcGVEZWJ1ZyBhcyBjb3JlOjppdGVyOjp0cmFpdHM6Oml0ZXJhdG9yOjpJdGVyYXRvcj46Om5leHQ6OmgwYzczODZmZjU2NDQyNDM3jgJDY29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3N0cnVjdF9maWVsZDJfZmluaXNoOjpoZjg0NDAxZjk5NzdiYmY5NY8CUWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmNyZWF0ZV9yb290OjpoMDMyNjVjNzBhM2VjNWFhY5ACRzxjb3JlOjp0aW1lOjpEdXJhdGlvbiBhcyBjb3JlOjpvcHM6OmFyaXRoOjpBZGQ+OjphZGQ6OmhmYzU4MzcyN2FiZmUyZDQ4kQJPaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5zZXJ0X2F0OjpoZTUwN2RiMzM4OGYzNzExNJICVWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmNsb3NlX3BfZWxlbWVudDo6aGJlOWJkOGZkZGVhYmI4ZjiTAi5hbGxvYzo6cmF3X3ZlYzo6ZmluaXNoX2dyb3c6OmhkYjk0MzQwOGJjOTkzMDY2lAIuYWxsb2M6OnJhd192ZWM6OmZpbmlzaF9ncm93OjpoNGUwNzkyZTg0YTc3YjA3MZUCLmFsbG9jOjpyYXdfdmVjOjpmaW5pc2hfZ3Jvdzo6aGRiNDQ0MGZiZjYxOGI5MziWAi5hbGxvYzo6cmF3X3ZlYzo6ZmluaXNoX2dyb3c6OmhmZDAxZjYzZGQ2YzNjMzA5lwIuYWxsb2M6OnJhd192ZWM6OmZpbmlzaF9ncm93OjpoYzMzYmM0ZjEzM2QxNmI5NpgCLmFsbG9jOjpyYXdfdmVjOjpmaW5pc2hfZ3Jvdzo6aGIxZGM4ZWViNjRhY2ZlOGWZAlM8aHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OnR5cGVzOjpUb2tlbiBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNzdmOGQxNTIxODg4YTA1Y5oCWmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmdlbmVyYXRlX2ltcGxpZWRfZW5kOjpoOTA1ZDQzMDA2NThiZWY5YZsCWmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmdlbmVyYXRlX2ltcGxpZWRfZW5kOjpoYzU5OTY0N2YzOTk0OTYyNJwCRjxjb3JlOjpvcHRpb246Ok9wdGlvbjxUPiBhcyBjb3JlOjpoYXNoOjpIYXNoPjo6aGFzaDo6aGJkYjc1ODhkOTczOTM0YmKdAl5odG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjpjbG9zZV9wX2VsZW1lbnQ6OmltcGxpZWQ6OmhiNDljNjE2MzQ4ZDE3MGI3ngJPaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6cG9wX3VudGlsOjpoODhmMWU1NTc3ZGE5NzVmMp8CVGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmFwcGVuZF9jb21tZW50OjpoN2Q2MWMyMjE1MTZkOWJiM6ACRWFsbG9jOjpjb2xsZWN0aW9uczo6dmVjX2RlcXVlOjpWZWNEZXF1ZTxULEE+Ojpncm93OjpoZDBkNmQ1NjQ0NTMwMjA4OaECRWFsbG9jOjpjb2xsZWN0aW9uczo6dmVjX2RlcXVlOjpWZWNEZXF1ZTxULEE+Ojpncm93OjpoODRmZTk0NzU0MzgyZjE0NqICQ3BhcmtpbmdfbG90X2NvcmU6OndvcmRfbG9jazo6V29yZExvY2s6OmxvY2tfc2xvdzo6aGRkM2ZjYjYxNjYyMGJhNTmjAi9hbGxvYzo6dmVjOjpWZWM8VCxBPjo6aW5zZXJ0OjpoNzJmMjA2MjJlNzVlMjdmN6QCV2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnJlbW92ZV9mcm9tX3N0YWNrOjpoMTYxZGE2N2MxMTcyMzY2OaUCcGNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxjb3JlOjpvcHRpb246Ok9wdGlvbjx0ZW5kcmlsOjp0ZW5kcmlsOjpUZW5kcmlsPHRlbmRyaWw6OmZtdDo6VVRGOD4+Pjo6aGRkYTFhZjkwZDYxMmQzNDKmAltodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+OjphcHBlbmRfY29tbWVudF90b19kb2M6Omg3MjJmNDljMGJlNTZiMzQ2pwI6Y29yZTo6Zm10OjpidWlsZGVyczo6RGVidWdUdXBsZTo6ZmluaXNoOjpoYTQxZDNiNjFiODlmNTQxN6gCSWNvcmU6OmZtdDo6bnVtOjo8aW1wbCBjb3JlOjpmbXQ6OlVwcGVySGV4IGZvciBpOD46OmZtdDo6aGFlZDliMTQ3MjA0YmYwNjGpAkljb3JlOjpmbXQ6Om51bTo6PGltcGwgY29yZTo6Zm10OjpMb3dlckhleCBmb3IgaTg+OjpmbXQ6OmhhYjljMWY5YzNmYWZlZGViqgIyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDI4Yzg4NTJiM2Q1N2M1YTOrAlpjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8dGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDx0ZW5kcmlsOjpmbXQ6OlVURjg+Pjo6aDhhYjZhOTY0YzhjYzM4ZTOsAlpjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8dGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDx0ZW5kcmlsOjpmbXQ6OlVURjg+Pjo6aDhhYjZhOTY0YzhjYzM4ZTOtAlpjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8dGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDx0ZW5kcmlsOjpmbXQ6OlVURjg+Pjo6aDhhYjZhOTY0YzhjYzM4ZTOuAjI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoMGE3ZmQ2ZmYyMWE5NTYwM68CQ3N0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19oYW5kbGVyOjp7e2Nsb3N1cmV9fTo6aDFlMTdiYWQwNGE1NzEzYTSwAkpjb3JlOjpmbXQ6Om51bTo6PGltcGwgY29yZTo6Zm10OjpMb3dlckhleCBmb3IgaTMyPjo6Zm10OjpoMDUyYjBjNGFiZDAwYTg0OLECSmNvcmU6OmZtdDo6bnVtOjo8aW1wbCBjb3JlOjpmbXQ6OlVwcGVySGV4IGZvciBpMzI+OjpmbXQ6Omg3MGUwZTgyMjU0ZGZjMDdjsgJIaHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplcjxTaW5rPjo6Y2xlYXJfdGVtcF9idWY6OmhlODRkZTEzZGE3ZGNhMDVmswJcaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5zZXJ0X2VsZW1lbnQ6Omxpc3RlZDo6aDE2ZjJiNWEzZWVlMWQ3Njm0AklodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6OmN1cnNvcnlfaW1wbGllZF9lbmQ6OmgxOGY3YmFkZjZlYmEzOWI0tQI6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoNDY4ZWI5MGMyODc4ZmE5MbYCMjwmVCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmgyZmM1MGNjYzY0YTBlMjA1twIyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGE5OWE4MDk3YTk2YTVkZjC4AjI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoNDUyM2VlMzgxZmNkZjU3ZrkCOHRlbmRyaWw6OnRlbmRyaWw6OlRlbmRyaWw8RixBPjo6Y2xlYXI6OmhmN2FhZmUyOTQ2NTcxMTE3ugJZPHN0ZDo6aW86OldyaXRlOjp3cml0ZV9mbXQ6OkFkYXB0ZXI8VD4gYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aGM0NDJhYTlkMTQ1NTI3MmO7AkVjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c2VyZGVfanNvbjo6ZXJyb3I6OkVycm9yPjo6aDQxNzUzYWU5MTE2NThlOTm8Alpjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8dGVuZHJpbDo6dGVuZHJpbDo6VGVuZHJpbDx0ZW5kcmlsOjpmbXQ6OlVURjg+Pjo6aDhhYjZhOTY0YzhjYzM4ZTO9AkhodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6Omh0bWxfZGVmYXVsdF9zY29wZTo6aDk1MmJjNWNkMWY1MjIwMje+Anxjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6b3B0aW9uOjpPcHRpb248c3RyaW5nX2NhY2hlOjphdG9tOjpBdG9tPG1hcmt1cDVldmVyOjpMb2NhbE5hbWVTdGF0aWNTZXQ+Pj46OmhlYzUyN2VmM2IwMjAyMDgyvwJ5Y29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6Om9wdGlvbjo6T3B0aW9uPHN0cmluZ19jYWNoZTo6YXRvbTo6QXRvbTxtYXJrdXA1ZXZlcjo6UHJlZml4U3RhdGljU2V0Pj4+OjpoZjc5MGI0NjZhYjk4MGJiNMACLmNvcmU6OnJlc3VsdDo6dW53cmFwX2ZhaWxlZDo6aGUwZGRjMjY5MDgzMDk4YWbBAi9hbGxvYzo6dmVjOjpWZWM8VCxBPjo6cmVtb3ZlOjpoNDBmMWQ2MWM3ODk3MWMyOcICUzxodG1sNWV2ZXI6OnRva2VuaXplcjo6Y2hhcl9yZWY6OlN0YXRlIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhmODJmYjRhMDJhYTRkM2I5wwJnaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5zZXJ0X2VsZW1lbnQ6OmZvcm1fYXNzb2NpYXRhYmxlOjpoZDcwNTE4NmE3M2ExZWQ1N8QCZmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxzdHJpbmdfY2FjaGU6OmF0b206OkF0b208bWFya3VwNWV2ZXI6OkxvY2FsTmFtZVN0YXRpY1NldD4+OjpoNzI5ZWRhOTU1MTc1NGMzNMUCZmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxzdHJpbmdfY2FjaGU6OmF0b206OkF0b208bWFya3VwNWV2ZXI6OkxvY2FsTmFtZVN0YXRpY1NldD4+OjpoYjlhZTE5ZTNmM2IxNDFhOcYCZmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxzdHJpbmdfY2FjaGU6OmF0b206OkF0b208bWFya3VwNWV2ZXI6Ok5hbWVzcGFjZVN0YXRpY1NldD4+OjpoNTIxN2JlZWYxMjcxZTI5MMcCrQE8aHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPiBhcyBodG1sNWV2ZXI6OnRva2VuaXplcjo6aW50ZXJmYWNlOjpUb2tlblNpbms+OjphZGp1c3RlZF9jdXJyZW50X25vZGVfcHJlc2VudF9idXRfbm90X2luX2h0bWxfbmFtZXNwYWNlOjpoZDA0MWIwZjQ1MDVjNjZkMsgCMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNjQ2OGFlNzlmMzViY2Y1MckCPmFsbG9jOjp2ZWM6OlZlYzxULEE+OjppbnNlcnQ6OmFzc2VydF9mYWlsZWQ6Omg2NjJjMzk0MmQ5MTkzODE0ygI+YWxsb2M6OnZlYzo6VmVjPFQsQT46OnJlbW92ZTo6YXNzZXJ0X2ZhaWxlZDo6aDk4NGRmM2I3ZjJmZTQwM2HLAjZjb3JlOjpwYW5pY2tpbmc6OnBhbmljX2JvdW5kc19jaGVjazo6aDBjZmNlNDU5MjYwYTBhODLMAkRjb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZGV4X2xlbl9mYWlsX3J0OjpoMGMxNDMxNDAyMjRmNTFlOc0CQmNvcmU6OnNsaWNlOjppbmRleDo6c2xpY2VfZW5kX2luZGV4X2xlbl9mYWlsX3J0OjpoNDFiNWU0OTBlODRhMzBkNM4CQGNvcmU6OnNsaWNlOjppbmRleDo6c2xpY2VfaW5kZXhfb3JkZXJfZmFpbF9ydDo6aDU4NzdlZjJhMWYyMzVhZmTPAjA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGJhOTgwM2I5ZTM2ZjM4YTbQAjlzdHJpbmdfY2FjaGU6OmR5bmFtaWNfc2V0OjpTZXQ6OnJlbW92ZTo6aGNiNjFlYzUwMmJjMDEzZjHRAi1hbGxvYzo6dmVjOjpWZWM8VCxBPjo6cHVzaDo6aDk4ZmQ5NjcyMjZmMWQ3NzfSAjtjb3JlOjpmbXQ6OmJ1aWxkZXJzOjpEZWJ1Z1N0cnVjdDo6ZmluaXNoOjpoNDdmMzA0NGI2ZDcxNTRmNdMCVGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnBhcnNlX3Jhd19kYXRhOjpoZDdkZmJmNmFkMThkZTZkN9QCSjxjb3JlOjpvcHM6OnJhbmdlOjpSYW5nZTxJZHg+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhhOGE3ZjVjZTM5MzI5NGQ41QJYaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5faHRtbF9lbGVtX25hbWVkOjpoYjEzZGE3MDM4NDgwNGJiZdYCMjwmVCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmgyNjQ3YTk3YzMzOWQ4MWRl1wIvYWxsb2M6OnZlYzo6VmVjPFQsQT46Omluc2VydDo6aGEzOTdkZTg3N2RjNmIzMWLYAjxkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+Ojppbml0X3RvcDo6aDAwZDZlZWFlNmE5NDY2MzHZAjdzdGQ6OmFsbG9jOjpkZWZhdWx0X2FsbG9jX2Vycm9yX2hvb2s6Omg4NzIwMWY1ZmU1YWI3NDU42gJbaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Zm9zdGVyX3BhcmVudF9pbl9ib2R5OjpoY2RkMTBmMzE1MmNkY2JiYtsCTXN0ZDo6aW86OmJ1ZmZlcmVkOjpidWZ3cml0ZXI6OkJ1ZldyaXRlcjxXPjo6d3JpdGVfYWxsX2NvbGQ6Omg4MzhjZDhiYmI3YWRjOTY33AJjPHN0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pY19oYW5kbGVyOjpQYW5pY1BheWxvYWQgYXMgY29yZTo6cGFuaWM6OkJveE1lVXA+OjpnZXQ6OmhmNzRmY2UwYzg4MzAwNDgx3QI6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfZm10OjpoZTBhMWMzZTk2ZTMxNjMzZd4COjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6aDMxYWI3NTcyZmVjY2IzODPfAjo8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9mbXQ6OmgzODhjYmE0NTMyYzEyM2Vj4AI6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfZm10OjpoNDFkOTdmZWVhZjRjOTk4OOECOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2ZtdDo6aGRhOWI2ZGJiYzc4OTFjZDDiAjo8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9mbXQ6OmhkOWVjNjQ3MWJhMzdmNjZi4wI6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfZm10OjpoMzY5MDg2NmYzYWFjNTUyMeQCMWNvcmU6OnBhbmlja2luZzo6YXNzZXJ0X2ZhaWxlZDo6aGZjMzNjMWJjNzkyMzYwNTblAjFjb3JlOjpwYW5pY2tpbmc6OmFzc2VydF9mYWlsZWQ6OmgzM2QzZjU1ZWE0ODAxNDZl5gIxY29yZTo6cGFuaWNraW5nOjphc3NlcnRfZmFpbGVkOjpoZDk5NDBmZTkwZGI4ZjkyN+cCSmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnB1c2g6OmhlZTM5YjdjYmQyMjI0MTg06AIyY29yZTo6Zm10OjpGb3JtYXR0ZXI6OndyaXRlX2ZtdDo6aGJkZTU1ZTY0Y2MyNzBkNGXpAi5jb3JlOjpmbXQ6OldyaXRlOjp3cml0ZV9mbXQ6OmgwOTk0ODczMWQ3NmNhYjE16gIuY29yZTo6Zm10OjpXcml0ZTo6d3JpdGVfZm10OjpoMDZiN2NmMDkyM2VlZmMzY+sCLmNvcmU6OmZtdDo6V3JpdGU6OndyaXRlX2ZtdDo6aDdjYzM3MzQxMGRiMTUxZjLsAi5jb3JlOjpmbXQ6OldyaXRlOjp3cml0ZV9mbXQ6OmhjZTk2NDlhNWE4NDIxYzY57QJCPGFsbG9jOjp2ZWM6OlZlYzxULEE+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgwN2YxZDJhMzAzNGY2OWI47gIuY29yZTo6b3B0aW9uOjpleHBlY3RfZmFpbGVkOjpoYzM2YTY5MzY2Nzc3Y2UwYu8CLmNvcmU6OmZtdDo6V3JpdGU6OndyaXRlX2ZtdDo6aGU3ZjBhOTlmN2NmNzQ4NzfwAmY8Y29yZTo6cmNkb206OlJjRG9tIGFzIG1hcmt1cDVldmVyOjppbnRlcmZhY2U6OnRyZWVfYnVpbGRlcjo6VHJlZVNpbms+OjpwYXJzZV9lcnJvcjo6aDEyM2UxZmMyNTQ2Nzc1NWbxAkFodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6OmhlYWRpbmdfdGFnOjpoMTdjZTBjN2UzYjljOWNlNvICMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYTRhY2JiOTgyNjdmODBkMPMCWDxtYXJrdXA1ZXZlcjo6dXRpbDo6YnVmZmVyX3F1ZXVlOjpTZXRSZXN1bHQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGY1ZGI5NWYyYzkxZjNmOTH0Ai1sb2c6Ol9fcHJpdmF0ZV9hcGlfZW5hYmxlZDo6aGI3NDNkOWNmYTA3YzZmN2T1Aj5hbGxvYzo6Y29sbGVjdGlvbnM6OmJ0cmVlOjpub2RlOjpzcGxpdHBvaW50OjpoYjhmYzFkNjgxNzMxNWY0MfYCXzxzdHJpbmdfY2FjaGU6OmF0b206OkF0b208U3RhdGljPiBhcyBjb3JlOjpvcHM6OmRyb3A6OkRyb3A+Ojpkcm9wOjpkcm9wX3Nsb3c6Omg1MGY3OTNhYzFiZjgyYWEy9wJWPGh0bWw1ZXZlcjo6dG9rZW5pemVyOjppbnRlcmZhY2U6OkRvY3R5cGUgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGJjYWM0YTE2Mjc4YmUxYjX4AlI8aHRtbDVldmVyOjp0b2tlbml6ZXI6OmludGVyZmFjZTo6VGFnIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg1Mzg0YWU5MTU4OTBmZmVk+QJVaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Y3VycmVudF9ub2RlX2luOjpoMzIwNzM5NTBjMjQ3OWFkOfoCL2FsbG9jOjp2ZWM6OlZlYzxULEE+OjpyZW1vdmU6OmgxNzliNTkxODJmYTUyNWMy+wJBaGFzaGJyb3duOjpyYXc6OkZhbGxpYmlsaXR5OjpjYXBhY2l0eV9vdmVyZmxvdzo6aGM2MWQ4YWRlYTlkYTQ5NWb8AlNodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6Om1hdGhtbF90ZXh0X2ludGVncmF0aW9uX3BvaW50OjpoNWI1NDBjOGYzMDNhZTk0NP0CSGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0YWdfc2V0czo6dGFibGVfYm9keV9jb250ZXh0OjpoMDE1YjlmYWYyMjQwNjE5Y/4CaWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnByb2Nlc3NfY2hhcnNfaW5fdGFibGU6OnRhYmxlX291dGVyOjpoNjg5ZDEwNzI0N2JlMWIzMv8CYzxzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWM6OlBhbmljUGF5bG9hZDxBPiBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OnRha2VfYm94OjpoNGI2M2Y1Yzk2MzYzYTliZoADUWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OmFwcGVuZF90ZXh0OjpoY2M1YTk3MmRlMDJiYzRmZoEDYzxzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWM6OlBhbmljUGF5bG9hZDxBPiBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OnRha2VfYm94OjpoMDg0ODMyYTY5OGI4NmE2YYIDEXJ1c3RfYmVnaW5fdW53aW5kgwMtYWxsb2M6OnZlYzo6VmVjPFQsQT46OnB1c2g6Omg1OTcwNTMwODg2NzUzOWYxhANePGNvcmU6OnNsaWNlOjppdGVyOjpJdGVyPFQ+IGFzIGNvcmU6Oml0ZXI6OnRyYWl0czo6aXRlcmF0b3I6Okl0ZXJhdG9yPjo6YW55OjpoM2FjYTE1M2QzNzg3OWY3MYUDU2h0bWw1ZXZlcjo6dG9rZW5pemVyOjpjaGFyX3JlZjo6Q2hhclJlZlRva2VuaXplcjo6dW5jb25zdW1lX25hbWU6OmgyNDQ1MWMwN2QxYjE2N2Y4hgNCY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPHN0ZDo6aW86OmVycm9yOjpFcnJvcj46OmhkOTgyNjJhM2MxY2FhYzQyhwNkY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPHN0ZDo6aW86OldyaXRlOjp3cml0ZV9mbXQ6OkFkYXB0ZXI8YWxsb2M6OnZlYzo6VmVjPHU4Pj4+OjpoYjk1Mzg2ZjVmNTVjYzUwM4gDMWFsbG9jOjp2ZWM6OlZlYzxULEE+Ojp0cnVuY2F0ZTo6aDIxNzM3Yjg4YTdiZGZhNWKJA0JwYXJraW5nX2xvdF9jb3JlOjpwYXJraW5nX2xvdDo6Y3JlYXRlX2hhc2h0YWJsZTo6aGMxYWM5ZDIzODI1NzlhMjSKA2Rjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c3RkOjppbzo6V3JpdGU6OndyaXRlX2ZtdDo6QWRhcHRlcjxhbGxvYzo6dmVjOjpWZWM8dTg+Pj46OmhjZWE5OWJkNzc3NTE4OGU4iwNOPG1hcmt1cDVldmVyOjppbnRlcmZhY2U6OlF1YWxOYW1lIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhlNzdlMmJmZWFhYzNhMDE1jANdPHN0cmluZ19jYWNoZTo6ZHluYW1pY19zZXQ6OkRZTkFNSUNfU0VUIGFzIGNvcmU6Om9wczo6ZGVyZWY6OkRlcmVmPjo6ZGVyZWY6Omg3MWExYTE1Yjg0ODExNDYwjQMpY29yZTo6cGFuaWNraW5nOjpwYW5pYzo6aDJmMDQxYmY2YWE5OTBkZmSOAzFjb21waWxlcl9idWlsdGluczo6bWVtOjptZW1jbXA6OmhiZTkzYzEzNWU3NTVjOWRijwNFPGNvcmU6Om9wdGlvbjo6T3B0aW9uPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhkOTNhN2JlYjI1ZDE3ZDRjkANFPGNvcmU6Om9wdGlvbjo6T3B0aW9uPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhmNDVmNTM3NGYyYjkyOWE4kQNFPGNvcmU6Om9wdGlvbjo6T3B0aW9uPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg3ZDNkYjY3YTE3OGRiYzA3kgMxYWxsb2M6OnN5bmM6OkFyYzxUPjo6ZHJvcF9zbG93OjpoNzYxODcyMzYwZTY0NmEzNZMDOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aDYwYTdkOGE3YzFmNzIyMTiUA1JodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6VHJlZUJ1aWxkZXI8SGFuZGxlLFNpbms+Ojphc3NlcnRfbmFtZWQ6OmgzY2I5OGExZmQ1ZWU3NjczlQM6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoY2M5MmNiNWYxNDZjZGYwOZYDWTxzdGQ6OmlvOjpXcml0ZTo6d3JpdGVfZm10OjpBZGFwdGVyPFQ+IGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9zdHI6Omg5OTkxOGQ3ZjliNzg1MjNllwM6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoZmIzNTM4N2E2OTBlZTBiY5gDOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aGUzYTMwOGFlMzc5MTM0NTaZA1k8c3RkOjppbzo6V3JpdGU6OndyaXRlX2ZtdDo6QWRhcHRlcjxUPiBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoOTVkOGI2MDVlN2QzYTI0YZoDOjwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX3N0cjo6aGY1NTEzNTNiY2E1N2M2ZmabAz1jb3JlOjpudW06OjxpbXBsIHU4Pjo6ZXFfaWdub3JlX2FzY2lpX2Nhc2U6OmhjOWM0NjFhNDRlOGM2NjNinANJPGFsbG9jOjpzdHJpbmc6OlN0cmluZyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoZTg3MzY5YWU5Yjg4N2I0OZ0DTzxtYXJrdXA1ZXZlcjo6aW50ZXJmYWNlOjpBdHRyaWJ1dGUgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDkzMzFkY2MwYTRmYTk1ZmSeAypzdGQ6OnRpbWU6Okluc3RhbnQ6Om5vdzo6aDIzMTFjOThjYjYwOTQ1ZDifAy5zdGQ6OnRpbWU6Okluc3RhbnQ6OmVsYXBzZWQ6OmhiMDdmZWFkMmRiMTNmZDg1oAM0YWxsb2M6OnJhd192ZWM6OmNhcGFjaXR5X292ZXJmbG93OjpoM2JiNDUzN2I1ZjlmODQwNKEDSjxhbGxvYzo6c3RyaW5nOjpGcm9tVXRmOEVycm9yIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhhOTE2NDRhYTAzNDQ1YzcxogMtYWxsb2M6OnZlYzo6VmVjPFQsQT46OnB1c2g6OmhjNjcyNGRjYjU3ZjdjOGE0owNZaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6c3RlcDo6ZXh0cmFfc3BlY2lhbDo6aGU4YTM5ZTI5NzU4OThiNTekA2s8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlN0clBhbmljUGF5bG9hZCBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OnRha2VfYm94OjpoMTAwMjY2MDA2MjM3ZmM0ZKUDSWh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnBvcDo6aDY2N2M3OWU4MDU0Y2U3YTimA0g8ZGxtYWxsb2M6OnN5czo6U3lzdGVtIGFzIGRsbWFsbG9jOjpBbGxvY2F0b3I+OjphbGxvYzo6aGViOGEwYjE2ZjhmNWJjYzCnA0Njb3JlOjpmbXQ6OkZvcm1hdHRlcjo6cGFkX2ludGVncmFsOjp3cml0ZV9wcmVmaXg6OmhiNjIzNjljMDJmMWEyOTZhqANLY29yZTo6Zm10OjpmbG9hdDo6PGltcGwgY29yZTo6Zm10OjpEaXNwbGF5IGZvciBmNjQ+OjpmbXQ6OmhiMjY0MTExY2JmYjFjOTk2qQMtYWxsb2M6OnZlYzo6VmVjPFQsQT46OnB1c2g6Omg3NDJhMTc3ZmM1ZWM5MDg3qgNQaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OnRhZ19zZXRzOjpzdmdfaHRtbF9pbnRlZ3JhdGlvbl9wb2ludDo6aDJkNDFiMWZjMTA5YTA4ZWarA0FodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6OnRhYmxlX3Njb3BlOjpoNWNhODY1N2JjZDNjZTNkYawDR2h0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0YWdfc2V0czo6dGFibGVfcm93X2NvbnRleHQ6Omg5NWVmNWRhZTFkNjBkOGYyrQNXaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6c3RlcDo6dGFibGVfb3V0ZXI6OmgyZjNiNjdlMWVkYTZkN2VhrgNNY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPHN0cmluZ19jYWNoZTo6ZHluYW1pY19zZXQ6OkVudHJ5Pjo6aGNlYzllN2ZjODY0MmFlNzivA01jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8c3RyaW5nX2NhY2hlOjpkeW5hbWljX3NldDo6RW50cnk+OjpoY2VjOWU3ZmM4NjQyYWU3OLADQmh0bWw1ZXZlcjo6dG9rZW5pemVyOjpUb2tlbml6ZXI8U2luaz46OmdldF9jaGFyOjpoMzY5ZjcxODE5OWIyYmQzZrEDQHN0ZDo6c3luYzo6b25jZV9sb2NrOjpPbmNlTG9jazxUPjo6aW5pdGlhbGl6ZTo6aGZlMGIyMGZmMmM1MDY3MDGyAy1jb3JlOjpwYW5pY2tpbmc6OnBhbmljX2ZtdDo6aGY1YzRjZDkyOWQ0YWFhOWWzAxFfX3diaW5kZ2VuX21hbGxvY7QDL3NlcmRlX2pzb246OmVycm9yOjpFcnJvcjo6aW86OmhmZTA4YWRlNjBlNmM1Y2RhtQNYaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6Y3VycmVudF9ub2RlX25hbWVkOjpoMGI3ZDgzZWY2Nzk2ZTc2ZbYDMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoM2YzZGM0NmU2ZTgxZWYzNbcDMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOTdkYjRjMjNlMzg2OWQ3MLgDEl9fcmRsX2FsbG9jX3plcm9lZLkDMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYzNjOTJkNTUzZjQ2NWMyZboDSGh0bWw1ZXZlcjo6dG9rZW5pemVyOjpjaGFyX3JlZjo6Q2hhclJlZlRva2VuaXplcjo6bmV3OjpoYTA0YTExZjIwMThkNmI1OLsDRnBhcmtpbmdfbG90X2NvcmU6OnBhcmtpbmdfbG90OjpGYWlyVGltZW91dDo6Z2VuX3UzMjo6aDk0ZDcyMmQyMDNmMmMxZja8A0ZodG1sNWV2ZXI6OnRva2VuaXplcjo6VG9rZW5pemVyPFNpbms+OjpkaXNjYXJkX2NoYXI6Omg1ODkzYzU4ZWNkY2RkYzNivQNZaHRtbDVldmVyOjp0b2tlbml6ZXI6OmNoYXJfcmVmOjpDaGFyUmVmVG9rZW5pemVyOjpmaW5pc2hfbnVtZXJpYzo6Y29udjo6aGFhNDc4ZWExYTYzZTg1YzW+A3s8bWFya3VwNWV2ZXI6OmludGVyZmFjZTo6RXhwYW5kZWROYW1lIGFzIGNvcmU6OmNtcDo6UGFydGlhbEVxPG1hcmt1cDVldmVyOjppbnRlcmZhY2U6OkV4cGFuZGVkTmFtZT4+OjplcTo6aGUyOTQ4MmY4NGJjYjcxMWa/Azljb3JlOjpmbXQ6OmJ1aWxkZXJzOjpEZWJ1Z0xpc3Q6OmZpbmlzaDo6aGYxM2M5MTcyYjMxNTNlNGTAAzRjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6ZGVidWdfdHVwbGU6OmgxNDQ5ZDJjOGRkOWNlZTUxwQM7c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljOjp7e2Nsb3N1cmV9fTo6aDcwMTg0NDE2MzA1YjdjZGXCA0JodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6OnNlbGVjdF9zY29wZTo6aGFlZmZlYTA4OGU5ZTJlZGPDAztodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dGFnX3NldHM6OnRkX3RoOjpoZWM3NjIxMGUwYzUzNDk0MsQDVmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnN0ZXA6OmNsb3NlX2RlZm46Omg3MTA5OTk1NmUxOGZiMzIzxQM7c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljOjp7e2Nsb3N1cmV9fTo6aDliNjE2ZDM1ODgyOTQ2MznGA0djb3JlOjpmbXQ6Om51bTo6PGltcGwgY29yZTo6Zm10OjpEZWJ1ZyBmb3IgaTMyPjo6Zm10OjpoMmQ0ZTRmYmNiYmE4MzQ1MccDN2RsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OnNldF9pbnVzZTo6aDcyZWVhYzRlYjEwYzc0YTfIA2g8Y29yZTo6Y2hhcjo6RXNjYXBlRGVmYXVsdCBhcyBjb3JlOjppdGVyOjp0cmFpdHM6OmV4YWN0X3NpemU6OkV4YWN0U2l6ZUl0ZXJhdG9yPjo6bGVuOjpoZGNhMTBiMjY1MWUxNzYwMckDLGNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpuZXc6OmhjZWEwZjM4OTQ5MTJhMGJkygM1Y29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3N0cnVjdDo6aDA2ZWQxZTIyMWQwZDE2YjfLAzNjb3JlOjpmbXQ6OkZvcm1hdHRlcjo6ZGVidWdfbGlzdDo6aGM3MTQwNjA3MWQ2N2IyNDbMAy5zdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWM6OmgwZDllYjIxZmU5NzBmMDAxzQNaaHRtbDVldmVyOjp0cmVlX2J1aWxkZXI6OlRyZWVCdWlsZGVyPEhhbmRsZSxTaW5rPjo6aW5zZXJ0X2FwcHJvcHJpYXRlbHk6OmhhODM1NTAwNjVmY2ZlYzUyzgM7aHRtbDVldmVyOjp1dGlsOjpzdHI6Omxvd2VyX2FzY2lpX2xldHRlcjo6aGJjMzVlNzNlNjZiZmQzM2PPAy5zdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWM6Omg3OWMyOGUzYjkxYzEzNzNk0ANYY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGNvcmU6Om9wdGlvbjo6T3B0aW9uPGFsbG9jOjpzdHJpbmc6OlN0cmluZz4+OjpoMjIwYWNmNmFiNjcyMGNmNNEDNWRsbWFsbG9jOjpkbG1hbGxvYzo6U2VnbWVudDo6aG9sZHM6OmgwNmFlODFiYWZmNzU0YjM20gMSX193YmluZGdlbl9yZWFsbG9j0wNCZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6c2V0X2ZyZWVfd2l0aF9waW51c2U6OmgyYzdkOWY1OTJjOWMxNjM21ANOY29yZTo6Zm10OjpudW06OmltcDo6PGltcGwgY29yZTo6Zm10OjpEaXNwbGF5IGZvciBpMzI+OjpmbXQ6OmhjNGY2MTQ3MjA1NTg4Nzcy1QMwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmgzYzUwZDJkYzBhNzc5NDMy1gNbPGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjp0eXBlczo6SW5zZXJ0aW9uTW9kZSBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoN2M5YmI1MWZiZTJjZTQwY9cDWTxodG1sNWV2ZXI6OnRyZWVfYnVpbGRlcjo6dHlwZXM6OlNwbGl0U3RhdHVzIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhiZGM0YTkxYjYyYzdiODAw2ANHPHN0ZDo6aW86OmVycm9yOjpFcnJvcktpbmQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDliNDQ3ZTY2ZWIzYTgzMjTZA0JkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpzZXRfaW51c2VfYW5kX3BpbnVzZTo6aDdmYWMyMzI2ZjQ3MDAwNzXaAzloYXNoYnJvd246OnJhdzo6RmFsbGliaWxpdHk6OmFsbG9jX2Vycjo6aDQxMmI4MGFjOTMzMTZhMWLbA0ljb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8YWxsb2M6OnN0cmluZzo6RnJvbVV0ZjhFcnJvcj46Omg1ZGYwZWY2YjFmZjZlNzU13ANCY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPGFsbG9jOjpzdHJpbmc6OlN0cmluZz46OmgyMmUzNDEyODZmNzBlYzJj3QM3aHRtbDVldmVyOjp1dGlsOjpzdHI6OmlzX2FzY2lpX2FsbnVtOjpoOWIwNjE5NmI5NDkzNTIzMt4DMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNmQ0NDEzOWUzNTAxZTJkY98DQmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxhbGxvYzo6c3RyaW5nOjpTdHJpbmc+OjpoZWUyYmU4NmM3Mzc0YWY2YuADvwFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8PGFsbG9jOjpib3hlZDo6Qm94PGR5biBjb3JlOjplcnJvcjo6RXJyb3IrY29yZTo6bWFya2VyOjpTeW5jK2NvcmU6Om1hcmtlcjo6U2VuZD4gYXMgY29yZTo6Y29udmVydDo6RnJvbTxhbGxvYzo6c3RyaW5nOjpTdHJpbmc+Pjo6ZnJvbTo6U3RyaW5nRXJyb3I+OjpoY2NjOWQzMzc1Mjc2Zjk2NuEDNDxib29sIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGRhMzk1NzMyODhkZjljNjbiA148c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljOjpQYW5pY1BheWxvYWQ8QT4gYXMgY29yZTo6cGFuaWM6OkJveE1lVXA+OjpnZXQ6Omg0NWE2ZWZjYmMyYjlmZjM14wNNaHRtbDVldmVyOjp0b2tlbml6ZXI6OmNoYXJfcmVmOjpDaGFyUmVmVG9rZW5pemVyOjpuYW1lX2J1Zjo6aDRkNmY4MDI4YzdkYzI4MTTkA1FodG1sNWV2ZXI6OnRva2VuaXplcjo6Y2hhcl9yZWY6OkNoYXJSZWZUb2tlbml6ZXI6Om5hbWVfYnVmX211dDo6aDdkOWUxMTU2NWI2YTIwZmLlA1s8aHRtbDVldmVyOjp0b2tlbml6ZXI6OlRva2VuaXplck9wdHMgYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6OmgzNWViOWYzNTI0NmY5Nzhk5gNAaHRtbDVldmVyOjp0b2tlbml6ZXI6OmludGVyZmFjZTo6RG9jdHlwZTo6bmV3OjpoYjhkMDQ0NGNlMDFjOTJlOOcDVjxodG1sNWV2ZXI6OnRva2VuaXplcjo6aW50ZXJmYWNlOjpUYWdLaW5kIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhiMTVjZDEyMmQ5NjViZWM26ANePHN0ZDo6cGFuaWNraW5nOjpiZWdpbl9wYW5pYzo6UGFuaWNQYXlsb2FkPEE+IGFzIGNvcmU6OnBhbmljOjpCb3hNZVVwPjo6Z2V0OjpoZDc0ZDIxYzc5YThmYjdmM+kDTzx0ZW5kcmlsOjp0ZW5kcmlsOjpTdWJ0ZW5kcmlsRXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDk4NzkxNDYwNjJiNGNkOGTqAzA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGVhOTU5MWMyZDI1N2FiOGXrA0BkbG1hbGxvYzo6ZGxtYWxsb2M6OlRyZWVDaHVuazo6bGVmdG1vc3RfY2hpbGQ6OmgzNzIwMzJlYjkxMzQ1NWQ57ANPaHRtbDVldmVyOjp0b2tlbml6ZXI6OmNoYXJfcmVmOjpDaGFyUmVmVG9rZW5pemVyOjpmaW5pc2hfb25lOjpoYTZhZmI2ZjNhMWM2Y2RmMu0DJ3N0ZDo6YWxsb2M6OnJ1c3Rfb29tOjpoZWM0YzhkNTdkMTA4M2FiM+4DP2RsbWFsbG9jOjpkbG1hbGxvYzo6bGVmdHNoaWZ0X2Zvcl90cmVlX2luZGV4OjpoMzVhZjdmODkyNDI2OWY1Nu8DT2RsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OnNldF9zaXplX2FuZF9waW51c2Vfb2ZfZnJlZV9jaHVuazo6aGZjYWIzMzIxODBmZTgxMWLwA1BodG1sNWV2ZXI6OnRva2VuaXplcjo6Y2hhcl9yZWY6OkNoYXJSZWZUb2tlbml6ZXI6OmZpbmlzaF9ub25lOjpoN2ViODMxMjlhZWUyYTAwNvEDPGh0bWw1ZXZlcjo6dXRpbDo6c3RyOjppc19hc2NpaV93aGl0ZXNwYWNlOjpoNjlmZGUyNzlkZWVjNTViZfIDMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoODQwMDY3YTRmODkyNDllYfMDVmh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlcjxIYW5kbGUsU2luaz46OnN0ZXA6OmNsb3NlX2xpc3Q6Omg2ZWY1NTE0ZWUyYTE2NzYx9AMvZGxtYWxsb2M6OmRsbWFsbG9jOjphbGlnbl91cDo6aDc3ZWRkOWE5NWRjZDczMmL1Aw5fX3J1c3RfcmVhbGxvY/YDD19fd2JpbmRnZW5fZnJlZfcDMGRsbWFsbG9jOjpkbG1hbGxvYzo6bGVmdF9iaXRzOjpoNjk0NWM5ODgwZGJjY2I1YfgDRTxjb3JlOjpjZWxsOjpCb3Jyb3dFcnJvciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZmRhY2JjMDE0YzExYWI0ZPkDSDxjb3JlOjpjZWxsOjpCb3Jyb3dNdXRFcnJvciBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYzFhZjk2YjE2NzVlNTBhZfoDMmNvcmU6OmZtdDo6Rm9ybWF0dGVyOjp3cml0ZV9zdHI6Omg2MDE4YTljYWNiY2U2ODYw+wM+PGNvcmU6OmZtdDo6RXJyb3IgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDM4YzQ2MmMwNTYxODQxMzD8AzA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aDA0Yjc1NDRiOTYwM2M0Yjj9Ay5jb3JlOjpzdHI6OnNsaWNlX2Vycm9yX2ZhaWw6Omg3NTZlZTcwYWQxMjdkZWVl/gMMX19ydXN0X2FsbG9j/wMTX19ydXN0X2FsbG9jX3plcm9lZIAERTxhbGxvYzo6c3RyaW5nOjpTdHJpbmcgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoYjJjODFjNzc3MmExMDNkZIEEMjwmVCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6Omg0MTcxOTkxMjQ2YTIxODZhggRDPGFsbG9jOjpzdHJpbmc6OlN0cmluZyBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYmJmM2U5ZTk0NzlhMjY5YoMEMjwmVCBhcyBjb3JlOjpmbXQ6OkRpc3BsYXk+OjpmbXQ6OmhhZTI0OGI1YjkyM2I0ZTQ5hARgPGh0bWw1ZXZlcjo6dHJlZV9idWlsZGVyOjpUcmVlQnVpbGRlck9wdHMgYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6Omg0MGUyYzk0MWNkOTQ4YmIzhQQyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDFjNWEyNWE2NmFhOGVmYzeGBF08cGFya2luZ19sb3RfY29yZTo6cGFya2luZ19sb3Q6OlRocmVhZERhdGEgYXMgY29yZTo6b3BzOjpkcm9wOjpEcm9wPjo6ZHJvcDo6aDkwMjZjMDllZWFjMjZhM2OHBDA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGEwZTA4MTY4ZjdlZGFiYjmIBDI8JlQgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoNDA3MTk2MmEyNzE0YWQ0ZokEQzxhbGxvYzo6c3RyaW5nOjpTdHJpbmcgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGJiZjNlOWU5NDc5YTI2OWKKBEU8YWxsb2M6OnN0cmluZzo6U3RyaW5nIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aGIyYzgxYzc3NzJhMTAzZGSLBGY8c3RkOjpwYW5pY2tpbmc6OmJlZ2luX3BhbmljX2hhbmRsZXI6OlN0clBhbmljUGF5bG9hZCBhcyBjb3JlOjpwYW5pYzo6Qm94TWVVcD46OmdldDo6aDhlYWEwZDY3ZDczYmRkMjOMBD5zdGQ6OnN5czo6d2FzbTo6Y29tbW9uOjpoYXNobWFwX3JhbmRvbV9rZXlzOjpoZDcyNTczZWY4MGNkMmE4No0ENGRsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OmNpbnVzZTo6aGM1OTQzODZiNmJhN2JjNjOOBDpkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpjbGVhcl9waW51c2U6OmgzNWU2ZDdjOWVmODM1OTdmjwQzZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6aW51c2U6OmgwYzNkOTc0OWNjZDliNDkxkAQyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdDo6aDgzZDY0ZGFhMDFhNWExMDWRBEQ8Y29yZTo6Zm10OjpBcmd1bWVudHMgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoNmYyMzQ2MzU1NjhjZTUxOJIEOGNvcmU6OmZtdDo6Rm9ybWF0dGVyOjpkZWJ1Z19sb3dlcl9oZXg6OmhhMzExNjE1NmQ2YTkyNmQ1kwQ4Y29yZTo6Zm10OjpGb3JtYXR0ZXI6OmRlYnVnX3VwcGVyX2hleDo6aGU0YjliN2JiMzU0YjI1NmKUBA5fX3J1c3RfZGVhbGxvY5UES2NvcmU6OmNtcDo6aW1wbHM6OjxpbXBsIGNvcmU6OmNtcDo6UGFydGlhbEVxIGZvciB1OD46OmVxOjpoMmMyZDUxODkwNzNkMWE4NpYEhwE8cGFya2luZ19sb3RfY29yZTo6dGhyZWFkX3Bhcmtlcjo6aW1wOjpUaHJlYWRQYXJrZXIgYXMgcGFya2luZ19sb3RfY29yZTo6dGhyZWFkX3Bhcmtlcjo6VGhyZWFkUGFya2VyVD46OnByZXBhcmVfcGFyazo6aGNiZjQyODZkNTMzNmI0ODeXBIQBPHBhcmtpbmdfbG90X2NvcmU6OnRocmVhZF9wYXJrZXI6OmltcDo6VGhyZWFkUGFya2VyIGFzIHBhcmtpbmdfbG90X2NvcmU6OnRocmVhZF9wYXJrZXI6OlRocmVhZFBhcmtlclQ+Ojp0aW1lZF9vdXQ6Omg2MjhhZjRkMWYzMDc4ZDZjmAR/PHBhcmtpbmdfbG90X2NvcmU6OnRocmVhZF9wYXJrZXI6OmltcDo6VGhyZWFkUGFya2VyIGFzIHBhcmtpbmdfbG90X2NvcmU6OnRocmVhZF9wYXJrZXI6OlRocmVhZFBhcmtlclQ+OjpwYXJrOjpoMDA3MDYzNmI4YTMyYzBkZJkEhQE8cGFya2luZ19sb3RfY29yZTo6dGhyZWFkX3Bhcmtlcjo6aW1wOjpUaHJlYWRQYXJrZXIgYXMgcGFya2luZ19sb3RfY29yZTo6dGhyZWFkX3Bhcmtlcjo6VGhyZWFkUGFya2VyVD46OnBhcmtfdW50aWw6Omg3YTBlMTk1YWRjNjMzNjg0mgSGATxwYXJraW5nX2xvdF9jb3JlOjp0aHJlYWRfcGFya2VyOjppbXA6OlRocmVhZFBhcmtlciBhcyBwYXJraW5nX2xvdF9jb3JlOjp0aHJlYWRfcGFya2VyOjpUaHJlYWRQYXJrZXJUPjo6dW5wYXJrX2xvY2s6OmhmNTcxMzU3ODI0YWU0N2IzmwQKcnVzdF9wYW5pY5wEWTxzdGQ6OnN5czo6d2FzbTo6b25jZTo6Q29tcGxldGlvbkd1YXJkIGFzIGNvcmU6Om9wczo6ZHJvcDo6RHJvcD46OmRyb3A6OmhlZTI0MWRhZDNjYTc5MTAwnQQwZGxtYWxsb2M6OmRsbWFsbG9jOjpsZWFzdF9iaXQ6OmgzMzA4YWEzYTM5ZmI0ZTExngQ1ZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6bW1hcHBlZDo6aDAyMDRkNmEwMWFmNGJhYjKfBFBkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpzZXRfc2l6ZV9hbmRfcGludXNlX29mX2ludXNlX2NodW5rOjpoZTc5MzYzZmFiMjQ0NTI2MKAEM2RsbWFsbG9jOjpkbG1hbGxvYzo6U2VnbWVudDo6dG9wOjpoMGQ5NmZiNTJiNWUyMjM4Y6EEOzwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2NoYXI6Omg3NmMzNTY2OTAwYjk5NzdlogQ5Y29yZTo6b3BzOjpmdW5jdGlvbjo6Rm5PbmNlOjpjYWxsX29uY2U6OmgzZGM4NjFmZTgyNDNjYTQ2owRBY29yZTo6c2xpY2U6OmluZGV4OjpzbGljZV9zdGFydF9pbmRleF9sZW5fZmFpbDo6aDY1ZjRjNjNjZjljM2ZjYTCkBD9jb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX2VuZF9pbmRleF9sZW5fZmFpbDo6aDU5MmM5ZmQ0Mzg0NDRjYWKlBD1jb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX2luZGV4X29yZGVyX2ZhaWw6Omg2YjAwNTIwYTY0NzU2NDExpgROY29yZTo6Zm10OjpudW06OmltcDo6PGltcGwgY29yZTo6Zm10OjpEaXNwbGF5IGZvciB1MzI+OjpmbXQ6Omg5MjQyM2M0MzZmYjhlYjZjpwRNY29yZTo6Zm10OjpudW06OmltcDo6PGltcGwgY29yZTo6Zm10OjpEaXNwbGF5IGZvciB1OD46OmZtdDo6aDk3Mzk4NTk1YTYxMjVkMTKoBDdjb3JlOjpmbXQ6OmJ1aWxkZXJzOjpEZWJ1Z1NldDo6ZW50cnk6OmhkNDNhNTBmNGJjZDljYjQ3qQQ6PCZtdXQgVyBhcyBjb3JlOjpmbXQ6OldyaXRlPjo6d3JpdGVfc3RyOjpoNzQ5YzdiNzUwMzdmNTE0N6oETmNvcmU6OmZtdDo6bnVtOjppbXA6OjxpbXBsIGNvcmU6OmZtdDo6RGlzcGxheSBmb3IgdTY0Pjo6Zm10OjpoNTFjMWNkYmYyMDQ3YzYwM6sEH19fd2JpbmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXKsBBpfX3J1c3RfYWxsb2NfZXJyb3JfaGFuZGxlcq0EMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYzBlMDA5NzVkNjNmZGEzNK4EMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoYjExOWNlY2FmZjRlNGRiNa8EMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoNGJkMDUzNmJhZGUxYjYxYbAEMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZjViM2VjMjcyNzEyZjcxYbEEMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOWI5OGRjOWFmMGFlZWJmZLIEMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoMjMzYjNhMzU1ZTRhZjdlObMEQDx0ZW5kcmlsOjpmbXQ6OlVURjggYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGJjMTI1MDVjNWVkZTMxMGS0BDA8JlQgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGZmYjkyZGNjOTkyMjNhMzC1BDs8Jm11dCBXIGFzIGNvcmU6OmZtdDo6V3JpdGU+Ojp3cml0ZV9jaGFyOjpoMDczNzBhZGVmMjk5YWQ0NLYEOzwmbXV0IFcgYXMgY29yZTo6Zm10OjpXcml0ZT46OndyaXRlX2NoYXI6OmhlYmY0OTk1NjBmYWUwNTFjtwQyZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6c2l6ZTo6aGMxYzZlZTE4NjJlZDNmNjO4BDRkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpwaW51c2U6OmgxNjA3Mzc1NDQ4MGE0N2JjuQQ5ZGxtYWxsb2M6OmRsbWFsbG9jOjpTZWdtZW50Ojppc19leHRlcm46Omg1Yjg4OGZjMTY5NGFhZGExugQ5ZGxtYWxsb2M6OmRsbWFsbG9jOjpTZWdtZW50OjpzeXNfZmxhZ3M6Omg0MmM0MjViNDM5NzkzMGVluwQwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Omg0ZDNmMWFiZmI3ZDJlMGE5vAQzYWxsb2M6OmFsbG9jOjpoYW5kbGVfYWxsb2NfZXJyb3I6Omg0ZjQ0MGZlMzI2YTQ0NTBkvQQ9YWxsb2M6OmFsbG9jOjpoYW5kbGVfYWxsb2NfZXJyb3I6OnJ0X2Vycm9yOjpoMTRhMTZkZDgzZTY1ZDE5Yr4EMzxzdHIgYXMgY29yZTo6Zm10OjpEaXNwbGF5Pjo6Zm10OjpoN2RjYjZlZGEwZjllMTVlMr8EMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoM2UzZDdmYzVjNTcwMGJiMMAEMDwmVCBhcyBjb3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoZjU1ZDM4YTdlODY3ZTI0YcEEB21lbW1vdmXCBAZtZW1jbXDDBAZtZW1zZXTEBAZtZW1jcHnFBElzdGQ6OnN5c19jb21tb246OmJhY2t0cmFjZTo6X19ydXN0X2VuZF9zaG9ydF9iYWNrdHJhY2U6Omg5MjRlZGE4MDE0NGI5NTAxxgQyPGJvb2wgYXMgY29yZTo6Zm10OjpEZWJ1Zz46OmZtdDo6aGFiOWYxNjA5OWM2NWE4MTHHBElzdGQ6OnN5c19jb21tb246OmJhY2t0cmFjZTo6X19ydXN0X2VuZF9zaG9ydF9iYWNrdHJhY2U6Omg4YzE0YWY3MTg2YjgwMmRiyARBc3RkOjpwYW5pY2tpbmc6OnBhbmljX2NvdW50Ojppc196ZXJvX3Nsb3dfcGF0aDo6aGEyNTc0MDYxNDc1MWFiZWTJBEM8c3RkOjppbzo6ZXJyb3I6OkVycm9yIGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OmhmNmU3MDgxZjBiNzUzMzQ3ygRJc3RkOjpzeXNfY29tbW9uOjpiYWNrdHJhY2U6Ol9fcnVzdF9lbmRfc2hvcnRfYmFja3RyYWNlOjpoNjNhZGFlNWMzMTQ1OGM0YssEC19fcmRsX2FsbG9jzAQ5ZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6cGx1c19vZmZzZXQ6Omg4Yzg4MTA2NzE4YjdkYTZlzQQ6ZGxtYWxsb2M6OmRsbWFsbG9jOjpDaHVuazo6bWludXNfb2Zmc2V0OjpoYjZkOTBhNmU4MWIwNDNiYs4ENGRsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OnRvX21lbTo6aGYyOGUyMzZhNThlNGU3OWXPBDZkbG1hbGxvYzo6ZGxtYWxsb2M6OkNodW5rOjpmcm9tX21lbTo6aDA2MmMwNGIyOGFlOGQxYjLQBDV3YXNtX2JpbmRnZW46Ol9fcnQ6Om1hbGxvY19mYWlsdXJlOjpoMDhjMjRkZTZhMmM3M2RlM9EEDV9fcmRsX2RlYWxsb2PSBDZkbG1hbGxvYzo6ZGxtYWxsb2M6OlRyZWVDaHVuazo6bmV4dDo6aDE4NzNiOWNkN2QzMWE5MDLTBDZkbG1hbGxvYzo6ZGxtYWxsb2M6OlRyZWVDaHVuazo6cHJldjo6aGU5YmE2OTgyNjBkOTVmYjPUBD5jb3JlOjpwYW5pYzo6cGFuaWNfaW5mbzo6UGFuaWNJbmZvOjptZXNzYWdlOjpoY2Q3MWU2ZWIzMmQwNTYzMNUEP2NvcmU6OnBhbmljOjpwYW5pY19pbmZvOjpQYW5pY0luZm86OmxvY2F0aW9uOjpoOThmZjM2NmFlODRjMTA2YdYEQWNvcmU6OnBhbmljOjpwYW5pY19pbmZvOjpQYW5pY0luZm86OmNhbl91bndpbmQ6OmgzZmMzNDZiMTA4MmNkZGJm1wQxPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoMTljYWZhOGIyNzIwNDk4MtgEODxsb2c6Ok5vcExvZ2dlciBhcyBsb2c6OkxvZz46OmVuYWJsZWQ6OmhlODJhMjcxYzk2MTYxMjIx2QRlPG1hcmt1cDVldmVyOjpMb2NhbE5hbWVTdGF0aWNTZXQgYXMgc3RyaW5nX2NhY2hlOjpzdGF0aWNfc2V0czo6U3RhdGljQXRvbVNldD46OmdldDo6aDQ5ZWMxZmU2ZDk2N2I1YTLaBGI8bWFya3VwNWV2ZXI6OlByZWZpeFN0YXRpY1NldCBhcyBzdHJpbmdfY2FjaGU6OnN0YXRpY19zZXRzOjpTdGF0aWNBdG9tU2V0Pjo6Z2V0OjpoMjgwMDg0NjAwNTQzNWQ1YtsEZTxtYXJrdXA1ZXZlcjo6TmFtZXNwYWNlU3RhdGljU2V0IGFzIHN0cmluZ19jYWNoZTo6c3RhdGljX3NldHM6OlN0YXRpY0F0b21TZXQ+OjpnZXQ6OmhhNGUyOWVkYzNkNDRlNjFm3ARFcGFya2luZ19sb3RfY29yZTo6dGhyZWFkX3Bhcmtlcjo6aW1wOjp0aHJlYWRfeWllbGQ6Omg5Y2Y4YzY2Y2EwNzU5N2Zk3QQxPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoYWMyYjVhNzY1M2E1Y2I2ZN4EMWluc3RhbnQ6Ondhc206OlN5c3RlbVRpbWU6Om5vdzo6aGQwMzZhNTM3OWRmNDNhYWXfBDE8VCBhcyBjb3JlOjphbnk6OkFueT46OnR5cGVfaWQ6OmgyNGM4YzRiYzg2NzAzZDAz4AQxPFQgYXMgY29yZTo6YW55OjpBbnk+Ojp0eXBlX2lkOjpoMzVjMGI2MGI2YTVmZTA2YuEEMTxUIGFzIGNvcmU6OmFueTo6QW55Pjo6dHlwZV9pZDo6aGQzYThjYTg0MmM3NzhmODTiBCZzdGQ6OnByb2Nlc3M6OmFib3J0OjpoYzNhMjVkZTQ1NDcyMDc0YuMEEl9fcnVzdF9zdGFydF9wYW5pY+QEPGRsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6OmZlbmNlcG9zdF9oZWFkOjpoZmQyMDRlODYyOTE0NTVmOeUEOGRsbWFsbG9jOjpkbG1hbGxvYzo6Q2h1bms6Om1lbV9vZmZzZXQ6Omg4MGYyOThkMmVkN2Q2ZmZj5gQ3ZGxtYWxsb2M6OmRsbWFsbG9jOjpUcmVlQ2h1bms6OmNodW5rOjpoNjcyMGJmMTBmZWI0NTVlZOcESDxkbG1hbGxvYzo6c3lzOjpTeXN0ZW0gYXMgZGxtYWxsb2M6OkFsbG9jYXRvcj46OnJlbWFwOjpoNzU1MWQ2ZDFmM2Y1OTYwNegETDxkbG1hbGxvYzo6c3lzOjpTeXN0ZW0gYXMgZGxtYWxsb2M6OkFsbG9jYXRvcj46OmZyZWVfcGFydDo6aGM3YTFmOWU1MTg3YWM3YmLpBEc8ZGxtYWxsb2M6OnN5czo6U3lzdGVtIGFzIGRsbWFsbG9jOjpBbGxvY2F0b3I+OjpmcmVlOjpoZDBkMGY2Y2Y2ZmY3MGQyOOoEUzxkbG1hbGxvYzo6c3lzOjpTeXN0ZW0gYXMgZGxtYWxsb2M6OkFsbG9jYXRvcj46OmNhbl9yZWxlYXNlX3BhcnQ6Omg5MzlhYTNiYWIyNGJiYWIw6wRSPGRsbWFsbG9jOjpzeXM6OlN5c3RlbSBhcyBkbG1hbGxvYzo6QWxsb2NhdG9yPjo6YWxsb2NhdGVzX3plcm9zOjpoNjFlMDg1NWU3MDIwN2U2YuwETDxkbG1hbGxvYzo6c3lzOjpTeXN0ZW0gYXMgZGxtYWxsb2M6OkFsbG9jYXRvcj46OnBhZ2Vfc2l6ZTo6aDcwNTc5YzY5YTk2NWZmMzftBDE8VCBhcyBjb3JlOjphbnk6OkFueT46OnR5cGVfaWQ6Omg2MTEyOWZiNjVjNGQzNjll7gRMY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPHN0ZDo6dGhyZWFkOjpsb2NhbDo6QWNjZXNzRXJyb3I+OjpoOTBhMzkxOTNlNTIzNjZkNe8ERGNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxjb3JlOjpjZWxsOjpCb3Jyb3dFcnJvcj46OmhjZDE0ZDU0ZTBlZjJkZDRk8ARzY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPDxjb3JlOjpjZWxsOjpSZWZDZWxsPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6OkJvcnJvd2VkUGxhY2Vob2xkZXI+OjpoODU2ODUzMTk5NmEyYjY5YvEET2NvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTwmbWFya3VwNWV2ZXI6OmludGVyZmFjZTo6QXR0cmlidXRlPjo6aDQ0ZmY1MDAzMDZmZDJhMGbyBE5jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8dGVuZHJpbDo6dGVuZHJpbDo6U3VidGVuZHJpbEVycm9yPjo6aGZlNTFhM2Y2ZjY5ZjVkZTbzBE5jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8JmFsbG9jOjpyYzo6UmM8Y29yZTo6cmNkb206Ok5vZGU+Pjo6aGY4YmQzYmU1ZjExNDE5MmP0BERjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Y29yZTo6Y2VsbDo6Qm9ycm93RXJyb3I+OjpoY2QxNGQ1NGUwZWYyZGQ0ZPUEPWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxjb3JlOjpmbXQ6OkVycm9yPjo6aDc1ZmIxZDZjNmE4YjgyNzT2BEdjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Jm11dCBhbGxvYzo6c3RyaW5nOjpTdHJpbmc+OjpoYzY3ZGJiNzg3NjUxYTQzY/cEMWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTwmdTMyPjo6aGI1OTQ3ZDUwYTQ2NjQ3ODn4BE9jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Jm1hcmt1cDVldmVyOjppbnRlcmZhY2U6OkF0dHJpYnV0ZT46Omg0MDhkYzNhM2VlNzRmOGM3+QRbY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZ0ZW5kcmlsOjp0ZW5kcmlsOjpUZW5kcmlsPHRlbmRyaWw6OmZtdDo6VVRGOD4+OjpoYzNjY2M1ODcxN2M4ZGY2Y/oEMWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxib29sPjo6aDBjN2MwZjE2M2ExNjdkM2P7BFNjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8Jmh0bWw1ZXZlcjo6dG9rZW5pemVyOjpzdGF0ZXM6OlJhd0tpbmQ+OjpoMDhjN2U4MmUzYjUzY2ZhOfwEUmNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTwmaHRtbDVldmVyOjp0b2tlbml6ZXI6OmludGVyZmFjZTo6VGFnPjo6aDA0MDVmMTA1ZDc3YWJiMTf9BDdjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8bG9nOjpMZXZlbD46Omg2MjY5ZDhjYWUyNGQxOWY1/gQ0PGxvZzo6Tm9wTG9nZ2VyIGFzIGxvZzo6TG9nPjo6bG9nOjpoYTZiMGJlNmZlZWM1MjAyZf8ENjxsb2c6Ok5vcExvZ2dlciBhcyBsb2c6OkxvZz46OmZsdXNoOjpoM2MwMjQ1ODUwZjYwODljN4AFhAFjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8JmFsbG9jOjpjb2xsZWN0aW9uczo6dmVjX2RlcXVlOjpWZWNEZXF1ZTx0ZW5kcmlsOjp0ZW5kcmlsOjpUZW5kcmlsPHRlbmRyaWw6OmZtdDo6VVRGOD4+Pjo6aDU0ODVlMWIxNzFjNjFjOTGBBWRjb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8JnN0cmluZ19jYWNoZTo6YXRvbTo6QXRvbTxtYXJrdXA1ZXZlcjo6UHJlZml4U3RhdGljU2V0Pj46OmgxOWNjMDBlYmRmM2VjMzNlggVbY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZ0ZW5kcmlsOjp0ZW5kcmlsOjpUZW5kcmlsPHRlbmRyaWw6OmZtdDo6VVRGOD4+OjpoNjI4ODg5YzY0MGVjZTVkNIMFXGNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTxzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWM6OlBhbmljUGF5bG9hZDwmc3RyPj46OmhkYWJkNjcxMmI1MTJkZGEwhAUxY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPCZzdHI+OjpoYjFmOTFjZWZlYTlkYzE0MYUFfjxwYXJraW5nX2xvdF9jb3JlOjp0aHJlYWRfcGFya2VyOjppbXA6OlRocmVhZFBhcmtlciBhcyBwYXJraW5nX2xvdF9jb3JlOjp0aHJlYWRfcGFya2VyOjpUaHJlYWRQYXJrZXJUPjo6bmV3OjpoODcxNmVjZjQ5NDA0OWQxNYYFaWNvcmU6OnB0cjo6ZHJvcF9pbl9wbGFjZTwmbXV0IHN0ZDo6aW86OldyaXRlOjp3cml0ZV9mbXQ6OkFkYXB0ZXI8YWxsb2M6OnZlYzo6VmVjPHU4Pj4+OjpoMDU0ZmU1ZmRmNGZjMDliZYcFLHN0ZDo6ZnM6Ok9wZW5PcHRpb25zOjpuZXc6Omg0NTM3YzY0OGFlYzI1ZTRhiAUyY29yZTo6cHRyOjpkcm9wX2luX3BsYWNlPHVzaXplPjo6aDg2ZmRmYzMwOWFkNzEyODaJBW9jb3JlOjpwdHI6OmRyb3BfaW5fcGxhY2U8JmNvcmU6Oml0ZXI6OmFkYXB0ZXJzOjpjb3BpZWQ6OkNvcGllZDxjb3JlOjpzbGljZTo6aXRlcjo6SXRlcjx1OD4+Pjo6aDAxOTk1ZmNmMzc5NjFmZDUA+4CAgAAJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjcwLjAgKDkwYzU0MTgwNiAyMDIzLTA1LTMxKQZ3YWxydXMGMC4xOS4wDHdhc20tYmluZGdlbhIwLjIuNzggKDdmODIwZGI0YikArICAgAAPdGFyZ2V0X2ZlYXR1cmVzAisPbXV0YWJsZS1nbG9iYWxzKwhzaWduLWV4dA=="
    ),
    (c) => c.charCodeAt(0)
  );
  const { instance, module: module2 } = await load2(input, imports);
  wasm = instance.exports;
  init.__wbindgen_wasm_module = module2;
  return wasm;
}
var deno_wasm_default = init;

// https://deno.land/x/deno_dom@v0.1.43/src/parser.ts
var parse18 = (_html) => {
  console.error("Error: deno-dom: No parser registered");
  Deno.exit(1);
};
var parseFrag = (_html, _contextLocalName) => {
  console.error("Error: deno-dom: No parser registered");
  Deno.exit(1);
};
var originalParse = parse18;
function register(func2, fragFunc) {
  if (parse18 !== originalParse) {
    return;
  }
  parse18 = func2;
  parseFrag = fragFunc;
}

// https://deno.land/x/deno_dom@v0.1.43/src/constructor-lock.ts
var CTOR_KEY = Symbol();

// https://deno.land/x/deno_dom@v0.1.43/src/dom/html-collection.ts
var HTMLCollectionFakeClass = (() => {
  return class HTMLCollection {
    constructor() {
      throw new TypeError("Illegal constructor");
    }
    static [Symbol.hasInstance](value) {
      return value.constructor === HTMLCollectionClass;
    }
  };
})();
var HTMLCollectionMutatorSym = Symbol();
var HTMLCollectionClass = (() => {
  class HTMLCollection2 extends Array {
    // @ts-ignore
    forEach(cb, thisArg = void 0) {
      super.forEach(cb, thisArg);
    }
    item(index) {
      return this[index] ?? null;
    }
    [HTMLCollectionMutatorSym]() {
      return {
        push: Array.prototype.push.bind(this),
        splice: Array.prototype.splice.bind(this),
        indexOf: Array.prototype.indexOf.bind(this)
      };
    }
    toString() {
      return "[object HTMLCollection]";
    }
  }
  return HTMLCollection2;
})();
for (const staticMethod of [
  "from",
  "isArray",
  "of"
]) {
  HTMLCollectionClass[staticMethod] = void 0;
}
for (const instanceMethod of [
  "concat",
  "copyWithin",
  "every",
  "fill",
  "filter",
  "find",
  "findIndex",
  "flat",
  "flatMap",
  "includes",
  "indexOf",
  "join",
  "lastIndexOf",
  "map",
  "pop",
  "push",
  "reduce",
  "reduceRight",
  "reverse",
  "shift",
  "slice",
  "some",
  "sort",
  "splice",
  "toLocaleString",
  "unshift",
  // Unlike NodeList, HTMLCollection also doesn't implement these
  "entries",
  "forEach",
  "keys",
  "values"
]) {
  HTMLCollectionClass.prototype[instanceMethod] = void 0;
}
var HTMLCollection = HTMLCollectionClass;

// https://deno.land/x/deno_dom@v0.1.43/src/dom/node-list.ts
var NodeListFakeClass = (() => {
  return class NodeList {
    constructor() {
      throw new TypeError("Illegal constructor");
    }
    static [Symbol.hasInstance](value) {
      return value.constructor === NodeListClass;
    }
  };
})();
var nodeListMutatorSym = Symbol();
var nodeListCachedMutator = Symbol();
var { push, splice, slice, indexOf, filter } = Array.prototype;
var NodeListMutatorImpl = class {
  constructor(arrayInstance) {
    this.arrayInstance = arrayInstance;
  }
  // There should only ever be one elementView per element. Element views
  // are basically just the source of HTMLCollections/.children properties
  // on elements that are always in sync with their .childNodes counterpart.
  elementViews = [];
  push(...items) {
    for (const view of this.elementViews) {
      for (const item of items) {
        if (item.nodeType === Node.ELEMENT_NODE) {
          push.call(view, item);
        }
      }
    }
    return push.call(this.arrayInstance, ...items);
  }
  splice(index, deleteCount = 0, ...items) {
    for (const view of this.elementViews) {
      const toDelete = filter.call(
        slice.call(this.arrayInstance, index, index + deleteCount),
        (item) => item.nodeType === Node.ELEMENT_NODE
      );
      const toInsert = items.filter(
        (item) => item.nodeType === Node.ELEMENT_NODE
      );
      let elementViewSpliceIndex = -1;
      for (let idx = index; idx < this.arrayInstance.length; idx++) {
        const item = this.arrayInstance[idx];
        if (item.nodeType === Node.ELEMENT_NODE) {
          elementViewSpliceIndex = indexOf.call(view, item);
          break;
        }
      }
      if (elementViewSpliceIndex === -1) {
        elementViewSpliceIndex = view.length;
      }
      if (toDelete.length) {
        splice.call(view, elementViewSpliceIndex, toDelete.length);
      }
      splice.call(view, elementViewSpliceIndex, 0, ...toInsert);
    }
    return splice.call(this.arrayInstance, index, deleteCount, ...items);
  }
  indexOf(item, fromIndex = 0) {
    return indexOf.call(this.arrayInstance, item, fromIndex);
  }
  indexOfElementsView(item, fromIndex = 0) {
    return indexOf.call(this.elementsView(), item, fromIndex);
  }
  // Return the elements-only view for this NodeList. Creates one if
  // it doesn't already exist.
  elementsView() {
    let view = this.elementViews[0];
    if (!view) {
      view = new HTMLCollection();
      this.elementViews.push(view);
      push.call(
        view,
        ...filter.call(
          this.arrayInstance,
          (item) => item.nodeType === Node.ELEMENT_NODE
        )
      );
    }
    return view;
  }
};
var NodeListClass = (() => {
  class NodeList2 extends Array {
    // @ts-ignore
    forEach(cb, thisArg = void 0) {
      super.forEach(cb, thisArg);
    }
    item(index) {
      return this[index] ?? null;
    }
    [nodeListMutatorSym]() {
      const cachedMutator = this[nodeListCachedMutator];
      if (cachedMutator) {
        return cachedMutator;
      } else {
        const cachedMutator2 = new NodeListMutatorImpl(this);
        this[nodeListCachedMutator] = cachedMutator2;
        return cachedMutator2;
      }
    }
    toString() {
      return "[object NodeList]";
    }
  }
  return NodeList2;
})();
for (const staticMethod of [
  "from",
  "isArray",
  "of"
]) {
  NodeListClass[staticMethod] = void 0;
}
for (const instanceMethod of [
  "concat",
  "copyWithin",
  "every",
  "fill",
  "filter",
  "find",
  "findIndex",
  "flat",
  "flatMap",
  "includes",
  "indexOf",
  "join",
  "lastIndexOf",
  "map",
  "pop",
  "push",
  "reduce",
  "reduceRight",
  "reverse",
  "shift",
  "slice",
  "some",
  "sort",
  "splice",
  "toLocaleString",
  "unshift"
]) {
  NodeListClass.prototype[instanceMethod] = void 0;
}
var NodeList = NodeListClass;

// https://deno.land/x/deno_dom@v0.1.43/src/dom/utils-types.ts
var utils_types_default = {
  Element: null,
  Document: null,
  DocumentFragment: null
};

// https://deno.land/x/deno_dom@v0.1.43/src/dom/utils.ts
var upperCaseCharRe = /[A-Z]/;
var lowerCaseCharRe = /[a-z]/;
function getDatasetHtmlAttrName(name) {
  let attributeName = "data-";
  for (const char of name) {
    if (upperCaseCharRe.test(char)) {
      attributeName += "-" + char.toLowerCase();
    } else {
      attributeName += char;
    }
  }
  return attributeName;
}
function getDatasetJavascriptName(name) {
  let javascriptName = "";
  let prevChar = "";
  for (const char of name.slice("data-".length)) {
    if (prevChar === "-" && lowerCaseCharRe.test(char)) {
      javascriptName += char.toUpperCase();
      prevChar = "";
    } else {
      javascriptName += prevChar;
      prevChar = char;
    }
  }
  return javascriptName + prevChar;
}
function getElementsByClassName(element, className, search2) {
  for (const child of element.childNodes) {
    if (child.nodeType === 1 /* ELEMENT_NODE */) {
      const classList = className.trim().split(/\s+/);
      let matchesCount = 0;
      for (const singleClassName of classList) {
        if (child.classList.contains(singleClassName)) {
          matchesCount++;
        }
      }
      if (matchesCount === classList.length) {
        search2.push(child);
      }
      getElementsByClassName(child, className, search2);
    }
  }
  return search2;
}
function getOuterHTMLOpeningTag(parentElement) {
  return "<" + parentElement.localName + getElementAttributesString(parentElement) + ">";
}
var voidElements = /* @__PURE__ */ new Set([
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function getOuterOrInnerHtml(parentElement, asOuterHtml) {
  let outerHTMLOpeningTag = "";
  let outerHTMLClosingTag = "";
  let innerHTML = "";
  if (asOuterHtml) {
    outerHTMLOpeningTag = getOuterHTMLOpeningTag(parentElement);
    outerHTMLClosingTag = `</${parentElement.localName}>`;
    if (voidElements.has(parentElement.localName)) {
      return outerHTMLOpeningTag;
    }
  }
  const initialChildNodes = parentElement.localName === "template" ? parentElement.content.childNodes : parentElement.childNodes;
  const childNodeDepth = [initialChildNodes];
  const indexDepth = [0];
  const closingTagDepth = [outerHTMLClosingTag];
  let depth = 0;
  depthLoop:
    while (depth > -1) {
      const child = childNodeDepth[depth][indexDepth[depth]];
      if (child) {
        switch (child.nodeType) {
          case 1 /* ELEMENT_NODE */: {
            innerHTML += getOuterHTMLOpeningTag(child);
            const childLocalName = child.localName;
            if (!voidElements.has(childLocalName)) {
              if (childLocalName === "template") {
                childNodeDepth.push(
                  child.content.childNodes
                );
              } else {
                childNodeDepth.push(child.childNodes);
              }
              indexDepth.push(0);
              closingTagDepth.push(`</${childLocalName}>`);
              depth++;
              continue depthLoop;
            }
            break;
          }
          case 8 /* COMMENT_NODE */:
            innerHTML += `<!--${child.data}-->`;
            break;
          case 3 /* TEXT_NODE */:
            switch (child.parentNode.localName) {
              case "style":
              case "script":
              case "xmp":
              case "iframe":
              case "noembed":
              case "noframes":
              case "plaintext":
                innerHTML += child.data;
                break;
              default:
                innerHTML += child.data.replace(/&/g, "&amp;").replace(/\xA0/g, "&nbsp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                break;
            }
            break;
        }
      } else {
        depth--;
        indexDepth.pop();
        childNodeDepth.pop();
        innerHTML += closingTagDepth.pop();
      }
      indexDepth[depth]++;
    }
  return outerHTMLOpeningTag + innerHTML;
}
function getElementAttributesString(element) {
  let out = "";
  for (const attribute of element.getAttributeNames()) {
    out += ` ${attribute.toLowerCase()}`;
    out += `="${element.getAttribute(attribute).replace(/&/g, "&amp;").replace(/\xA0/g, "&nbsp;").replace(/"/g, "&quot;")}"`;
  }
  return out;
}
function insertBeforeAfter(node, nodes, before) {
  const parentNode = node.parentNode;
  const mutator = parentNode._getChildNodesMutator();
  let viablePrevNextSibling = null;
  {
    const difference = before ? -1 : 1;
    for (let i2 = mutator.indexOf(node) + difference; 0 <= i2 && i2 < parentNode.childNodes.length; i2 += difference) {
      if (!nodes.includes(parentNode.childNodes[i2])) {
        viablePrevNextSibling = parentNode.childNodes[i2];
        break;
      }
    }
  }
  nodes = nodesAndTextNodes(nodes, parentNode);
  let index;
  if (viablePrevNextSibling) {
    index = mutator.indexOf(viablePrevNextSibling) + (before ? 1 : 0);
  } else {
    index = before ? 0 : parentNode.childNodes.length;
  }
  mutator.splice(index, 0, ...nodes);
}
function isDocumentFragment(node) {
  let obj = node;
  if (!(obj && typeof obj === "object")) {
    return false;
  }
  while (true) {
    switch (obj.constructor) {
      case utils_types_default.DocumentFragment:
        return true;
      case Node:
      case utils_types_default.Element:
        return false;
      case Object:
      case null:
      case void 0:
        return false;
      default:
        obj = Reflect.getPrototypeOf(obj);
    }
  }
}
function moveDocumentFragmentChildren(fragment, newParent) {
  const childCount = fragment.childNodes.length;
  for (const child of fragment.childNodes) {
    child._setParent(newParent);
  }
  const mutator = fragment._getChildNodesMutator();
  mutator.splice(0, childCount);
}

// https://deno.land/x/deno_dom@v0.1.43/src/dom/node.ts
var nodesAndTextNodes = (nodes, parentNode) => {
  return nodes.flatMap((n) => {
    if (isDocumentFragment(n)) {
      const children = Array.from(n.childNodes);
      moveDocumentFragmentChildren(n, parentNode);
      return children;
    } else {
      const node = n instanceof Node ? n : new Text2("" + n);
      if (n === node && parentNode) {
        parentNode._assertNotAncestor(node);
      }
      node._remove(true);
      node._setParent(parentNode, true);
      return [node];
    }
  });
};
var Node = class _Node extends EventTarget {
  constructor(nodeName, nodeType, parentNode, key) {
    if (key !== CTOR_KEY) {
      throw new TypeError("Illegal constructor.");
    }
    super();
    this.nodeName = nodeName;
    this.nodeType = nodeType;
    this.#nodeValue = null;
    this.childNodes = new NodeList();
    this.#childNodesMutator = this.childNodes[nodeListMutatorSym]();
    this.parentElement = parentNode;
    if (parentNode) {
      parentNode.appendChild(this);
    }
  }
  #nodeValue = null;
  childNodes;
  parentNode = null;
  parentElement;
  #childNodesMutator;
  #ownerDocument = null;
  _ancestors = /* @__PURE__ */ new Set();
  // Instance constants defined after Node
  // class body below to avoid clutter
  static ELEMENT_NODE = 1 /* ELEMENT_NODE */;
  static ATTRIBUTE_NODE = 2 /* ATTRIBUTE_NODE */;
  static TEXT_NODE = 3 /* TEXT_NODE */;
  static CDATA_SECTION_NODE = 4 /* CDATA_SECTION_NODE */;
  static ENTITY_REFERENCE_NODE = 5 /* ENTITY_REFERENCE_NODE */;
  static ENTITY_NODE = 6 /* ENTITY_NODE */;
  static PROCESSING_INSTRUCTION_NODE = 7 /* PROCESSING_INSTRUCTION_NODE */;
  static COMMENT_NODE = 8 /* COMMENT_NODE */;
  static DOCUMENT_NODE = 9 /* DOCUMENT_NODE */;
  static DOCUMENT_TYPE_NODE = 10 /* DOCUMENT_TYPE_NODE */;
  static DOCUMENT_FRAGMENT_NODE = 11 /* DOCUMENT_FRAGMENT_NODE */;
  static NOTATION_NODE = 12 /* NOTATION_NODE */;
  _getChildNodesMutator() {
    return this.#childNodesMutator;
  }
  /**
   * Update ancestor chain & owner document for this child
   * and all its children.
   */
  _setParent(newParent, force = false) {
    const sameParent = this.parentNode === newParent;
    const shouldUpdateParentAndAncestors = !sameParent || force;
    if (shouldUpdateParentAndAncestors) {
      this.parentNode = newParent;
      if (newParent) {
        if (!sameParent) {
          if (newParent.nodeType === 1 /* ELEMENT_NODE */) {
            this.parentElement = newParent;
          } else {
            this.parentElement = null;
          }
          this._setOwnerDocument(newParent.#ownerDocument);
        }
        this._ancestors = new Set(newParent._ancestors);
        this._ancestors.add(newParent);
      } else {
        this.parentElement = null;
        this._ancestors.clear();
      }
      for (const child of this.childNodes) {
        child._setParent(this, shouldUpdateParentAndAncestors);
      }
    }
  }
  _assertNotAncestor(child) {
    if (child.contains(this)) {
      throw new DOMException("The new child is an ancestor of the parent");
    }
  }
  _setOwnerDocument(document2) {
    if (this.#ownerDocument !== document2) {
      this.#ownerDocument = document2;
      for (const child of this.childNodes) {
        child._setOwnerDocument(document2);
      }
    }
  }
  contains(child) {
    return child._ancestors.has(this) || child === this;
  }
  get ownerDocument() {
    return this.#ownerDocument;
  }
  get nodeValue() {
    return this.#nodeValue;
  }
  set nodeValue(value) {
  }
  get textContent() {
    let out = "";
    for (const child of this.childNodes) {
      switch (child.nodeType) {
        case 3 /* TEXT_NODE */:
          out += child.nodeValue;
          break;
        case 1 /* ELEMENT_NODE */:
          out += child.textContent;
          break;
      }
    }
    return out;
  }
  set textContent(content) {
    for (const child of this.childNodes) {
      child._setParent(null);
    }
    this._getChildNodesMutator().splice(0, this.childNodes.length);
    this.appendChild(new Text2(content));
  }
  get firstChild() {
    return this.childNodes[0] || null;
  }
  get lastChild() {
    return this.childNodes[this.childNodes.length - 1] || null;
  }
  hasChildNodes() {
    return Boolean(this.childNodes.length);
  }
  cloneNode(deep = false) {
    const copy7 = this._shallowClone();
    copy7._setOwnerDocument(this.ownerDocument);
    if (deep) {
      for (const child of this.childNodes) {
        copy7.appendChild(child.cloneNode(true));
      }
    }
    return copy7;
  }
  _shallowClone() {
    throw new Error("Illegal invocation");
  }
  _remove(skipSetParent = false) {
    const parent = this.parentNode;
    if (parent) {
      const nodeList = parent._getChildNodesMutator();
      const idx = nodeList.indexOf(this);
      nodeList.splice(idx, 1);
      if (!skipSetParent) {
        this._setParent(null);
      }
    }
  }
  appendChild(child) {
    if (isDocumentFragment(child)) {
      const mutator = this._getChildNodesMutator();
      mutator.push(...child.childNodes);
      moveDocumentFragmentChildren(child, this);
      return child;
    } else {
      return child._appendTo(this);
    }
  }
  _appendTo(parentNode) {
    parentNode._assertNotAncestor(this);
    const oldParentNode = this.parentNode;
    if (oldParentNode === parentNode) {
      if (parentNode._getChildNodesMutator().indexOf(this) !== -1) {
        return this;
      }
    } else if (oldParentNode) {
      this._remove();
    }
    this._setParent(parentNode, true);
    parentNode._getChildNodesMutator().push(this);
    return this;
  }
  removeChild(child) {
    if (child && typeof child === "object") {
      if (child.parentNode === this) {
        child._remove();
        return child;
      } else {
        throw new DOMException(
          "Node.removeChild: The node to be removed is not a child of this node"
        );
      }
    } else {
      throw new TypeError("Node.removeChild: Argument 1 is not an object.");
    }
  }
  replaceChild(newChild, oldChild) {
    if (oldChild.parentNode !== this) {
      throw new Error("Old child's parent is not the current node.");
    }
    oldChild._replaceWith(newChild);
    return oldChild;
  }
  insertBefore(newNode, refNode) {
    this._assertNotAncestor(newNode);
    const mutator = this._getChildNodesMutator();
    if (refNode === null) {
      this.appendChild(newNode);
      return newNode;
    }
    const index = mutator.indexOf(refNode);
    if (index === -1) {
      throw new Error(
        "DOMException: Child to insert before is not a child of this node"
      );
    }
    if (isDocumentFragment(newNode)) {
      mutator.splice(index, 0, ...newNode.childNodes);
      moveDocumentFragmentChildren(newNode, this);
    } else {
      const oldParentNode = newNode.parentNode;
      const oldMutator = oldParentNode?._getChildNodesMutator();
      if (oldMutator) {
        oldMutator.splice(oldMutator.indexOf(newNode), 1);
      }
      newNode._setParent(this, oldParentNode !== this);
      mutator.splice(index, 0, newNode);
    }
    return newNode;
  }
  _replaceWith(...nodes) {
    if (this.parentNode) {
      const parentNode = this.parentNode;
      const mutator = parentNode._getChildNodesMutator();
      let viableNextSibling = null;
      {
        const thisIndex = mutator.indexOf(this);
        for (let i2 = thisIndex + 1; i2 < parentNode.childNodes.length; i2++) {
          if (!nodes.includes(parentNode.childNodes[i2])) {
            viableNextSibling = parentNode.childNodes[i2];
            break;
          }
        }
      }
      nodes = nodesAndTextNodes(nodes, parentNode);
      let index = viableNextSibling ? mutator.indexOf(viableNextSibling) : parentNode.childNodes.length;
      let deleteNumber;
      if (parentNode.childNodes[index - 1] === this) {
        index--;
        deleteNumber = 1;
      } else {
        deleteNumber = 0;
      }
      mutator.splice(index, deleteNumber, ...nodes);
      this._setParent(null);
    }
  }
  get nextSibling() {
    const parent = this.parentNode;
    if (!parent) {
      return null;
    }
    const index = parent._getChildNodesMutator().indexOf(this);
    const next = parent.childNodes[index + 1] || null;
    return next;
  }
  get previousSibling() {
    const parent = this.parentNode;
    if (!parent) {
      return null;
    }
    const index = parent._getChildNodesMutator().indexOf(this);
    const prev = parent.childNodes[index - 1] || null;
    return prev;
  }
  // Node.compareDocumentPosition()'s bitmask values
  static DOCUMENT_POSITION_DISCONNECTED = 1;
  static DOCUMENT_POSITION_PRECEDING = 2;
  static DOCUMENT_POSITION_FOLLOWING = 4;
  static DOCUMENT_POSITION_CONTAINS = 8;
  static DOCUMENT_POSITION_CONTAINED_BY = 16;
  static DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
  /**
   * FIXME: Does not implement attribute node checks
   * ref: https://dom.spec.whatwg.org/#dom-node-comparedocumentposition
   * MDN: https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
   */
  compareDocumentPosition(other) {
    if (other === this) {
      return 0;
    }
    if (!(other instanceof _Node)) {
      throw new TypeError(
        "Node.compareDocumentPosition: Argument 1 does not implement interface Node."
      );
    }
    let node1Root = other;
    let node2Root = this;
    const node1Hierarchy = [node1Root];
    const node2Hierarchy = [node2Root];
    while (node1Root.parentNode ?? node2Root.parentNode) {
      node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
      node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
    }
    if (node1Root !== node2Root) {
      return _Node.DOCUMENT_POSITION_DISCONNECTED | _Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | _Node.DOCUMENT_POSITION_PRECEDING;
    }
    const longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
    const shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
    if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
      return longerHierarchy === node1Hierarchy ? _Node.DOCUMENT_POSITION_CONTAINED_BY | _Node.DOCUMENT_POSITION_FOLLOWING : _Node.DOCUMENT_POSITION_CONTAINS | _Node.DOCUMENT_POSITION_PRECEDING;
    }
    const longerStart = longerHierarchy.length - shorterHierarchy.length;
    for (let i2 = shorterHierarchy.length - 1; i2 >= 0; i2--) {
      const shorterHierarchyNode = shorterHierarchy[i2];
      const longerHierarchyNode = longerHierarchy[longerStart + i2];
      if (longerHierarchyNode !== shorterHierarchyNode) {
        const siblings = shorterHierarchyNode.parentNode._getChildNodesMutator();
        if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
          if (shorterHierarchy === node1Hierarchy) {
            return _Node.DOCUMENT_POSITION_PRECEDING;
          } else {
            return _Node.DOCUMENT_POSITION_FOLLOWING;
          }
        } else {
          if (longerHierarchy === node1Hierarchy) {
            return _Node.DOCUMENT_POSITION_PRECEDING;
          } else {
            return _Node.DOCUMENT_POSITION_FOLLOWING;
          }
        }
      }
    }
    return _Node.DOCUMENT_POSITION_FOLLOWING;
  }
  getRootNode(opts = {}) {
    if (this.parentNode) {
      return this.parentNode.getRootNode(opts);
    }
    if (opts.composed && this.host) {
      return this.host.getRootNode(opts);
    }
    return this;
  }
};
Node.prototype.ELEMENT_NODE = 1 /* ELEMENT_NODE */;
Node.prototype.ATTRIBUTE_NODE = 2 /* ATTRIBUTE_NODE */;
Node.prototype.TEXT_NODE = 3 /* TEXT_NODE */;
Node.prototype.CDATA_SECTION_NODE = 4 /* CDATA_SECTION_NODE */;
Node.prototype.ENTITY_REFERENCE_NODE = 5 /* ENTITY_REFERENCE_NODE */;
Node.prototype.ENTITY_NODE = 6 /* ENTITY_NODE */;
Node.prototype.PROCESSING_INSTRUCTION_NODE = 7 /* PROCESSING_INSTRUCTION_NODE */;
Node.prototype.COMMENT_NODE = 8 /* COMMENT_NODE */;
Node.prototype.DOCUMENT_NODE = 9 /* DOCUMENT_NODE */;
Node.prototype.DOCUMENT_TYPE_NODE = 10 /* DOCUMENT_TYPE_NODE */;
Node.prototype.DOCUMENT_FRAGMENT_NODE = 11 /* DOCUMENT_FRAGMENT_NODE */;
Node.prototype.NOTATION_NODE = 12 /* NOTATION_NODE */;
var CharacterData = class extends Node {
  #nodeValue = "";
  constructor(data, nodeName, nodeType, parentNode, key) {
    super(
      nodeName,
      nodeType,
      parentNode,
      key
    );
    this.#nodeValue = data;
  }
  get nodeValue() {
    return this.#nodeValue;
  }
  set nodeValue(value) {
    this.#nodeValue = String(value ?? "");
  }
  get data() {
    return this.#nodeValue;
  }
  set data(value) {
    this.nodeValue = value;
  }
  get textContent() {
    return this.#nodeValue;
  }
  set textContent(value) {
    this.nodeValue = value;
  }
  get length() {
    return this.data.length;
  }
  before(...nodes) {
    if (this.parentNode) {
      insertBeforeAfter(this, nodes, true);
    }
  }
  after(...nodes) {
    if (this.parentNode) {
      insertBeforeAfter(this, nodes, false);
    }
  }
  remove() {
    this._remove();
  }
  replaceWith(...nodes) {
    this._replaceWith(...nodes);
  }
  // TODO: Implement NonDocumentTypeChildNode.nextElementSibling, etc
  // ref: https://developer.mozilla.org/en-US/docs/Web/API/CharacterData
};
var Text2 = class _Text extends CharacterData {
  constructor(text = "") {
    super(
      String(text),
      "#text",
      3 /* TEXT_NODE */,
      null,
      CTOR_KEY
    );
  }
  _shallowClone() {
    return new _Text(this.textContent);
  }
  get textContent() {
    return this.nodeValue;
  }
};
var Comment2 = class _Comment extends CharacterData {
  constructor(text = "") {
    super(
      String(text),
      "#comment",
      8 /* COMMENT_NODE */,
      null,
      CTOR_KEY
    );
  }
  _shallowClone() {
    return new _Comment(this.textContent);
  }
  get textContent() {
    return this.nodeValue;
  }
};

// https://deno.land/x/deno_dom@v0.1.43/src/dom/element.ts
var DOMTokenList = class _DOMTokenList {
  #_value = "";
  get #value() {
    return this.#_value;
  }
  set #value(value) {
    this.#_value = value;
    this.#onChange(value);
  }
  #set = /* @__PURE__ */ new Set();
  #onChange;
  constructor(onChange, key) {
    if (key !== CTOR_KEY) {
      throw new TypeError("Illegal constructor");
    }
    this.#onChange = onChange;
  }
  static #invalidToken(token) {
    return token === "" || /[\t\n\f\r ]/.test(token);
  }
  #setIndices() {
    const classes = Array.from(this.#set);
    for (let i2 = 0; i2 < classes.length; i2++) {
      this[i2] = classes[i2];
    }
  }
  set value(input) {
    this.#value = input;
    this.#set = new Set(
      input.trim().split(/[\t\n\f\r\s]+/g).filter(Boolean)
    );
    this.#setIndices();
  }
  get value() {
    return this.#_value;
  }
  get length() {
    return this.#set.size;
  }
  *entries() {
    const array = Array.from(this.#set);
    for (let i2 = 0; i2 < array.length; i2++) {
      yield [i2, array[i2]];
    }
  }
  *values() {
    yield* this.#set.values();
  }
  *keys() {
    for (let i2 = 0; i2 < this.#set.size; i2++) {
      yield i2;
    }
  }
  *[Symbol.iterator]() {
    yield* this.#set.values();
  }
  item(index) {
    index = Number(index);
    if (Number.isNaN(index) || index === Infinity)
      index = 0;
    return this[Math.trunc(index) % 2 ** 32] ?? null;
  }
  contains(element) {
    return this.#set.has(element);
  }
  add(...elements) {
    for (const element of elements) {
      if (_DOMTokenList.#invalidToken(element)) {
        throw new DOMException(
          "Failed to execute 'add' on 'DOMTokenList': The token provided must not be empty."
        );
      }
      const { size } = this.#set;
      this.#set.add(element);
      if (size < this.#set.size) {
        this[size] = element;
      }
    }
    this.#updateClassString();
  }
  remove(...elements) {
    const { size } = this.#set;
    for (const element of elements) {
      if (_DOMTokenList.#invalidToken(element)) {
        throw new DOMException(
          "Failed to execute 'remove' on 'DOMTokenList': The token provided must not be empty."
        );
      }
      this.#set.delete(element);
    }
    if (size !== this.#set.size) {
      for (let i2 = this.#set.size; i2 < size; i2++) {
        delete this[i2];
      }
      this.#setIndices();
    }
    this.#updateClassString();
  }
  replace(oldToken, newToken) {
    if ([oldToken, newToken].some((v) => _DOMTokenList.#invalidToken(v))) {
      throw new DOMException(
        "Failed to execute 'replace' on 'DOMTokenList': The token provided must not be empty."
      );
    }
    if (!this.#set.has(oldToken)) {
      return false;
    }
    if (this.#set.has(newToken)) {
      this.remove(oldToken);
    } else {
      this.#set.delete(oldToken);
      this.#set.add(newToken);
      this.#setIndices();
      this.#updateClassString();
    }
    return true;
  }
  supports() {
    throw new Error("Not implemented");
  }
  toggle(element, force) {
    if (force !== void 0) {
      const operation = force ? "add" : "remove";
      this[operation](element);
      return false;
    } else {
      const contains = this.contains(element);
      const operation = contains ? "remove" : "add";
      this[operation](element);
      return !contains;
    }
  }
  forEach(callback) {
    for (const [i2, value] of this.entries()) {
      callback(value, i2, this);
    }
  }
  #updateClassString() {
    this.#value = Array.from(this.#set).join(" ");
  }
};
var setNamedNodeMapOwnerElementSym = Symbol();
var setAttrValueSym = Symbol();
var Attr = class _Attr extends Node {
  #namedNodeMap = null;
  #name = "";
  #value = "";
  #ownerElement = null;
  constructor(map2, name, value, key) {
    if (key !== CTOR_KEY) {
      throw new TypeError("Illegal constructor");
    }
    super(name, 2 /* ATTRIBUTE_NODE */, null, CTOR_KEY);
    this.#name = name;
    this.#value = value;
    this.#namedNodeMap = map2;
  }
  [setNamedNodeMapOwnerElementSym](ownerElement) {
    this.#ownerElement = ownerElement;
    this.#namedNodeMap = ownerElement?.attributes ?? null;
    if (ownerElement) {
      this._setOwnerDocument(ownerElement.ownerDocument);
    }
  }
  [setAttrValueSym](value) {
    this.#value = value;
  }
  _shallowClone() {
    const newAttr = new _Attr(null, this.#name, this.#value, CTOR_KEY);
    newAttr._setOwnerDocument(this.ownerDocument);
    return newAttr;
  }
  cloneNode() {
    return super.cloneNode();
  }
  appendChild() {
    throw new DOMException("Cannot add children to an Attribute");
  }
  replaceChild() {
    throw new DOMException("Cannot add children to an Attribute");
  }
  insertBefore() {
    throw new DOMException("Cannot add children to an Attribute");
  }
  removeChild() {
    throw new DOMException(
      "The node to be removed is not a child of this node"
    );
  }
  get name() {
    return this.#name;
  }
  get localName() {
    return this.#name;
  }
  get value() {
    return this.#value;
  }
  set value(value) {
    this.#value = String(value);
    if (this.#namedNodeMap) {
      this.#namedNodeMap[setNamedNodeMapValueSym](
        this.#name,
        this.#value,
        true
      );
    }
  }
  get ownerElement() {
    return this.#ownerElement ?? null;
  }
  get specified() {
    return true;
  }
  // TODO
  get prefix() {
    return null;
  }
};
var setNamedNodeMapValueSym = Symbol();
var getNamedNodeMapValueSym = Symbol();
var getNamedNodeMapAttrNamesSym = Symbol();
var getNamedNodeMapAttrNodeSym = Symbol();
var removeNamedNodeMapAttrSym = Symbol();
var NamedNodeMap = class _NamedNodeMap {
  static #indexedAttrAccess = function(map2, index) {
    if (index + 1 > this.length) {
      return void 0;
    }
    const attribute = Object.keys(map2).filter((attribute2) => map2[attribute2] !== void 0)[index]?.slice(1);
    return this[getNamedNodeMapAttrNodeSym](attribute);
  };
  #onAttrNodeChange;
  constructor(ownerElement, onAttrNodeChange, key) {
    if (key !== CTOR_KEY) {
      throw new TypeError("Illegal constructor.");
    }
    this.#ownerElement = ownerElement;
    this.#onAttrNodeChange = onAttrNodeChange;
  }
  #attrNodeCache = {};
  #map = {};
  #length = 0;
  #capacity = 0;
  #ownerElement = null;
  [getNamedNodeMapAttrNodeSym](attribute) {
    const safeAttrName = "a" + attribute;
    let attrNode = this.#attrNodeCache[safeAttrName];
    if (!attrNode) {
      attrNode = this.#attrNodeCache[safeAttrName] = new Attr(
        this,
        attribute,
        this.#map[safeAttrName],
        CTOR_KEY
      );
      attrNode[setNamedNodeMapOwnerElementSym](this.#ownerElement);
    }
    return attrNode;
  }
  [getNamedNodeMapAttrNamesSym]() {
    const names = [];
    for (const [name, value] of Object.entries(this.#map)) {
      if (value !== void 0) {
        names.push(name.slice(1));
      }
    }
    return names;
  }
  [getNamedNodeMapValueSym](attribute) {
    const safeAttrName = "a" + attribute;
    return this.#map[safeAttrName];
  }
  [setNamedNodeMapValueSym](attribute, value, bubble = false) {
    const safeAttrName = "a" + attribute;
    if (this.#map[safeAttrName] === void 0) {
      this.#length++;
      if (this.#length > this.#capacity) {
        this.#capacity = this.#length;
        const index = this.#capacity - 1;
        Object.defineProperty(this, String(this.#capacity - 1), {
          get: _NamedNodeMap.#indexedAttrAccess.bind(this, this.#map, index)
        });
      }
    } else if (this.#attrNodeCache[safeAttrName]) {
      this.#attrNodeCache[safeAttrName][setAttrValueSym](value);
    }
    this.#map[safeAttrName] = value;
    if (bubble) {
      this.#onAttrNodeChange(attribute, value);
    }
  }
  /**
   * Called when an attribute is removed from
   * an element
   */
  [removeNamedNodeMapAttrSym](attribute) {
    const safeAttrName = "a" + attribute;
    if (this.#map[safeAttrName] !== void 0) {
      this.#length--;
      this.#map[safeAttrName] = void 0;
      this.#onAttrNodeChange(attribute, null);
      const attrNode = this.#attrNodeCache[safeAttrName];
      if (attrNode) {
        attrNode[setNamedNodeMapOwnerElementSym](null);
        this.#attrNodeCache[safeAttrName] = void 0;
      }
    }
  }
  *[Symbol.iterator]() {
    for (let i2 = 0; i2 < this.length; i2++) {
      yield this[i2];
    }
  }
  get length() {
    return this.#length;
  }
  // FIXME: This method should accept anything and basically
  // coerce any non numbers (and Infinity/-Infinity) into 0
  item(index) {
    if (index >= this.#length) {
      return null;
    }
    return this[index];
  }
  getNamedItem(attribute) {
    const safeAttrName = "a" + attribute;
    if (this.#map[safeAttrName] !== void 0) {
      return this[getNamedNodeMapAttrNodeSym](attribute);
    }
    return null;
  }
  setNamedItem(attrNode) {
    if (attrNode.ownerElement) {
      throw new DOMException("Attribute already in use");
    }
    const safeAttrName = "a" + attrNode.name;
    const previousAttr = this.#attrNodeCache[safeAttrName];
    if (previousAttr) {
      previousAttr[setNamedNodeMapOwnerElementSym](null);
      this.#map[safeAttrName] = void 0;
    }
    attrNode[setNamedNodeMapOwnerElementSym](this.#ownerElement);
    this.#attrNodeCache[safeAttrName] = attrNode;
    this[setNamedNodeMapValueSym](attrNode.name, attrNode.value, true);
  }
  removeNamedItem(attribute) {
    const safeAttrName = "a" + attribute;
    if (this.#map[safeAttrName] !== void 0) {
      const attrNode = this[getNamedNodeMapAttrNodeSym](attribute);
      this[removeNamedNodeMapAttrSym](attribute);
      return attrNode;
    }
    throw new DOMException("Node was not found");
  }
};
var XML_NAMESTART_CHAR_RE_SRC = ":A-Za-z_" + String.raw`\u{C0}-\u{D6}\u{D8}-\u{F6}\u{F8}-\u{2FF}\u{370}-\u{37D}` + String.raw`\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}` + String.raw`\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}`;
var XML_NAME_CHAR_RE_SRC = XML_NAMESTART_CHAR_RE_SRC + String.raw`\u{B7}\u{0300}-\u{036F}\u{203F}-\u{2040}0-9.-`;
var xmlNamestartCharRe = new RegExp(`[${XML_NAMESTART_CHAR_RE_SRC}]`, "u");
var xmlNameCharRe = new RegExp(`[${XML_NAME_CHAR_RE_SRC}]`, "u");
var Element2 = class _Element extends Node {
  constructor(tagName, parentNode, attributes, key) {
    super(
      tagName,
      1 /* ELEMENT_NODE */,
      parentNode,
      key
    );
    this.tagName = tagName;
    for (const attr of attributes) {
      this.setAttribute(attr[0], attr[1]);
      switch (attr[0]) {
        case "class":
          this.#classList.value = attr[1];
          break;
        case "id":
          this.#currentId = attr[1];
          break;
      }
    }
    this.tagName = this.nodeName = tagName.toUpperCase();
    this.localName = tagName.toLowerCase();
  }
  localName;
  attributes = new NamedNodeMap(this, (attribute, value) => {
    if (value === null) {
      value = "";
    }
    switch (attribute) {
      case "class":
        this.#classList.value = value;
        break;
      case "id":
        this.#currentId = value;
        break;
    }
  }, CTOR_KEY);
  #datasetProxy = null;
  #currentId = "";
  #classList = new DOMTokenList(
    (className) => {
      if (this.hasAttribute("class") || className !== "") {
        this.attributes[setNamedNodeMapValueSym]("class", className);
      }
    },
    CTOR_KEY
  );
  _shallowClone() {
    const attributes = [];
    for (const attribute of this.getAttributeNames()) {
      attributes.push([attribute, this.getAttribute(attribute)]);
    }
    return new _Element(this.nodeName, null, attributes, CTOR_KEY);
  }
  get childElementCount() {
    return this._getChildNodesMutator().elementsView().length;
  }
  get className() {
    return this.getAttribute("class") ?? "";
  }
  set className(className) {
    this.setAttribute("class", className);
    this.#classList.value = className;
  }
  get classList() {
    return this.#classList;
  }
  get outerHTML() {
    return getOuterOrInnerHtml(this, true);
  }
  set outerHTML(html) {
    if (this.parentNode) {
      const { parentElement, parentNode } = this;
      let contextLocalName = parentElement?.localName;
      switch (parentNode.nodeType) {
        case 9 /* DOCUMENT_NODE */: {
          throw new DOMException(
            "Modifications are not allowed for this document"
          );
        }
        case 11 /* DOCUMENT_FRAGMENT_NODE */: {
          contextLocalName = "body";
        }
        default: {
          const { childNodes: newChildNodes } = fragmentNodesFromString(html, contextLocalName).childNodes[0];
          const mutator = parentNode._getChildNodesMutator();
          const insertionIndex = mutator.indexOf(this);
          for (let i2 = newChildNodes.length - 1; i2 >= 0; i2--) {
            const child = newChildNodes[i2];
            mutator.splice(insertionIndex, 0, child);
            child._setParent(parentNode);
            child._setOwnerDocument(parentNode.ownerDocument);
          }
          this.remove();
        }
      }
    }
  }
  get innerHTML() {
    return getOuterOrInnerHtml(this, false);
  }
  set innerHTML(html) {
    for (const child of this.childNodes) {
      child._setParent(null);
    }
    const mutator = this._getChildNodesMutator();
    mutator.splice(0, this.childNodes.length);
    if (html.length) {
      const parsed = fragmentNodesFromString(html, this.localName);
      for (const child of parsed.childNodes[0].childNodes) {
        mutator.push(child);
      }
      for (const child of this.childNodes) {
        child._setParent(this);
        child._setOwnerDocument(this.ownerDocument);
      }
    }
  }
  get innerText() {
    return this.textContent;
  }
  set innerText(text) {
    this.textContent = text;
  }
  get children() {
    return this._getChildNodesMutator().elementsView();
  }
  get id() {
    return this.#currentId || "";
  }
  set id(id) {
    this.setAttribute("id", this.#currentId = id);
  }
  get dataset() {
    if (this.#datasetProxy) {
      return this.#datasetProxy;
    }
    this.#datasetProxy = new Proxy({}, {
      get: (_target, property, _receiver) => {
        if (typeof property === "string") {
          const attributeName = getDatasetHtmlAttrName(property);
          return this.getAttribute(attributeName) ?? void 0;
        }
        return void 0;
      },
      set: (_target, property, value, _receiver) => {
        if (typeof property === "string") {
          let attributeName = "data-";
          let prevChar = "";
          for (const char of property) {
            if (prevChar === "-" && lowerCaseCharRe.test(char)) {
              throw new DOMException(
                "An invalid or illegal string was specified"
              );
            }
            if (!xmlNameCharRe.test(char)) {
              throw new DOMException("String contains an invalid character");
            }
            if (upperCaseCharRe.test(char)) {
              attributeName += "-";
            }
            attributeName += char.toLowerCase();
            prevChar = char;
          }
          this.setAttribute(attributeName, String(value));
        }
        return true;
      },
      deleteProperty: (_target, property) => {
        if (typeof property === "string") {
          const attributeName = getDatasetHtmlAttrName(property);
          this.removeAttribute(attributeName);
        }
        return true;
      },
      ownKeys: (_target) => {
        return this.getAttributeNames().flatMap((attributeName) => {
          if (attributeName.startsWith?.("data-")) {
            return [getDatasetJavascriptName(attributeName)];
          } else {
            return [];
          }
        });
      },
      getOwnPropertyDescriptor: (_target, property) => {
        if (typeof property === "string") {
          const attributeName = getDatasetHtmlAttrName(property);
          if (this.hasAttribute(attributeName)) {
            return {
              writable: true,
              enumerable: true,
              configurable: true
            };
          }
        }
        return void 0;
      },
      has: (_target, property) => {
        if (typeof property === "string") {
          const attributeName = getDatasetHtmlAttrName(property);
          return this.hasAttribute(attributeName);
        }
        return false;
      }
    });
    return this.#datasetProxy;
  }
  getAttributeNames() {
    return this.attributes[getNamedNodeMapAttrNamesSym]();
  }
  getAttribute(name) {
    return this.attributes[getNamedNodeMapValueSym](name.toLowerCase()) ?? null;
  }
  setAttribute(rawName, value) {
    const name = String(rawName?.toLowerCase());
    const strValue = String(value);
    this.attributes[setNamedNodeMapValueSym](name, strValue);
    if (name === "id") {
      this.#currentId = strValue;
    } else if (name === "class") {
      this.#classList.value = strValue;
    }
  }
  removeAttribute(rawName) {
    const name = String(rawName?.toLowerCase());
    this.attributes[removeNamedNodeMapAttrSym](name);
    if (name === "class") {
      this.#classList.value = "";
    }
  }
  hasAttribute(name) {
    return this.attributes[getNamedNodeMapValueSym](
      String(name?.toLowerCase())
    ) !== void 0;
  }
  hasAttributeNS(_namespace, name) {
    return this.attributes[getNamedNodeMapValueSym](
      String(name?.toLowerCase())
    ) !== void 0;
  }
  replaceWith(...nodes) {
    this._replaceWith(...nodes);
  }
  remove() {
    this._remove();
  }
  append(...nodes) {
    const mutator = this._getChildNodesMutator();
    mutator.push(...nodesAndTextNodes(nodes, this));
  }
  prepend(...nodes) {
    const mutator = this._getChildNodesMutator();
    mutator.splice(0, 0, ...nodesAndTextNodes(nodes, this));
  }
  before(...nodes) {
    if (this.parentNode) {
      insertBeforeAfter(this, nodes, true);
    }
  }
  after(...nodes) {
    if (this.parentNode) {
      insertBeforeAfter(this, nodes, false);
    }
  }
  get firstElementChild() {
    const elements = this._getChildNodesMutator().elementsView();
    return elements[0] ?? null;
  }
  get lastElementChild() {
    const elements = this._getChildNodesMutator().elementsView();
    return elements[elements.length - 1] ?? null;
  }
  get nextElementSibling() {
    const parent = this.parentNode;
    if (!parent) {
      return null;
    }
    const mutator = parent._getChildNodesMutator();
    const index = mutator.indexOfElementsView(this);
    const elements = mutator.elementsView();
    return elements[index + 1] ?? null;
  }
  get previousElementSibling() {
    const parent = this.parentNode;
    if (!parent) {
      return null;
    }
    const mutator = parent._getChildNodesMutator();
    const index = mutator.indexOfElementsView(this);
    const elements = mutator.elementsView();
    return elements[index - 1] ?? null;
  }
  querySelector(selectors) {
    if (!this.ownerDocument) {
      throw new Error("Element must have an owner document");
    }
    return this.ownerDocument._nwapi.first(selectors, this);
  }
  querySelectorAll(selectors) {
    if (!this.ownerDocument) {
      throw new Error("Element must have an owner document");
    }
    const nodeList = new NodeList();
    const mutator = nodeList[nodeListMutatorSym]();
    for (const match of this.ownerDocument._nwapi.select(selectors, this)) {
      mutator.push(match);
    }
    return nodeList;
  }
  matches(selectorString) {
    return this.ownerDocument._nwapi.match(selectorString, this);
  }
  closest(selectorString) {
    const { match } = this.ownerDocument._nwapi;
    let el = this;
    do {
      if (match(selectorString, el)) {
        return el;
      }
      el = el.parentElement;
    } while (el !== null);
    return null;
  }
  // TODO: DRY!!!
  getElementById(id) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        if (child.id === id) {
          return child;
        }
        const search2 = child.getElementById(id);
        if (search2) {
          return search2;
        }
      }
    }
    return null;
  }
  getElementsByTagName(tagName) {
    const fixCaseTagName = tagName.toUpperCase();
    if (fixCaseTagName === "*") {
      return this._getElementsByTagNameWildcard([]);
    } else {
      return this._getElementsByTagName(tagName.toUpperCase(), []);
    }
  }
  _getElementsByTagNameWildcard(search2) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        search2.push(child);
        child._getElementsByTagNameWildcard(search2);
      }
    }
    return search2;
  }
  _getElementsByTagName(tagName, search2) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        if (child.tagName === tagName) {
          search2.push(child);
        }
        child._getElementsByTagName(tagName, search2);
      }
    }
    return search2;
  }
  getElementsByClassName(className) {
    return getElementsByClassName(this, className, []);
  }
  getElementsByTagNameNS(_namespace, localName) {
    return this.getElementsByTagName(localName);
  }
};
utils_types_default.Element = Element2;

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/custom-api.ts
var customByTagNameSym = Symbol();
var customByClassNameSym = Symbol();

// https://deno.land/x/deno_dom@v0.1.43/src/dom/document-fragment.ts
var DocumentFragment2 = class _DocumentFragment extends Node {
  constructor() {
    super(
      "#document-fragment",
      11 /* DOCUMENT_FRAGMENT_NODE */,
      null,
      CTOR_KEY
    );
  }
  get childElementCount() {
    return this._getChildNodesMutator().elementsView().length;
  }
  get children() {
    return this._getChildNodesMutator().elementsView();
  }
  get firstElementChild() {
    const elements = this._getChildNodesMutator().elementsView();
    return elements[0] ?? null;
  }
  get lastElementChild() {
    const elements = this._getChildNodesMutator().elementsView();
    return elements[elements.length - 1] ?? null;
  }
  _shallowClone() {
    return new _DocumentFragment();
  }
  append(...nodes) {
    const mutator = this._getChildNodesMutator();
    mutator.push(...nodesAndTextNodes(nodes, this));
  }
  prepend(...nodes) {
    const mutator = this._getChildNodesMutator();
    mutator.splice(0, 0, ...nodesAndTextNodes(nodes, this));
  }
  replaceChildren(...nodes) {
    const mutator = this._getChildNodesMutator();
    for (const child of this.childNodes) {
      child._setParent(null);
    }
    mutator.splice(0, this.childNodes.length);
    mutator.splice(0, 0, ...nodesAndTextNodes(nodes, this));
  }
  // TODO: DRY!!!
  getElementById(id) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        if (child.id === id) {
          return child;
        }
        const search2 = child.getElementById(id);
        if (search2) {
          return search2;
        }
      }
    }
    return null;
  }
  querySelector(selectors) {
    if (!this.ownerDocument) {
      throw new Error("DocumentFragment must have an owner document");
    }
    return this.ownerDocument._nwapi.first(selectors, this);
  }
  querySelectorAll(selectors) {
    if (!this.ownerDocument) {
      throw new Error("DocumentFragment must have an owner document");
    }
    const nodeList = new NodeList();
    const mutator = nodeList[nodeListMutatorSym]();
    mutator.push(
      ...this.ownerDocument._nwapi.select(selectors, this)
    );
    return nodeList;
  }
};
utils_types_default.DocumentFragment = DocumentFragment2;
function documentFragmentGetElementsByTagName(tagName) {
  const search2 = [];
  if (tagName === "*") {
    return documentFragmentGetElementsByTagNameWildcard(this, search2);
  }
  for (const child of this.childNodes) {
    if (child.nodeType === 1 /* ELEMENT_NODE */) {
      if (child.tagName === tagName) {
        search2.push(child);
      }
      child._getElementsByTagName(tagName, search2);
    }
  }
  return search2;
}
function documentFragmentGetElementsByClassName(className) {
  return getElementsByClassName(this, className, []);
}
function documentFragmentGetElementsByTagNameWildcard(fragment, search2) {
  for (const child of fragment.childNodes) {
    if (child.nodeType === 1 /* ELEMENT_NODE */) {
      search2.push(child);
      child._getElementsByTagNameWildcard(search2);
    }
  }
  return search2;
}
DocumentFragment2.prototype[customByTagNameSym] = documentFragmentGetElementsByTagName;
DocumentFragment2.prototype[customByClassNameSym] = documentFragmentGetElementsByClassName;

// https://deno.land/x/deno_dom@v0.1.43/src/dom/elements/html-template-element.ts
var HTMLTemplateElement = class _HTMLTemplateElement extends Element2 {
  /**
   * This blocks access to the .#contents property when the
   * super() constructor is running which invokes (our
   * overridden) _setParent() method. Without it, we get
   * the following error thrown:
   *
   *   TypeError: Cannot read private member #content from
   *   an object whose class did not declare it
   *
   * FIXME: Maybe find a cleaner way to do this
   */
  __contentIsSet = false;
  #content = null;
  constructor(parentNode, attributes, key, content) {
    super(
      "TEMPLATE",
      parentNode,
      attributes,
      key
    );
    this.#content = content;
    this.__contentIsSet = true;
  }
  get content() {
    return this.#content;
  }
  _setOwnerDocument(document2) {
    super._setOwnerDocument(document2);
    if (this.__contentIsSet) {
      this.content._setOwnerDocument(document2);
    }
  }
  _shallowClone() {
    const frag = new DocumentFragment2();
    const attributes = this.getAttributeNames().map((name) => [name, this.getAttribute(name)]);
    return new _HTMLTemplateElement(null, attributes, CTOR_KEY, frag);
  }
  cloneNode(deep = false) {
    const newNode = super.cloneNode(deep);
    if (deep) {
      const destContent = newNode.content;
      for (const child of this.content.childNodes) {
        destContent.appendChild(child.cloneNode(deep));
      }
    }
    return newNode;
  }
  get innerHTML() {
    return getOuterOrInnerHtml(this, false);
  }
  // Replace children in the `.content`
  set innerHTML(html) {
    const content = this.content;
    for (const child of content.childNodes) {
      child._setParent(null);
    }
    const mutator = content._getChildNodesMutator();
    mutator.splice(0, content.childNodes.length);
    if (html.length) {
      const parsed = fragmentNodesFromString(html, this.localName);
      mutator.push(...parsed.childNodes[0].childNodes);
      for (const child of content.childNodes) {
        child._setParent(content);
        child._setOwnerDocument(content.ownerDocument);
      }
    }
  }
  get outerHTML() {
    return `<template${getElementAttributesString(this)}>${this.innerHTML}</template>`;
  }
};

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/nwsapi.js
var nwsapi_default = (document2) => {
  const NW = Factory({ document: document2, DOMException }, "null");
  NW.configure({
    IDS_DUPES: false,
    LOGERRORS: false
  });
  return NW;
};
function Factory(global, Export) {
  var version = "nwsapi-2.2.0", doc = global.document, root = doc.documentElement, slice2 = Array.prototype.slice, WSP = "[\\x20\\t\\r\\n\\f]", CFG = {
    // extensions
    operators: "[~*^$|]=|=",
    combinators: "[\\x20\\t>+~](?=[^>+~])"
  }, NOT = {
    // not enclosed in double/single/parens/square
    double_enc: '(?=(?:[^"]*["][^"]*["])*[^"]*$)',
    single_enc: "(?=(?:[^']*['][^']*['])*[^']*$)",
    parens_enc: "(?![^\\x28]*\\x29)",
    square_enc: "(?![^\\x5b]*\\x5d)"
  }, REX = {
    // regular expressions
    HasEscapes: RegExp("\\\\"),
    HexNumbers: RegExp("^[0-9a-fA-F]"),
    EscOrQuote: RegExp("^\\\\|[\\x22\\x27]"),
    RegExpChar: RegExp("(?:(?!\\\\)[\\\\^$.*+?()[\\]{}|\\/])", "g"),
    TrimSpaces: RegExp("[\\r\\n\\f]|^" + WSP + "+|" + WSP + "+$", "g"),
    CommaGroup: RegExp("(\\s*,\\s*)" + NOT.square_enc + NOT.parens_enc, "g"),
    SplitGroup: RegExp("((?:\\x28[^\\x29]*\\x29|\\[[^\\]]*\\]|\\\\.|[^,])+)", "g"),
    FixEscapes: RegExp("\\\\([0-9a-fA-F]{1,6}" + WSP + "?|.)|([\\x22\\x27])", "g"),
    CombineWSP: RegExp("[\\n\\r\\f\\x20]+" + NOT.single_enc + NOT.double_enc, "g"),
    TabCharWSP: RegExp("(\\x20?\\t+\\x20?)" + NOT.single_enc + NOT.double_enc, "g"),
    PseudosWSP: RegExp("\\s+([-+])\\s+" + NOT.square_enc, "g")
  }, STD = {
    combinator: RegExp("\\s?([>+~])\\s?", "g"),
    apimethods: RegExp("^(?:[a-z]+|\\*)\\|", "i"),
    namespaces: RegExp("(\\*|[a-z]+)\\|[-a-z]+", "i")
  }, GROUPS = {
    // pseudo-classes requiring parameters
    linguistic: "(dir|lang)\\x28\\s?([-\\w]{2,})\\s?(?:\\x29|$)",
    logicalsel: "(is|where|matches|not)\\x28\\s?([^()]*|[^\\x28]*\\x28[^\\x29]*\\x29)\\s?(?:\\x29|$)",
    treestruct: "(nth(?:-last)?(?:-child|-of-type))(?:\\x28\\s?(even|odd|(?:[-+]?\\d*)(?:n\\s?[-+]?\\s?\\d*)?)\\s?(?:\\x29|$))",
    // pseudo-classes not requiring parameters
    locationpc: "(any-link|link|visited|target)\\b",
    useraction: "(hover|active|focus|focus-within)\\b",
    structural: "(root|empty|(?:(?:first|last|only)(?:-child|-of-type)))\\b",
    inputstate: "(enabled|disabled|read-only|read-write|placeholder-shown|default)\\b",
    inputvalue: "(checked|indeterminate|required|optional|valid|invalid|in-range|out-of-range)\\b",
    // pseudo-elements starting with single colon (:)
    pseudo_sng: "(after|before|first-letter|first-line)\\b",
    // pseudo-elements starting with double colon (::)
    pseudo_dbl: ":(after|before|first-letter|first-line|selection|placeholder|-webkit-[-a-zA-Z0-9]{2,})\\b"
  }, Patterns = {
    // pseudo-classes
    treestruct: RegExp("^:(?:" + GROUPS.treestruct + ")(.*)", "i"),
    structural: RegExp("^:(?:" + GROUPS.structural + ")(.*)", "i"),
    linguistic: RegExp("^:(?:" + GROUPS.linguistic + ")(.*)", "i"),
    useraction: RegExp("^:(?:" + GROUPS.useraction + ")(.*)", "i"),
    inputstate: RegExp("^:(?:" + GROUPS.inputstate + ")(.*)", "i"),
    inputvalue: RegExp("^:(?:" + GROUPS.inputvalue + ")(.*)", "i"),
    locationpc: RegExp("^:(?:" + GROUPS.locationpc + ")(.*)", "i"),
    logicalsel: RegExp("^:(?:" + GROUPS.logicalsel + ")(.*)", "i"),
    pseudo_dbl: RegExp("^:(?:" + GROUPS.pseudo_dbl + ")(.*)", "i"),
    pseudo_sng: RegExp("^:(?:" + GROUPS.pseudo_sng + ")(.*)", "i"),
    // combinator symbols
    children: RegExp("^" + WSP + "?\\>" + WSP + "?(.*)"),
    adjacent: RegExp("^" + WSP + "?\\+" + WSP + "?(.*)"),
    relative: RegExp("^" + WSP + "?\\~" + WSP + "?(.*)"),
    ancestor: RegExp("^" + WSP + "+(.*)"),
    // universal & namespace
    universal: RegExp("^\\*(.*)"),
    namespace: RegExp("^(\\w+|\\*)?\\|(.*)")
  }, RTL = RegExp("^[\\u0591-\\u08ff\\ufb1d-\\ufdfd\\ufe70-\\ufefc ]+$"), qsNotArgs = "Not enough arguments", qsInvalid = " is not a valid selector", reNthElem = RegExp("(:nth(?:-last)?-child)", "i"), reNthType = RegExp("(:nth(?:-last)?-of-type)", "i"), reOptimizer, reValidator, Config = {
    IDS_DUPES: true,
    MIXEDCASE: true,
    LOGERRORS: true,
    VERBOSITY: true
  }, NAMESPACE, QUIRKS_MODE, HTML_DOCUMENT, ATTR_STD_OPS = {
    "=": 1,
    "^=": 1,
    "$=": 1,
    "|=": 1,
    "*=": 1,
    "~=": 1
  }, HTML_TABLE = {
    "accept": 1,
    "accept-charset": 1,
    "align": 1,
    "alink": 1,
    "axis": 1,
    "bgcolor": 1,
    "charset": 1,
    "checked": 1,
    "clear": 1,
    "codetype": 1,
    "color": 1,
    "compact": 1,
    "declare": 1,
    "defer": 1,
    "dir": 1,
    "direction": 1,
    "disabled": 1,
    "enctype": 1,
    "face": 1,
    "frame": 1,
    "hreflang": 1,
    "http-equiv": 1,
    "lang": 1,
    "language": 1,
    "link": 1,
    "media": 1,
    "method": 1,
    "multiple": 1,
    "nohref": 1,
    "noresize": 1,
    "noshade": 1,
    "nowrap": 1,
    "readonly": 1,
    "rel": 1,
    "rev": 1,
    "rules": 1,
    "scope": 1,
    "scrolling": 1,
    "selected": 1,
    "shape": 1,
    "target": 1,
    "text": 1,
    "type": 1,
    "valign": 1,
    "valuetype": 1,
    "vlink": 1
  }, Combinators = {}, Selectors = {}, Operators = {
    "=": {
      p1: "^",
      p2: "$",
      p3: "true"
    },
    "^=": {
      p1: "^",
      p2: "",
      p3: "true"
    },
    "$=": {
      p1: "",
      p2: "$",
      p3: "true"
    },
    "*=": {
      p1: "",
      p2: "",
      p3: "true"
    },
    "|=": {
      p1: "^",
      p2: "(-|$)",
      p3: "true"
    },
    "~=": {
      p1: "(^|\\s)",
      p2: "(\\s|$)",
      p3: "true"
    }
  }, concatCall = function(nodes, callback) {
    var i2 = 0, l2 = nodes.length, list = Array(l2);
    while (l2 > i2) {
      if (false === callback(list[i2] = nodes[i2]))
        break;
      ++i2;
    }
    return list;
  }, concatList = function(list, nodes) {
    var i2 = -1, l2 = nodes.length;
    while (l2--) {
      list[list.length] = nodes[++i2];
    }
    return list;
  }, documentOrder = function(a, b) {
    if (!hasDupes && a === b) {
      hasDupes = true;
      return 0;
    }
    return a.compareDocumentPosition(b) & 4 ? -1 : 1;
  }, hasDupes = false, unique = function(nodes) {
    var i2 = 0, j = -1, l2 = nodes.length + 1, list = [];
    while (--l2) {
      if (nodes[i2++] === nodes[i2])
        continue;
      list[++j] = nodes[i2 - 1];
    }
    hasDupes = false;
    return list;
  }, hasMixedCaseTagNames = function(context) {
    var ns, api = "getElementsByTagNameNS";
    context = context.ownerDocument || context;
    ns = context.documentElement.namespaceURI || "http://www.w3.org/1999/xhtml";
    return context[api]("*", "*").length - context[api](ns, "*").length > 0;
  }, switchContext = function(context, force) {
    var oldDoc = doc;
    doc = context.ownerDocument || context;
    if (force || oldDoc !== doc) {
      root = doc.documentElement;
      HTML_DOCUMENT = isHTML(doc);
      QUIRKS_MODE = HTML_DOCUMENT && doc.compatMode.indexOf("CSS") < 0;
      NAMESPACE = root && root.namespaceURI;
      Snapshot.doc = doc;
      Snapshot.root = root;
    }
    return Snapshot.from = context;
  }, codePointToUTF16 = function(codePoint) {
    if (codePoint < 1 || codePoint > 1114111 || codePoint > 55295 && codePoint < 57344) {
      return "\\ufffd";
    }
    if (codePoint < 65536) {
      var lowHex = "000" + codePoint.toString(16);
      return "\\u" + lowHex.substr(lowHex.length - 4);
    }
    return "\\u" + ((codePoint - 65536 >> 10) + 55296).toString(16) + "\\u" + ((codePoint - 65536) % 1024 + 56320).toString(16);
  }, stringFromCodePoint = function(codePoint) {
    if (codePoint < 1 || codePoint > 1114111 || codePoint > 55295 && codePoint < 57344) {
      return "\uFFFD";
    }
    if (codePoint < 65536) {
      return String.fromCharCode(codePoint);
    }
    return String.fromCodePoint ? String.fromCodePoint(codePoint) : String.fromCharCode(
      (codePoint - 65536 >> 10) + 55296,
      (codePoint - 65536) % 1024 + 56320
    );
  }, convertEscapes = function(str2) {
    return REX.HasEscapes.test(str2) ? str2.replace(
      REX.FixEscapes,
      function(substring, p1, p2) {
        return p2 ? "\\" + p2 : (
          // javascript strings are UTF-16 encoded
          REX.HexNumbers.test(p1) ? codePointToUTF16(parseInt(p1, 16)) : (
            // \' \"
            REX.EscOrQuote.test(p1) ? substring : (
              // \g \h \. \# etc
              p1
            )
          )
        );
      }
    ) : str2;
  }, unescapeIdentifier = function(str2) {
    return REX.HasEscapes.test(str2) ? str2.replace(
      REX.FixEscapes,
      function(substring, p1, p2) {
        return p2 ? p2 : (
          // javascript strings are UTF-16 encoded
          REX.HexNumbers.test(p1) ? stringFromCodePoint(parseInt(p1, 16)) : (
            // \' \"
            REX.EscOrQuote.test(p1) ? substring : (
              // \g \h \. \# etc
              p1
            )
          )
        );
      }
    ) : str2;
  }, method = {
    "#": "getElementById",
    "*": "getElementsByTagNameNS",
    ".": "getElementsByClassName"
  }, compat = {
    "#": function(c, n) {
      REX.HasEscapes.test(n) && (n = unescapeIdentifier(n));
      return function(e, f) {
        return byId(n, c);
      };
    },
    "*": function(c, n) {
      REX.HasEscapes.test(n) && (n = unescapeIdentifier(n));
      return function(e, f) {
        return byTag(n, c);
      };
    },
    ".": function(c, n) {
      REX.HasEscapes.test(n) && (n = unescapeIdentifier(n));
      return function(e, f) {
        return byClass(n, c);
      };
    }
  }, byIdRaw = function(id, context) {
    var node = context, nodes = [], next = node.firstElementChild;
    while (node = next) {
      node.id == id && (nodes[nodes.length] = node);
      if (next = node.firstElementChild || node.nextElementSibling)
        continue;
      while (!next && (node = node.parentElement) && node !== context) {
        next = node.nextElementSibling;
      }
    }
    return nodes;
  }, byId = function(id, context) {
    var e, nodes, api = method["#"];
    if (Config.IDS_DUPES === false) {
      if (api in context) {
        return (e = context[api](id)) ? [e] : none;
      }
    } else {
      if ("all" in context) {
        if (e = context.all[id]) {
          if (e.nodeType == 1)
            return e.getAttribute("id") != id ? [] : [e];
          else if (id == "length")
            return (e = context[api](id)) ? [e] : none;
          for (i = 0, l = e.length, nodes = []; l > i; ++i) {
            if (e[i].id == id)
              nodes[nodes.length] = e[i];
          }
          return nodes && nodes.length ? nodes : [nodes];
        } else
          return none;
      }
    }
    return byIdRaw(id, context);
  }, byTag = function(tag, context) {
    var e, nodes, api = method["*"];
    if (api in context) {
      return slice2.call(context[api]("*", tag));
    } else {
      tag = tag.toLowerCase();
      if (e = context.firstElementChild) {
        if (!(e.nextElementSibling || tag == "*" || e.localName == tag)) {
          return slice2.call(e[api]("*", tag));
        } else {
          nodes = [];
          do {
            if (tag == "*" || e.localName == tag)
              nodes[nodes.length] = e;
            concatList(nodes, e[api]("*", tag));
          } while (e = e.nextElementSibling);
        }
      } else
        nodes = none;
    }
    return nodes;
  }, byClass = function(cls, context) {
    var e, nodes, api = method["."], reCls;
    if (api in context) {
      return slice2.call(context[api](cls));
    } else {
      if (e = context.firstElementChild) {
        reCls = RegExp("(^|\\s)" + cls + "(\\s|$)", QUIRKS_MODE ? "i" : "");
        if (!(e.nextElementSibling || reCls.test(e.className))) {
          return slice2.call(e[api](cls));
        } else {
          nodes = [];
          do {
            if (reCls.test(e.className))
              nodes[nodes.length] = e;
            concatList(nodes, e[api](cls));
          } while (e = e.nextElementSibling);
        }
      } else
        nodes = none;
    }
    return nodes;
  }, hasAttributeNS = function(e, name) {
    var i2, l2, attr = e.getAttributeNames();
    name = RegExp(":?" + name + "$", HTML_DOCUMENT ? "i" : "");
    for (i2 = 0, l2 = attr.length; l2 > i2; ++i2) {
      if (name.test(attr[i2]))
        return true;
    }
    return false;
  }, nthElement = function() {
    var idx = 0, len = 0, set2 = 0, parent = void 0, parents = Array(), nodes = Array();
    return function(element, dir) {
      if (dir == 2) {
        idx = 0;
        len = 0;
        set2 = 0;
        nodes.length = 0;
        parents.length = 0;
        parent = void 0;
        return -1;
      }
      var e, i2, j, k, l2;
      if (parent === element.parentElement) {
        i2 = set2;
        j = idx;
        l2 = len;
      } else {
        l2 = parents.length;
        parent = element.parentElement;
        for (i2 = -1, j = 0, k = l2 - 1; l2 > j; ++j, --k) {
          if (parents[j] === parent) {
            i2 = j;
            break;
          }
          if (parents[k] === parent) {
            i2 = k;
            break;
          }
        }
        if (i2 < 0) {
          parents[i2 = l2] = parent;
          l2 = 0;
          nodes[i2] = Array();
          e = parent && parent.firstElementChild || element;
          while (e) {
            nodes[i2][l2] = e;
            if (e === element)
              j = l2;
            e = e.nextElementSibling;
            ++l2;
          }
          set2 = i2;
          idx = 0;
          len = l2;
          if (l2 < 2)
            return l2;
        } else {
          l2 = nodes[i2].length;
          set2 = i2;
        }
      }
      if (element !== nodes[i2][j] && element !== nodes[i2][j = 0]) {
        for (j = 0, e = nodes[i2], k = l2 - 1; l2 > j; ++j, --k) {
          if (e[j] === element) {
            break;
          }
          if (e[k] === element) {
            j = k;
            break;
          }
        }
      }
      idx = j + 1;
      len = l2;
      return dir ? l2 - j : idx;
    };
  }(), nthOfType = function() {
    var idx = 0, len = 0, set2 = 0, parent = void 0, parents = Array(), nodes = Array();
    return function(element, dir) {
      if (dir == 2) {
        idx = 0;
        len = 0;
        set2 = 0;
        nodes.length = 0;
        parents.length = 0;
        parent = void 0;
        return -1;
      }
      var e, i2, j, k, l2, name = element.localName;
      if (nodes[set2] && nodes[set2][name] && parent === element.parentElement) {
        i2 = set2;
        j = idx;
        l2 = len;
      } else {
        l2 = parents.length;
        parent = element.parentElement;
        for (i2 = -1, j = 0, k = l2 - 1; l2 > j; ++j, --k) {
          if (parents[j] === parent) {
            i2 = j;
            break;
          }
          if (parents[k] === parent) {
            i2 = k;
            break;
          }
        }
        if (i2 < 0 || !nodes[i2][name]) {
          parents[i2 = l2] = parent;
          nodes[i2] || (nodes[i2] = Object());
          l2 = 0;
          nodes[i2][name] = Array();
          e = parent && parent.firstElementChild || element;
          while (e) {
            if (e === element)
              j = l2;
            if (e.localName == name) {
              nodes[i2][name][l2] = e;
              ++l2;
            }
            e = e.nextElementSibling;
          }
          set2 = i2;
          idx = j;
          len = l2;
          if (l2 < 2)
            return l2;
        } else {
          l2 = nodes[i2][name].length;
          set2 = i2;
        }
      }
      if (element !== nodes[i2][name][j] && element !== nodes[i2][name][j = 0]) {
        for (j = 0, e = nodes[i2][name], k = l2 - 1; l2 > j; ++j, --k) {
          if (e[j] === element) {
            break;
          }
          if (e[k] === element) {
            j = k;
            break;
          }
        }
      }
      idx = j + 1;
      len = l2;
      return dir ? l2 - j : idx;
    };
  }(), isHTML = function(node) {
    var doc2 = node.ownerDocument || node;
    return doc2.nodeType == 9 && // contentType not in IE <= 11
    "contentType" in doc2 ? doc2.contentType.indexOf("/html") > 0 : doc2.createElement("DiV").localName == "div";
  }, configure = function(option, clear) {
    if (typeof option == "string") {
      return !!Config[option];
    }
    if (typeof option != "object") {
      return Config;
    }
    for (var i2 in option) {
      Config[i2] = !!option[i2];
    }
    if (clear) {
      matchResolvers = {};
      selectResolvers = {};
    }
    setIdentifierSyntax();
    return true;
  }, emit = function(message, proto) {
    var err;
    if (Config.VERBOSITY) {
      if (proto) {
        err = new proto(message);
      } else {
        err = new global.DOMException(message, "SyntaxError");
      }
      throw err;
    }
    if (Config.LOGERRORS && console && console.log) {
      console.log(message);
    }
  }, initialize = function(doc2) {
    setIdentifierSyntax();
    lastContext = switchContext(doc2, true);
  }, setIdentifierSyntax = function() {
    var identifier = (
      // doesn't start with a digit
      "(?=[^0-9])(?:-{2}|[a-zA-Z0-9-_]|[^\\x00-\\x9f]|\\\\[^\\r\\n\\f0-9a-fA-F]|\\\\[0-9a-fA-F]{1,6}(?:\\r\\n|\\s)?|\\\\.)+"
    ), pseudonames = "[-\\w]+", pseudoparms = "(?:[-+]?\\d*)(?:n\\s?[-+]?\\s?\\d*)", doublequote = '"[^"\\\\]*(?:\\\\.[^"\\\\]*)*(?:"|$)', singlequote = "'[^'\\\\]*(?:\\\\.[^'\\\\]*)*(?:'|$)", attrparser = identifier + "|" + doublequote + "|" + singlequote, attrvalues = "([\\x22\\x27]?)((?!\\3)*|(?:\\\\?.)*?)(?:\\3|$)", attributes = "\\[(?:\\*\\|)?" + WSP + "?(" + identifier + "(?::" + identifier + ")?)" + WSP + "?(?:(" + CFG.operators + ")" + WSP + "?(?:" + attrparser + "))?" + // attribute case sensitivity
    WSP + "?(i)?" + WSP + "?(?:\\]|$)", attrmatcher = attributes.replace(attrparser, attrvalues), pseudoclass = "(?:\\x28" + WSP + "*(?:" + pseudoparms + "?)?|(?:\\*|\\|)|(?:(?::" + pseudonames + "(?:\\x28" + pseudoparms + "?(?:\\x29|$))?|)|(?:[.#]?" + identifier + ")|(?:" + attributes + "))+|(?:" + WSP + "?," + WSP + "?)|(?:" + WSP + "?)|(?:\\x29|$))*", standardValidator = "(?=" + WSP + "?[^>+~(){}<>])(?:(?:\\*|\\|)|(?:[.#]?" + identifier + ")+|(?:" + attributes + ")+|(?:::?" + pseudonames + pseudoclass + ")|(?:" + WSP + "?" + CFG.combinators + WSP + "?)|(?:" + WSP + "?," + WSP + "?)|(?:" + WSP + "?))+";
    reOptimizer = RegExp(
      "(?:([.:#*]?)(" + identifier + ")(?::[-\\w]+|\\[[^\\]]+(?:\\]|$)|\\x28[^\\x29]+(?:\\x29|$))*)$"
    );
    reValidator = RegExp(standardValidator, "g");
    Patterns.id = RegExp("^#(" + identifier + ")(.*)");
    Patterns.tagName = RegExp("^(" + identifier + ")(.*)");
    Patterns.className = RegExp("^\\.(" + identifier + ")(.*)");
    Patterns.attribute = RegExp("^(?:" + attrmatcher + ")(.*)");
  }, F_INIT = '"use strict";return function Resolver(c,f,x,r)', S_HEAD = "var e,n,o,j=r.length-1,k=-1", M_HEAD = "var e,n,o", S_LOOP = "main:while((e=c[++k]))", N_LOOP = "main:while((e=c.item(++k)))", M_LOOP = "e=c;", S_BODY = "r[++j]=c[k];", N_BODY = "r[++j]=c.item(k);", M_BODY = "", S_TAIL = "continue main;", M_TAIL = "r=true;", S_TEST = "if(f(c[k])){break main;}", N_TEST = "if(f(c.item(k))){break main;}", M_TEST = "f(c);", S_VARS = [], M_VARS = [], compile = function(selector, mode, callback) {
    var factory2, token, head = "", loop = "", macro = "", source = "", vars = "";
    switch (mode) {
      case true:
        if (selectLambdas[selector]) {
          return selectLambdas[selector];
        }
        macro = S_BODY + (callback ? S_TEST : "") + S_TAIL;
        head = S_HEAD;
        loop = S_LOOP;
        break;
      case false:
        if (matchLambdas[selector]) {
          return matchLambdas[selector];
        }
        macro = M_BODY + (callback ? M_TEST : "") + M_TAIL;
        head = M_HEAD;
        loop = M_LOOP;
        break;
      case null:
        if (selectLambdas[selector]) {
          return selectLambdas[selector];
        }
        macro = N_BODY + (callback ? N_TEST : "") + S_TAIL;
        head = S_HEAD;
        loop = N_LOOP;
        break;
      default:
        break;
    }
    source = compileSelector(selector, macro, mode, callback, false);
    loop += mode || mode === null ? "{" + source + "}" : source;
    if (mode || mode === null && selector.includes(":nth")) {
      loop += reNthElem.test(selector) ? "s.nthElement(null, 2);" : "";
      loop += reNthType.test(selector) ? "s.nthOfType(null, 2);" : "";
    }
    if (S_VARS[0] || M_VARS[0]) {
      vars = "," + (S_VARS.join(",") || M_VARS.join(","));
      S_VARS.length = 0;
      M_VARS.length = 0;
    }
    factory2 = Function("s", F_INIT + "{" + head + vars + ";" + loop + "return r;}")(Snapshot);
    return mode || mode === null ? selectLambdas[selector] = factory2 : matchLambdas[selector] = factory2;
  }, compileSelector = function(expression, source, mode, callback, not) {
    var a, b, n, f, i2, l2, name, NS, N = not ? "!" : "", D = not ? "" : "!", compat2, expr, match2, result2, status, symbol, test, type, selector = expression, selector_string, vars;
    selector_string = mode ? lastSelected : lastMatched;
    selector = selector.replace(STD.combinator, "$1");
    while (selector) {
      symbol = STD.apimethods.test(selector) ? "|" : selector[0];
      switch (symbol) {
        case "*":
          match2 = selector.match(Patterns.universal);
          if (N == "!") {
            source = "if(" + N + "true){" + source + "}";
          }
          break;
        case "#":
          match2 = selector.match(Patterns.id);
          source = "if(" + N + "(/^" + match2[1] + '$/.test(e.getAttribute("id")))){' + source + "}";
          break;
        case ".":
          match2 = selector.match(Patterns.className);
          compat2 = (QUIRKS_MODE ? "i" : "") + '.test(e.getAttribute("class"))';
          source = "if(" + N + "(/(^|\\s)" + match2[1] + "(\\s|$)/" + compat2 + ")){" + source + "}";
          break;
        case (/[_a-z]/i.test(symbol) ? symbol : void 0):
          match2 = selector.match(Patterns.tagName);
          source = "if(" + N + "(e.localName" + (Config.MIXEDCASE || hasMixedCaseTagNames(doc) ? '=="' + match2[1].toLowerCase() + '"' : '=="' + match2[1].toUpperCase() + '"') + ")){" + source + "}";
          break;
        case "|":
          match2 = selector.match(Patterns.namespace);
          if (match2[1] == "*") {
            source = "if(" + N + "true){" + source + "}";
          } else if (!match2[1]) {
            source = "if(" + N + "(!e.namespaceURI)){" + source + "}";
          } else if (typeof match2[1] == "string" && root.prefix == match2[1]) {
            source = "if(" + N + '(e.namespaceURI=="' + NAMESPACE + '")){' + source + "}";
          } else {
            emit("'" + selector_string + "'" + qsInvalid);
          }
          break;
        case "[":
          match2 = selector.match(Patterns.attribute);
          NS = match2[0].match(STD.namespaces);
          name = match2[1];
          expr = name.split(":");
          expr = expr.length == 2 ? expr[1] : expr[0];
          if (match2[2] && !(test = Operators[match2[2]])) {
            emit("'" + selector_string + "'" + qsInvalid);
            return "";
          }
          if (match2[4] === "") {
            test = match2[2] == "~=" ? { p1: "^\\s", p2: "+$", p3: "true" } : match2[2] in ATTR_STD_OPS && match2[2] != "~=" ? { p1: "^", p2: "$", p3: "true" } : test;
          } else if (match2[2] == "~=" && match2[4].includes(" ")) {
            source = "if(" + N + "false){" + source + "}";
            break;
          } else if (match2[4]) {
            match2[4] = convertEscapes(match2[4]).replace(REX.RegExpChar, "\\$&");
          }
          type = match2[5] == "i" || HTML_DOCUMENT && HTML_TABLE[expr.toLowerCase()] ? "i" : "";
          source = "if(" + N + "(" + (!match2[2] ? NS ? 's.hasAttributeNS(e,"' + name + '")' : 'e.hasAttribute&&e.hasAttribute("' + name + '")' : !match2[4] && ATTR_STD_OPS[match2[2]] && match2[2] != "~=" ? 'e.getAttribute&&e.getAttribute("' + name + '")==""' : "(/" + test.p1 + match2[4] + test.p2 + "/" + type + ').test(e.getAttribute&&e.getAttribute("' + name + '"))==' + test.p3) + ")){" + source + "}";
          break;
        case "~":
          match2 = selector.match(Patterns.relative);
          source = "n=e;while((e=e.previousElementSibling)){" + source + "}e=n;";
          break;
        case "+":
          match2 = selector.match(Patterns.adjacent);
          source = "n=e;if((e=e.previousElementSibling)){" + source + "}e=n;";
          break;
        case "	":
        case " ":
          match2 = selector.match(Patterns.ancestor);
          source = "n=e;while((e=e.parentElement)){" + source + "}e=n;";
          break;
        case ">":
          match2 = selector.match(Patterns.children);
          source = "n=e;if((e=e.parentElement)){" + source + "}e=n;";
          break;
        case (symbol in Combinators ? symbol : void 0):
          match2[match2.length - 1] = "*";
          source = Combinators[symbol](match2) + source;
          break;
        case ":":
          if (match2 = selector.match(Patterns.structural)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "root":
                source = "if(" + N + "(e===s.root)){" + source + (mode ? "break main;" : "") + "}";
                break;
              case "empty":
                source = "n=e.firstChild;while(n&&!(/1|3/).test(n.nodeType)){n=n.nextSibling}if(" + D + "n){" + source + "}";
                break;
              case "only-child":
                source = "if(" + N + "(!e.nextElementSibling&&!e.previousElementSibling)){" + source + "}";
                break;
              case "last-child":
                source = "if(" + N + "(!e.nextElementSibling)){" + source + "}";
                break;
              case "first-child":
                source = "if(" + N + "(!e.previousElementSibling)){" + source + "}";
                break;
              case "only-of-type":
                source = "o=e.localName;n=e;while((n=n.nextElementSibling)&&n.localName!=o);if(!n){n=e;while((n=n.previousElementSibling)&&n.localName!=o);}if(" + D + "n){" + source + "}";
                break;
              case "last-of-type":
                source = "n=e;o=e.localName;while((n=n.nextElementSibling)&&n.localName!=o);if(" + D + "n){" + source + "}";
                break;
              case "first-of-type":
                source = "n=e;o=e.localName;while((n=n.previousElementSibling)&&n.localName!=o);if(" + D + "n){" + source + "}";
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.treestruct)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "nth-child":
              case "nth-of-type":
              case "nth-last-child":
              case "nth-last-of-type":
                expr = /-of-type/i.test(match2[1]);
                if (match2[1] && match2[2]) {
                  type = /last/i.test(match2[1]);
                  if (match2[2] == "n") {
                    source = "if(" + N + "true){" + source + "}";
                    break;
                  } else if (match2[2] == "1") {
                    test = type ? "next" : "previous";
                    source = expr ? "n=e;o=e.localName;while((n=n." + test + "ElementSibling)&&n.localName!=o);if(" + D + "n){" + source + "}" : "if(" + N + "!e." + test + "ElementSibling){" + source + "}";
                    break;
                  } else if (match2[2] == "even" || match2[2] == "2n0" || match2[2] == "2n+0" || match2[2] == "2n") {
                    test = "n%2==0";
                  } else if (match2[2] == "odd" || match2[2] == "2n1" || match2[2] == "2n+1") {
                    test = "n%2==1";
                  } else {
                    f = /n/i.test(match2[2]);
                    n = match2[2].split("n");
                    a = parseInt(n[0], 10) || 0;
                    b = parseInt(n[1], 10) || 0;
                    if (n[0] == "-") {
                      a = -1;
                    }
                    if (n[0] == "+") {
                      a = 1;
                    }
                    test = (b ? "(n" + (b > 0 ? "-" : "+") + Math.abs(b) + ")" : "n") + "%" + a + "==0";
                    test = a >= 1 ? f ? "n>" + (b - 1) + (Math.abs(a) != 1 ? "&&" + test : "") : "n==" + a : a <= -1 ? f ? "n<" + (b + 1) + (Math.abs(a) != 1 ? "&&" + test : "") : "n==" + a : a === 0 ? n[0] ? "n==" + b : "n>" + (b - 1) : "false";
                  }
                  expr = expr ? "OfType" : "Element";
                  type = type ? "true" : "false";
                  source = "n=s.nth" + expr + "(e," + type + ");if(" + N + "(" + test + ")){" + source + "}";
                } else {
                  emit("'" + selector_string + "'" + qsInvalid);
                }
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.logicalsel)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "is":
              case "where":
              case "matches":
                expr = match2[2].replace(REX.CommaGroup, ",").replace(REX.TrimSpaces, "");
                source = 'if(s.match("' + expr.replace(/\x22/g, '\\"') + '",e)){' + source + "}";
                break;
              case "not":
                expr = match2[2].replace(REX.CommaGroup, ",").replace(REX.TrimSpaces, "");
                source = 'if(!s.match("' + expr.replace(/\x22/g, '\\"') + '",e)){' + source + "}";
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.linguistic)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "dir":
                source = "var p;if(" + N + "((/" + match2[2] + '/i.test(e.dir))||(p=s.ancestor("[dir]", e))&&(/' + match2[2] + '/i.test(p.dir))||(e.dir==""||e.dir=="auto")&&(' + (match2[2] == "ltr" ? "!" : "") + RTL + ".test(e.textContent)))){" + source + "};";
                break;
              case "lang":
                expr = "(?:^|-)" + match2[2] + "(?:-|$)";
                source = "var p;if(" + N + '((e.isConnected&&(e.lang==""&&(p=s.ancestor("[lang]",e)))&&(p.lang=="' + match2[2] + '")||/' + expr + "/i.test(e.lang)))){" + source + "};";
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.locationpc)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "any-link":
                source = "if(" + N + '(/^a|area$/i.test(e.localName)&&e.hasAttribute("href")||e.visited)){' + source + "}";
                break;
              case "link":
                source = "if(" + N + '(/^a|area$/i.test(e.localName)&&e.hasAttribute("href"))){' + source + "}";
                break;
              case "visited":
                source = "if(" + N + '(/^a|area$/i.test(e.localName)&&e.hasAttribute("href")&&e.visited)){' + source + "}";
                break;
              case "target":
                source = "if(" + N + "((s.doc.compareDocumentPosition(e)&16)&&s.doc.location.hash&&e.id==s.doc.location.hash.slice(1))){" + source + "}";
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.useraction)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "hover":
                source = "hasFocus" in doc && doc.hasFocus() ? "if(" + N + "(e===s.doc.hoverElement)){" + source + "}" : "if(" + D + "true){" + source + "}";
                break;
              case "active":
                source = "hasFocus" in doc && doc.hasFocus() ? "if(" + N + "(e===s.doc.activeElement)){" + source + "}" : "if(" + D + "true){" + source + "}";
                break;
              case "focus":
                source = "hasFocus" in doc ? "if(" + N + '(e===s.doc.activeElement&&s.doc.hasFocus()&&(e.type||e.href||typeof e.tabIndex=="number"))){' + source + "}" : "if(" + N + "(e===s.doc.activeElement&&(e.type||e.href))){" + source + "}";
                break;
              case "focus-within":
                source = "hasFocus" in doc ? "n=s.doc.activeElement;while(e){if(e===n||e.parentNode===n)break;}if(" + N + '(e===n&&s.doc.hasFocus()&&(e.type||e.href||typeof e.tabIndex=="number"))){' + source + "}" : source;
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.inputstate)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "enabled":
                source = "if(" + N + '(("form" in e||/^optgroup$/i.test(e.localName))&&"disabled" in e &&e.disabled===false)){' + source + "}";
                break;
              case "disabled":
                source = "if(" + N + '(("form" in e||/^optgroup$/i.test(e.localName))&&"disabled" in e&&(e.disabled===true||(n=s.ancestor("fieldset",e))&&(n=s.first("legend",n))&&!n.contains(e)))){' + source + "}";
                break;
              case "read-only":
                source = "if(" + N + '((/^textarea$/i.test(e.localName)&&(e.readOnly||e.disabled))||("|password|text|".includes("|"+e.type+"|")&&e.readOnly))){' + source + "}";
                break;
              case "read-write":
                source = "if(" + N + '(((/^textarea$/i.test(e.localName)&&!e.readOnly&&!e.disabled)||("|password|text|".includes("|"+e.type+"|")&&!e.readOnly&&!e.disabled))||(e.hasAttribute("contenteditable")||(s.doc.designMode=="on")))){' + source + "}";
                break;
              case "placeholder-shown":
                source = "if(" + N + '((/^input|textarea$/i.test(e.localName))&&e.hasAttribute("placeholder")&&("|textarea|password|number|search|email|text|tel|url|".includes("|"+e.type+"|"))&&(!s.match(":focus",e)))){' + source + "}";
                break;
              case "default":
                source = "if(" + N + '("form" in e && e.form)){var x=0;n=[];if(e.type=="image")n=e.form.getElementsByTagName("input");if(e.type=="submit")n=e.form.elements;while(n[x]&&e!==n[x]){if(n[x].type=="image")break;if(n[x].type=="submit")break;x++;}}if(' + N + '(e.form&&(e===n[x]&&"|image|submit|".includes("|"+e.type+"|"))||((/^option$/i.test(e.localName))&&e.defaultSelected)||(("|radio|checkbox|".includes("|"+e.type+"|"))&&e.defaultChecked))){' + source + "}";
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.inputvalue)) {
            match2[1] = match2[1].toLowerCase();
            switch (match2[1]) {
              case "checked":
                source = "if(" + N + '(/^input$/i.test(e.localName)&&("|radio|checkbox|".includes("|"+e.type+"|")&&e.checked)||(/^option$/i.test(e.localName)&&(e.selected||e.checked)))){' + source + "}";
                break;
              case "indeterminate":
                source = "if(" + N + '(/^progress$/i.test(e.localName)&&!e.hasAttribute("value"))||(/^input$/i.test(e.localName)&&("checkbox"==e.type&&e.indeterminate)||("radio"==e.type&&e.name&&!s.first("input[name="+e.name+"]:checked",e.form)))){' + source + "}";
                break;
              case "required":
                source = "if(" + N + "(/^input|select|textarea$/i.test(e.localName)&&e.required)){" + source + "}";
                break;
              case "optional":
                source = "if(" + N + "(/^input|select|textarea$/i.test(e.localName)&&!e.required)){" + source + "}";
                break;
              case "invalid":
                source = "if(" + N + '(((/^form$/i.test(e.localName)&&!e.noValidate)||(e.willValidate&&!e.formNoValidate))&&!e.checkValidity())||(/^fieldset$/i.test(e.localName)&&s.first(":invalid",e))){' + source + "}";
                break;
              case "valid":
                source = "if(" + N + '(((/^form$/i.test(e.localName)&&!e.noValidate)||(e.willValidate&&!e.formNoValidate))&&e.checkValidity())||(/^fieldset$/i.test(e.localName)&&s.first(":valid",e))){' + source + "}";
                break;
              case "in-range":
                source = "if(" + N + '(/^input$/i.test(e.localName))&&(e.willValidate&&!e.formNoValidate)&&(!e.validity.rangeUnderflow&&!e.validity.rangeOverflow)&&("|date|datetime-local|month|number|range|time|week|".includes("|"+e.type+"|"))&&("range"==e.type||e.getAttribute("min")||e.getAttribute("max"))){' + source + "}";
                break;
              case "out-of-range":
                source = "if(" + N + '(/^input$/i.test(e.localName))&&(e.willValidate&&!e.formNoValidate)&&(e.validity.rangeUnderflow||e.validity.rangeOverflow)&&("|date|datetime-local|month|number|range|time|week|".includes("|"+e.type+"|"))&&("range"==e.type||e.getAttribute("min")||e.getAttribute("max"))){' + source + "}";
                break;
              default:
                emit("'" + selector_string + "'" + qsInvalid);
                break;
            }
          } else if (match2 = selector.match(Patterns.pseudo_sng)) {
            source = 'if(e.element&&e.type.toLowerCase()==":' + match2[0].toLowerCase() + '"){e=e.element;' + source + "}";
          } else if (match2 = selector.match(Patterns.pseudo_dbl)) {
            source = 'if(e.element&&e.type.toLowerCase()=="' + match2[0].toLowerCase() + '"){e=e.element;' + source + "}";
          } else {
            expr = false;
            status = false;
            for (expr in Selectors) {
              if (match2 = selector.match(Selectors[expr].Expression)) {
                result2 = Selectors[expr].Callback(match2, source, mode, callback);
                if ("match" in result2) {
                  match2 = result2.match;
                }
                vars = result2.modvar;
                if (mode) {
                  vars && S_VARS.indexOf(vars) < 0 && (S_VARS[S_VARS.length] = vars);
                } else {
                  vars && M_VARS.indexOf(vars) < 0 && (M_VARS[M_VARS.length] = vars);
                }
                source = result2.source;
                status = result2.status;
                if (status) {
                  break;
                }
              }
            }
            if (!status) {
              emit("unknown pseudo-class selector '" + selector + "'");
              return "";
            }
            if (!expr) {
              emit("unknown token in selector '" + selector + "'");
              return "";
            }
          }
          break;
        default:
          emit("'" + selector_string + "'" + qsInvalid);
          break;
      }
      if (!match2) {
        emit("'" + selector_string + "'" + qsInvalid);
        return "";
      }
      selector = match2.pop();
    }
    return source;
  }, makeref = function(selectors, element) {
    return selectors.replace(
      /:scope/ig,
      element.localName + (element.id ? "#" + element.id : "") + (element.className ? "." + element.classList[0] : "")
    );
  }, ancestor = function _closest2(selectors, element, callback) {
    if (/:scope/i.test(selectors)) {
      selectors = makeref(selectors, element);
    }
    while (element) {
      if (match(selectors, element, callback))
        break;
      element = element.parentElement;
    }
    return element;
  }, match_assert = function(f, element, callback) {
    for (var i2 = 0, l2 = f.length, r = false; l2 > i2; ++i2)
      f[i2](element, callback, null, false) && (r = true);
    return r;
  }, match_collect = function(selectors, callback) {
    for (var i2 = 0, l2 = selectors.length, f = []; l2 > i2; ++i2)
      f[i2] = compile(selectors[i2], false, callback);
    return { factory: f };
  }, match = function _matches2(selectors, element, callback) {
    var expressions, parsed;
    if (element && matchResolvers[selectors]) {
      return match_assert(matchResolvers[selectors].factory, element, callback);
    }
    lastMatched = selectors;
    if (arguments.length === 0) {
      emit(qsNotArgs, TypeError);
      return Config.VERBOSITY ? void 0 : false;
    } else if (arguments[0] === "") {
      emit("''" + qsInvalid);
      return Config.VERBOSITY ? void 0 : false;
    }
    if (typeof selectors != "string") {
      selectors = "" + selectors;
    }
    if (/:scope/i.test(selectors)) {
      selectors = makeref(selectors, element);
    }
    parsed = selectors.replace(/\x00|\\$/g, "\uFFFD").replace(REX.CombineWSP, " ").replace(REX.PseudosWSP, "$1").replace(REX.TabCharWSP, "	").replace(REX.CommaGroup, ",").replace(REX.TrimSpaces, "");
    if ((expressions = parsed.match(reValidator)) && expressions.join("") == parsed) {
      expressions = parsed.match(REX.SplitGroup);
      if (parsed[parsed.length - 1] == ",") {
        emit(qsInvalid);
        return Config.VERBOSITY ? void 0 : false;
      }
    } else {
      emit("'" + selectors + "'" + qsInvalid);
      return Config.VERBOSITY ? void 0 : false;
    }
    matchResolvers[selectors] = match_collect(expressions, callback);
    return match_assert(matchResolvers[selectors].factory, element, callback);
  }, first = function _querySelector2(selectors, context, callback) {
    if (arguments.length === 0) {
      emit(qsNotArgs, TypeError);
    }
    return select(
      selectors,
      context,
      typeof callback == "function" ? function firstMatch(element) {
        callback(element);
        return false;
      } : function firstMatch() {
        return false;
      }
    )[0] || null;
  }, select = function _querySelectorAll2(selectors, context, callback) {
    var expressions, nodes, parsed, resolver;
    context || (context = doc);
    if (selectors) {
      if (resolver = selectResolvers[selectors]) {
        if (resolver.context === context && resolver.callback === callback) {
          var f = resolver.factory, h = resolver.htmlset, n = resolver.nodeset, nodes = [];
          if (n.length > 1) {
            for (var i2 = 0, l2 = n.length, list; l2 > i2; ++i2) {
              list = compat[n[i2][0]](context, n[i2].slice(1))();
              if (f[i2] !== null) {
                f[i2](list, callback, context, nodes);
              } else {
                nodes = nodes.concat(list);
              }
            }
            if (l2 > 1 && nodes.length > 1) {
              nodes.sort(documentOrder);
              hasDupes && (nodes = unique(nodes));
            }
          } else {
            if (f[0]) {
              nodes = f[0](h[0](), callback, context, nodes);
            } else {
              nodes = h[0]();
            }
          }
          return typeof callback == "function" ? concatCall(nodes, callback) : nodes;
        }
      }
    }
    lastSelected = selectors;
    if (arguments.length === 0) {
      emit(qsNotArgs, TypeError);
      return Config.VERBOSITY ? void 0 : none;
    } else if (arguments[0] === "") {
      emit("''" + qsInvalid);
      return Config.VERBOSITY ? void 0 : none;
    } else if (lastContext !== context) {
      lastContext = switchContext(context);
    }
    if (typeof selectors != "string") {
      selectors = "" + selectors;
    }
    if (/:scope/i.test(selectors)) {
      selectors = makeref(selectors, context);
    }
    parsed = selectors.replace(/\x00|\\$/g, "\uFFFD").replace(REX.CombineWSP, " ").replace(REX.PseudosWSP, "$1").replace(REX.TabCharWSP, "	").replace(REX.CommaGroup, ",").replace(REX.TrimSpaces, "");
    if ((expressions = parsed.match(reValidator)) && expressions.join("") == parsed) {
      expressions = parsed.match(REX.SplitGroup);
      if (parsed[parsed.length - 1] == ",") {
        emit(qsInvalid);
        return Config.VERBOSITY ? void 0 : false;
      }
    } else {
      emit("'" + selectors + "'" + qsInvalid);
      return Config.VERBOSITY ? void 0 : false;
    }
    selectResolvers[selectors] = collect(expressions, context, callback);
    nodes = selectResolvers[selectors].results;
    return typeof callback == "function" ? concatCall(nodes, callback) : nodes;
  }, optimize = function(selector, token) {
    var index = token.index, length = token[1].length + token[2].length;
    return selector.slice(0, index) + (" >+~".indexOf(selector.charAt(index - 1)) > -1 ? ":[".indexOf(selector.charAt(index + length + 1)) > -1 ? "*" : "" : "") + selector.slice(index + length - (token[1] == "*" ? 1 : 0));
  }, collect = function(selectors, context, callback) {
    var i2, l2, seen = {}, token = ["", "*", "*"], optimized = selectors, factory2 = [], htmlset = [], nodeset = [], results = [], type;
    for (i2 = 0, l2 = selectors.length; l2 > i2; ++i2) {
      if (!seen[selectors[i2]] && (seen[selectors[i2]] = true)) {
        type = selectors[i2].match(reOptimizer);
        if (type && type[1] != ":" && (token = type)) {
          token[1] || (token[1] = "*");
          optimized[i2] = optimize(optimized[i2], token);
        } else {
          token = ["", "*", "*"];
        }
      }
      nodeset[i2] = token[1] + token[2];
      htmlset[i2] = compat[token[1]](context, token[2]);
      factory2[i2] = compile(optimized[i2], true, null);
      factory2[i2] ? factory2[i2](htmlset[i2](), callback, context, results) : result.concat(htmlset[i2]());
    }
    if (l2 > 1) {
      results.sort(documentOrder);
      hasDupes && (results = unique(results));
    }
    return {
      callback,
      context,
      factory: factory2,
      htmlset,
      nodeset,
      results
    };
  }, _closest, _matches, _querySelector, _querySelectorAll, install = function(all) {
    _closest = Element.prototype.closest;
    _matches = Element.prototype.matches;
    _querySelector = Document.prototype.querySelector;
    _querySelectorAll = Document.prototype.querySelectorAll;
    Element.prototype.closest = function closest2() {
      var ctor = Object.getPrototypeOf(this).__proto__.__proto__.constructor.name;
      if (!("nodeType" in this)) {
        emit("'closest' called on an object that does not implement interface " + ctor + ".", TypeError);
      }
      return arguments.length < 1 ? ancestor.apply(this, []) : arguments.length < 2 ? ancestor.apply(this, [arguments[0], this]) : ancestor.apply(this, [arguments[0], this, typeof arguments[1] == "function" ? arguments[1] : void 0]);
    };
    Element.prototype.matches = function matches() {
      var ctor = Object.getPrototypeOf(this).__proto__.__proto__.constructor.name;
      if (!("nodeType" in this)) {
        emit("'matches' called on an object that does not implement interface " + ctor + ".", TypeError);
      }
      return arguments.length < 1 ? match.apply(this, []) : arguments.length < 2 ? match.apply(this, [arguments[0], this]) : match.apply(this, [arguments[0], this, typeof arguments[1] == "function" ? arguments[1] : void 0]);
    };
    Element.prototype.querySelector = Document.prototype.querySelector = DocumentFragment.prototype.querySelector = function querySelector() {
      var ctor = Object.getPrototypeOf(this).__proto__.__proto__.constructor.name;
      if (!("nodeType" in this)) {
        emit("'querySelector' called on an object that does not implement interface " + ctor + ".", TypeError);
      }
      return arguments.length < 1 ? first.apply(this, []) : arguments.length < 2 ? first.apply(this, [arguments[0], this]) : first.apply(this, [arguments[0], this, typeof arguments[1] == "function" ? arguments[1] : void 0]);
    };
    Element.prototype.querySelectorAll = Document.prototype.querySelectorAll = DocumentFragment.prototype.querySelectorAll = function querySelectorAll() {
      var ctor = Object.getPrototypeOf(this).__proto__.__proto__.constructor.name;
      if (!("nodeType" in this)) {
        emit("'querySelectorAll' called on an object that does not implement interface " + ctor + ".", TypeError);
      }
      return arguments.length < 1 ? select.apply(this, []) : arguments.length < 2 ? select.apply(this, [arguments[0], this]) : select.apply(this, [arguments[0], this, typeof arguments[1] == "function" ? arguments[1] : void 0]);
    };
    if (all) {
      document.addEventListener("load", function(e) {
        var c, d, r, s, t = e.target;
        if (/iframe/i.test(t.localName)) {
          c = "(" + Export + ")(this, " + Factory + ");";
          d = t.contentDocument;
          s = d.createElement("script");
          s.textContent = c + "NW.Dom.install()";
          r = d.documentElement;
          r.removeChild(r.insertBefore(s, r.firstChild));
        }
      }, true);
    }
  }, uninstall = function() {
    Element.prototype.closest = _closest;
    Element.prototype.matches = _matches;
    Element.prototype.querySelector = Document.prototype.querySelector = DocumentFragment.prototype.querySelector = _querySelector;
    Element.prototype.querySelectorAll = Document.prototype.querySelectorAll = DocumentFragment.prototype.querySelectorAll = _querySelectorAll;
  }, none = Array(), lastContext, lastMatched, lastSelected, matchLambdas = {}, selectLambdas = {}, matchResolvers = {}, selectResolvers = {}, Snapshot = {
    doc,
    from: doc,
    root,
    byTag,
    first,
    match,
    ancestor,
    nthOfType,
    nthElement,
    hasAttributeNS
  }, Dom = {
    // exported cache objects
    lastMatched,
    lastSelected,
    matchLambdas,
    selectLambdas,
    matchResolvers,
    selectResolvers,
    // exported compiler macros
    CFG,
    M_BODY,
    S_BODY,
    M_TEST,
    S_TEST,
    // exported engine methods
    byId,
    byTag,
    byClass,
    match,
    first,
    select,
    closest: ancestor,
    compile,
    configure,
    emit,
    Config,
    Snapshot,
    Version: version,
    install,
    uninstall,
    Operators,
    Selectors,
    // register a new selector combinator symbol and its related function resolver
    registerCombinator: function(combinator, resolver) {
      var i2 = 0, l2 = combinator.length, symbol;
      for (; l2 > i2; ++i2) {
        if (combinator[i2] != "=") {
          symbol = combinator[i2];
          break;
        }
      }
      if (CFG.combinators.indexOf(symbol) < 0) {
        CFG.combinators = CFG.combinators.replace("](", symbol + "](");
        CFG.combinators = CFG.combinators.replace("])", symbol + "])");
        Combinators[combinator] = resolver;
        setIdentifierSyntax();
      } else {
        console.warn("Warning: the '" + combinator + "' combinator is already registered.");
      }
    },
    // register a new attribute operator symbol and its related function resolver
    registerOperator: function(operator, resolver) {
      var i2 = 0, l2 = operator.length, symbol;
      for (; l2 > i2; ++i2) {
        if (operator[i2] != "=") {
          symbol = operator[i2];
          break;
        }
      }
      if (CFG.operators.indexOf(symbol) < 0 && !Operators[operator]) {
        CFG.operators = CFG.operators.replace("]=", symbol + "]=");
        Operators[operator] = resolver;
        setIdentifierSyntax();
      } else {
        console.warn("Warning: the '" + operator + "' operator is already registered.");
      }
    },
    // register a new selector symbol and its related function resolver
    registerSelector: function(name, rexp, func2) {
      Selectors[name] || (Selectors[name] = {
        Expression: rexp,
        Callback: func2
      });
    }
  };
  initialize(doc);
  return Dom;
}

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/nwsapi-types.ts
var DOM = nwsapi_default;

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/sizzle.js
var sizzle_default = (document2) => {
  const sizzleWindow = {
    document: document2
  };
  SetupSizzle(sizzleWindow);
  const { Sizzle } = sizzleWindow;
  return {
    first(selectors, context) {
      return Sizzle(selectors, context)[0] ?? null;
    },
    select(selectors, context) {
      return Sizzle(selectors, context);
    },
    match(selectors, context) {
      return Sizzle.matchesSelector(context, selectors);
    }
  };
};
function SetupSizzle(window2) {
  var i2, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document2, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * /* @__PURE__ */ new Date(), preferredDoc = window2.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
    if (a === b) {
      hasDuplicate = true;
    }
    return 0;
  }, hasOwn6 = {}.hasOwnProperty, arr = [], pop = arr.pop, pushNative = arr.push, push2 = arr.push, slice2 = arr.slice, indexOf2 = function(list, elem) {
    var i3 = 0, len = list.length;
    for (; i3 < len; i3++) {
      if (list[i3] === elem) {
        return i3;
      }
    }
    return -1;
  }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
  "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
  // or strings [capture 3 or capture 4]"
  `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp(
    "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
    "g"
  ), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp(
    "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"
  ), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
    ID: new RegExp("^#(" + identifier + ")"),
    CLASS: new RegExp("^\\.(" + identifier + ")"),
    TAG: new RegExp("^(" + identifier + "|[*])"),
    ATTR: new RegExp("^" + attributes),
    PSEUDO: new RegExp("^" + pseudos),
    CHILD: new RegExp(
      "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
      "i"
    ),
    bool: new RegExp("^(?:" + booleans + ")$", "i"),
    // For use in libraries implementing .is()
    // We use this for POS matching in `select`
    needsContext: new RegExp(
      "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",
      "i"
    )
  }, rhtml = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp(
    "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])",
    "g"
  ), funescape = function(escape, nonHex) {
    var high = "0x" + escape.slice(1) - 65536;
    return nonHex ? (
      // Strip the backslash prefix from a non-hex escape sequence
      nonHex
    ) : (
      // Replace a hexadecimal escape sequence with the encoded Unicode code point
      // Support: IE <=11+
      // For values outside the Basic Multilingual Plane (BMP), manually construct a
      // surrogate pair
      high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
    );
  }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
    if (asCodePoint) {
      if (ch === "\0") {
        return "\uFFFD";
      }
      return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
    }
    return "\\" + ch;
  }, unloadHandler = function() {
    setDocument();
  }, inDisabledFieldset = addCombinator(
    function(elem) {
      return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
    },
    { dir: "parentNode", next: "legend" }
  );
  try {
    push2.apply(
      arr = slice2.call(preferredDoc.childNodes),
      preferredDoc.childNodes
    );
    arr[preferredDoc.childNodes.length].nodeType;
  } catch (e) {
    push2 = {
      apply: arr.length ? (
        // Leverage slice if possible
        function(target, els) {
          pushNative.apply(target, slice2.call(els));
        }
      ) : (
        // Support: IE<9
        // Otherwise append directly
        function(target, els) {
          var j = target.length, i3 = 0;
          while (target[j++] = els[i3++]) {
          }
          target.length = j - 1;
        }
      )
    };
  }
  function Sizzle(selector, context, results, seed) {
    var m, i3, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
    results = results || [];
    if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
      return results;
    }
    if (!seed) {
      setDocument(context);
      context = context || document2;
      if (documentIsHTML) {
        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
          if (m = match[1]) {
            if (nodeType === 9) {
              if (elem = context.getElementById(m)) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else if (match[2]) {
            push2.apply(results, context.getElementsByTagName(selector));
            return results;
          } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
            push2.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && // Support: IE 8 only
        // Exclude object elements
        (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
          newSelector = selector;
          newContext = context;
          if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            if (newContext !== context || !support.scope) {
              if (nid = context.getAttribute("id")) {
                nid = nid.replace(rcssescape, fcssescape);
              } else {
                context.setAttribute("id", nid = expando);
              }
            }
            groups = tokenize(selector);
            i3 = groups.length;
            while (i3--) {
              groups[i3] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i3]);
            }
            newSelector = groups.join(",");
          }
          try {
            push2.apply(results, newContext.querySelectorAll(newSelector));
            return results;
          } catch (qsaError) {
            nonnativeSelectorCache(selector, true);
          } finally {
            if (nid === expando) {
              context.removeAttribute("id");
            }
          }
        }
      }
    }
    return select(selector.replace(rtrim, "$1"), context, results, seed);
  }
  function createCache() {
    var keys = [];
    function cache6(key, value) {
      if (keys.push(key + " ") > Expr.cacheLength) {
        delete cache6[keys.shift()];
      }
      return cache6[key + " "] = value;
    }
    return cache6;
  }
  function markFunction(fn) {
    fn[expando] = true;
    return fn;
  }
  function assert9(fn) {
    return true;
    var el = document2.createElement("fieldset");
    try {
      return !!fn(el);
    } catch (e) {
      return false;
    } finally {
      if (el.parentNode) {
        el.parentNode.removeChild(el);
      }
      el = null;
    }
  }
  function addHandle(attrs, handler) {
    var arr2 = attrs.split("|"), i3 = arr2.length;
    while (i3--) {
      Expr.attrHandle[arr2[i3]] = handler;
    }
  }
  function siblingCheck(a, b) {
    var cur = b && a, diff2 = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
    if (diff2) {
      return diff2;
    }
    if (cur) {
      while (cur = cur.nextSibling) {
        if (cur === b) {
          return -1;
        }
      }
    }
    return a ? 1 : -1;
  }
  function createInputPseudo(type) {
    return function(elem) {
      var name = elem.nodeName.toLowerCase();
      return name === "input" && elem.type === type;
    };
  }
  function createButtonPseudo(type) {
    return function(elem) {
      var name = elem.nodeName.toLowerCase();
      return (name === "input" || name === "button") && elem.type === type;
    };
  }
  function createDisabledPseudo(disabled) {
    return function(elem) {
      if ("form" in elem) {
        if (elem.parentNode && elem.disabled === false) {
          if ("label" in elem) {
            if ("label" in elem.parentNode) {
              return elem.parentNode.disabled === disabled;
            } else {
              return elem.disabled === disabled;
            }
          }
          return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
          /* jshint -W018 */
          elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
        }
        return elem.disabled === disabled;
      } else if ("label" in elem) {
        return elem.disabled === disabled;
      }
      return false;
    };
  }
  function createPositionalPseudo(fn) {
    return markFunction(function(argument) {
      argument = +argument;
      return markFunction(function(seed, matches2) {
        var j, matchIndexes = fn([], seed.length, argument), i3 = matchIndexes.length;
        while (i3--) {
          if (seed[j = matchIndexes[i3]]) {
            seed[j] = !(matches2[j] = seed[j]);
          }
        }
      });
    });
  }
  function testContext(context) {
    return context && typeof context.getElementsByTagName !== "undefined" && context;
  }
  support = Sizzle.support = {};
  isXML = Sizzle.isXML = function(elem) {
    var namespace = elem && elem.namespaceURI, docElem2 = elem && (elem.ownerDocument || elem).documentElement;
    return !rhtml.test(namespace || docElem2 && docElem2.nodeName || "HTML");
  };
  setDocument = Sizzle.setDocument = function(node) {
    var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
    if (doc == document2 || doc.nodeType !== 9 || !doc.documentElement) {
      return document2;
    }
    document2 = doc;
    docElem = document2.documentElement;
    documentIsHTML = !isXML(document2);
    if (preferredDoc != document2 && (subWindow = document2.defaultView) && subWindow.top !== subWindow) {
      if (subWindow.addEventListener) {
        subWindow.addEventListener("unload", unloadHandler, false);
      } else if (subWindow.attachEvent) {
        subWindow.attachEvent("onunload", unloadHandler);
      }
    }
    support.scope = assert9(function(el) {
      docElem.appendChild(el).appendChild(document2.createElement("div"));
      return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
    });
    support.attributes = assert9(function(el) {
      el.className = "i";
      return !el.getAttribute("className");
    });
    support.getElementsByTagName = assert9(function(el) {
      el.appendChild(document2.createComment(""));
      return !el.getElementsByTagName("*").length;
    });
    support.getElementsByClassName = rnative.test(
      document2.getElementsByClassName
    );
    support.getById = assert9(function(el) {
      docElem.appendChild(el).id = expando;
      return !document2.getElementsByName || !document2.getElementsByName(expando).length;
    });
    if (support.getById) {
      Expr.filter["ID"] = function(id) {
        var attrId = id.replace(runescape, funescape);
        return function(elem) {
          return elem.getAttribute("id") === attrId;
        };
      };
      Expr.find["ID"] = function(id, context) {
        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
          var elem = context.getElementById(id);
          return elem ? [elem] : [];
        }
      };
    } else {
      Expr.filter["ID"] = function(id) {
        var attrId = id.replace(runescape, funescape);
        return function(elem) {
          var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
          return node2 && node2.value === attrId;
        };
      };
      Expr.find["ID"] = function(id, context) {
        if (typeof context.getElementById !== "undefined" && documentIsHTML) {
          var node2, i3, elems, elem = context.getElementById(id);
          if (elem) {
            node2 = elem.getAttributeNode("id");
            if (node2 && node2.value === id) {
              return [elem];
            }
            elems = context.getElementsByName(id);
            i3 = 0;
            while (elem = elems[i3++]) {
              node2 = elem.getAttributeNode("id");
              if (node2 && node2.value === id) {
                return [elem];
              }
            }
          }
          return [];
        }
      };
    }
    Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
      if (typeof context.getElementsByTagName !== "undefined") {
        return context.getElementsByTagName(tag);
      } else if (context[customByTagNameSym]) {
        return context[customByTagNameSym](tag);
      } else if (support.qsa) {
        return context.querySelectorAll(tag);
      }
    } : function(tag, context) {
      var elem, tmp = [], i3 = 0, results = context.getElementsByTagName(tag);
      if (tag === "*") {
        while (elem = results[i3++]) {
          if (elem.nodeType === 1) {
            tmp.push(elem);
          }
        }
        return tmp;
      }
      return results;
    };
    Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
      if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
        return context.getElementsByClassName(className);
      } else if (context[customByClassNameSym]) {
        return context[customByClassNameSym](className);
      }
    };
    rbuggyMatches = [];
    rbuggyQSA = [];
    if (support.qsa = rnative.test(document2.querySelectorAll)) {
      assert9(function(el) {
        var input;
        docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
        if (el.querySelectorAll("[msallowcapture^='']").length) {
          rbuggyQSA.push("[*^$]=" + whitespace + `*(?:''|"")`);
        }
        if (!el.querySelectorAll("[selected]").length) {
          rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
        }
        if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
          rbuggyQSA.push("~=");
        }
        input = document2.createElement("input");
        input.setAttribute("name", "");
        el.appendChild(input);
        if (!el.querySelectorAll("[name='']").length) {
          rbuggyQSA.push(
            "\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`
          );
        }
        if (!el.querySelectorAll(":checked").length) {
          rbuggyQSA.push(":checked");
        }
        if (!el.querySelectorAll("a#" + expando + "+*").length) {
          rbuggyQSA.push(".#.+[+~]");
        }
        el.querySelectorAll("\\\f");
        rbuggyQSA.push("[\\r\\n\\f]");
      });
      assert9(function(el) {
        el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
        var input = document2.createElement("input");
        input.setAttribute("type", "hidden");
        el.appendChild(input).setAttribute("name", "D");
        if (el.querySelectorAll("[name=d]").length) {
          rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
        }
        if (el.querySelectorAll(":enabled").length !== 2) {
          rbuggyQSA.push(":enabled", ":disabled");
        }
        docElem.appendChild(el).disabled = true;
        if (el.querySelectorAll(":disabled").length !== 2) {
          rbuggyQSA.push(":enabled", ":disabled");
        }
        el.querySelectorAll("*,:x");
        rbuggyQSA.push(",.*:");
      });
    }
    if (support.matchesSelector = rnative.test(
      matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector
    )) {
      assert9(function(el) {
        support.disconnectedMatch = matches.call(el, "*");
        matches.call(el, "[s!='']:x");
        rbuggyMatches.push("!=", pseudos);
      });
    }
    rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
    rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
    hasCompare = rnative.test(docElem.compareDocumentPosition);
    contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
      var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
      return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
    } : function(a, b) {
      if (b) {
        while (b = b.parentNode) {
          if (b === a) {
            return true;
          }
        }
      }
      return false;
    };
    sortOrder = hasCompare ? function(a, b) {
      if (a === b) {
        hasDuplicate = true;
        return 0;
      }
      var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
      if (compare) {
        return compare;
      }
      compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : (
        // Otherwise we know they are disconnected
        1
      );
      if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
        if (a == document2 || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
          return -1;
        }
        if (b == document2 || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
          return 1;
        }
        return sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
      }
      return compare & 4 ? -1 : 1;
    } : function(a, b) {
      if (a === b) {
        hasDuplicate = true;
        return 0;
      }
      var cur, i3 = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
      if (!aup || !bup) {
        return a == document2 ? -1 : b == document2 ? 1 : (
          /* eslint-enable eqeqeq */
          aup ? -1 : bup ? 1 : sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0
        );
      } else if (aup === bup) {
        return siblingCheck(a, b);
      }
      cur = a;
      while (cur = cur.parentNode) {
        ap.unshift(cur);
      }
      cur = b;
      while (cur = cur.parentNode) {
        bp.unshift(cur);
      }
      while (ap[i3] === bp[i3]) {
        i3++;
      }
      return i3 ? (
        // Do a sibling check if the nodes have a common ancestor
        siblingCheck(ap[i3], bp[i3])
      ) : (
        // Otherwise nodes in our document sort first
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        /* eslint-disable eqeqeq */
        ap[i3] == preferredDoc ? -1 : bp[i3] == preferredDoc ? 1 : (
          /* eslint-enable eqeqeq */
          0
        )
      );
    };
    return document2;
  };
  Sizzle.matches = function(expr, elements) {
    return Sizzle(expr, null, null, elements);
  };
  Sizzle.matchesSelector = function(elem, expr) {
    setDocument(elem);
    if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
      try {
        var ret = matches.call(elem, expr);
        if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
        // fragment in IE 9
        elem.document && elem.document.nodeType !== 11) {
          return ret;
        }
      } catch (e) {
        nonnativeSelectorCache(expr, true);
      }
    }
    return Sizzle(expr, document2, null, [elem]).length > 0;
  };
  Sizzle.contains = function(context, elem) {
    if ((context.ownerDocument || context) != document2) {
      setDocument(context);
    }
    return contains(context, elem);
  };
  Sizzle.attr = function(elem, name) {
    if ((elem.ownerDocument || elem) != document2) {
      setDocument(elem);
    }
    var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn6.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
    return val !== void 0 ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
  };
  Sizzle.escape = function(sel) {
    return (sel + "").replace(rcssescape, fcssescape);
  };
  Sizzle.error = function(msg) {
    throw new DOMException(`'${msg}' is not a valid selector`);
  };
  Sizzle.uniqueSort = function(results) {
    var elem, duplicates = [], j = 0, i3 = 0;
    hasDuplicate = !support.detectDuplicates;
    sortInput = !support.sortStable && results.slice(0);
    results.sort(sortOrder);
    if (hasDuplicate) {
      while (elem = results[i3++]) {
        if (elem === results[i3]) {
          j = duplicates.push(i3);
        }
      }
      while (j--) {
        results.splice(duplicates[j], 1);
      }
    }
    sortInput = null;
    return results;
  };
  getText = Sizzle.getText = function(elem) {
    var node, ret = "", i3 = 0, nodeType = elem.nodeType;
    if (!nodeType) {
      while (node = elem[i3++]) {
        ret += getText(node);
      }
    } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
      if (typeof elem.textContent === "string") {
        return elem.textContent;
      } else {
        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
          ret += getText(elem);
        }
      }
    } else if (nodeType === 3 || nodeType === 4) {
      return elem.nodeValue;
    }
    return ret;
  };
  Expr = Sizzle.selectors = {
    // Can be adjusted by the user
    cacheLength: 50,
    createPseudo: markFunction,
    match: matchExpr,
    attrHandle: {},
    find: {},
    relative: {
      ">": { dir: "parentNode", first: true },
      " ": { dir: "parentNode" },
      "+": { dir: "previousSibling", first: true },
      "~": { dir: "previousSibling" }
    },
    preFilter: {
      ATTR: function(match) {
        match[1] = match[1].replace(runescape, funescape);
        match[3] = (match[3] || match[4] || match[5] || "").replace(
          runescape,
          funescape
        );
        if (match[2] === "~=") {
          match[3] = " " + match[3] + " ";
        }
        return match.slice(0, 4);
      },
      CHILD: function(match) {
        match[1] = match[1].toLowerCase();
        if (match[1].slice(0, 3) === "nth") {
          if (!match[3]) {
            Sizzle.error(match[0]);
          }
          match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
          match[5] = +(match[7] + match[8] || match[3] === "odd");
        } else if (match[3]) {
          Sizzle.error(match[0]);
        }
        return match;
      },
      PSEUDO: function(match) {
        var excess, unquoted = !match[6] && match[2];
        if (matchExpr["CHILD"].test(match[0])) {
          return null;
        }
        if (match[3]) {
          match[2] = match[4] || match[5] || "";
        } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
        (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
        (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
          match[0] = match[0].slice(0, excess);
          match[2] = unquoted.slice(0, excess);
        }
        return match.slice(0, 3);
      }
    },
    filter: {
      TAG: function(nodeNameSelector) {
        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
        return nodeNameSelector === "*" ? function() {
          return true;
        } : function(elem) {
          return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
        };
      },
      CLASS: function(className) {
        var pattern = classCache[className + " "];
        return pattern || (pattern = new RegExp(
          "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)"
        )) && classCache(className, function(elem) {
          return pattern.test(
            typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
          );
        });
      },
      ATTR: function(name, operator, check) {
        return function(elem) {
          var result2 = Sizzle.attr(elem, name);
          if (result2 == null) {
            return operator === "!=";
          }
          if (!operator) {
            return true;
          }
          result2 += "";
          return operator === "=" ? result2 === check : operator === "!=" ? result2 !== check : operator === "^=" ? check && result2.indexOf(check) === 0 : operator === "*=" ? check && result2.indexOf(check) > -1 : operator === "$=" ? check && result2.slice(-check.length) === check : operator === "~=" ? (" " + result2.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result2 === check || result2.slice(0, check.length + 1) === check + "-" : false;
        };
      },
      CHILD: function(type, what, _argument, first, last) {
        var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
        return first === 1 && last === 0 ? (
          // Shortcut for :nth-*(n)
          function(elem) {
            return !!elem.parentNode;
          }
        ) : function(elem, _context, xml) {
          var cache6, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff2 = false;
          if (parent) {
            if (simple) {
              while (dir) {
                node = elem;
                while (node = node[dir]) {
                  if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                    return false;
                  }
                }
                start = dir = type === "only" && !start && "nextSibling";
              }
              return true;
            }
            start = [forward ? parent.firstChild : parent.lastChild];
            if (forward && useCache) {
              node = parent;
              outerCache = node[expando] || (node[expando] = {});
              uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
              cache6 = uniqueCache[type] || [];
              nodeIndex = cache6[0] === dirruns && cache6[1];
              diff2 = nodeIndex && cache6[2];
              node = nodeIndex && parent.childNodes[nodeIndex];
              while (node = ++nodeIndex && node && node[dir] || // Fallback to seeking `elem` from the start
              (diff2 = nodeIndex = 0) || start.pop()) {
                if (node.nodeType === 1 && ++diff2 && node === elem) {
                  uniqueCache[type] = [dirruns, nodeIndex, diff2];
                  break;
                }
              }
            } else {
              if (useCache) {
                node = elem;
                outerCache = node[expando] || (node[expando] = {});
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache6 = uniqueCache[type] || [];
                nodeIndex = cache6[0] === dirruns && cache6[1];
                diff2 = nodeIndex;
              }
              if (diff2 === false) {
                while (node = ++nodeIndex && node && node[dir] || (diff2 = nodeIndex = 0) || start.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff2) {
                    if (useCache) {
                      outerCache = node[expando] || (node[expando] = {});
                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      uniqueCache[type] = [dirruns, diff2];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
            }
            diff2 -= last;
            return diff2 === first || diff2 % first === 0 && diff2 / first >= 0;
          }
        };
      },
      PSEUDO: function(pseudo, argument) {
        var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
        if (fn[expando]) {
          return fn(argument);
        }
        if (fn.length > 1) {
          args = [pseudo, pseudo, "", argument];
          return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
            var idx, matched = fn(seed, argument), i3 = matched.length;
            while (i3--) {
              idx = indexOf2(seed, matched[i3]);
              seed[idx] = !(matches2[idx] = matched[i3]);
            }
          }) : function(elem) {
            return fn(elem, 0, args);
          };
        }
        return fn;
      }
    },
    pseudos: {
      // Potentially complex pseudos
      not: markFunction(function(selector) {
        var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
        return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
          var elem, unmatched = matcher(seed, null, xml, []), i3 = seed.length;
          while (i3--) {
            if (elem = unmatched[i3]) {
              seed[i3] = !(matches2[i3] = elem);
            }
          }
        }) : function(elem, _context, xml) {
          input[0] = elem;
          matcher(input, null, xml, results);
          input[0] = null;
          return !results.pop();
        };
      }),
      has: markFunction(function(selector) {
        return function(elem) {
          return Sizzle(selector, elem).length > 0;
        };
      }),
      contains: markFunction(function(text) {
        text = text.replace(runescape, funescape);
        return function(elem) {
          return (elem.textContent || getText(elem)).indexOf(text) > -1;
        };
      }),
      // "Whether an element is represented by a :lang() selector
      // is based solely on the element's language value
      // being equal to the identifier C,
      // or beginning with the identifier C immediately followed by "-".
      // The matching of C against the element's language value is performed case-insensitively.
      // The identifier C does not have to be a valid language name."
      // http://www.w3.org/TR/selectors/#lang-pseudo
      lang: markFunction(function(lang) {
        if (!ridentifier.test(lang || "")) {
          Sizzle.error("unsupported lang: " + lang);
        }
        lang = lang.replace(runescape, funescape).toLowerCase();
        return function(elem) {
          var elemLang;
          do {
            if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
              elemLang = elemLang.toLowerCase();
              return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
            }
          } while ((elem = elem.parentNode) && elem.nodeType === 1);
          return false;
        };
      }),
      // Miscellaneous
      target: function(elem) {
        var hash = window2.location && window2.location.hash;
        return hash && hash.slice(1) === elem.id;
      },
      root: function(elem) {
        return elem === docElem;
      },
      focus: function(elem) {
        return elem === document2.activeElement && (!document2.hasFocus || document2.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
      },
      // Boolean properties
      enabled: createDisabledPseudo(false),
      disabled: createDisabledPseudo(true),
      checked: function(elem) {
        var nodeName = elem.nodeName.toLowerCase();
        return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
      },
      selected: function(elem) {
        if (elem.parentNode) {
          elem.parentNode.selectedIndex;
        }
        return elem.selected === true;
      },
      // Contents
      empty: function(elem) {
        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
          if (elem.nodeType < 6) {
            return false;
          }
        }
        return true;
      },
      parent: function(elem) {
        return !Expr.pseudos["empty"](elem);
      },
      // Element/input types
      header: function(elem) {
        return rheader.test(elem.nodeName);
      },
      input: function(elem) {
        return rinputs.test(elem.nodeName);
      },
      button: function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === "button" || name === "button";
      },
      text: function(elem) {
        var attr;
        return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && // Support: IE<8
        // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
        ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
      },
      // Position-in-collection
      first: createPositionalPseudo(function() {
        return [0];
      }),
      last: createPositionalPseudo(function(_matchIndexes, length) {
        return [length - 1];
      }),
      eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
        return [argument < 0 ? argument + length : argument];
      }),
      even: createPositionalPseudo(function(matchIndexes, length) {
        var i3 = 0;
        for (; i3 < length; i3 += 2) {
          matchIndexes.push(i3);
        }
        return matchIndexes;
      }),
      odd: createPositionalPseudo(function(matchIndexes, length) {
        var i3 = 1;
        for (; i3 < length; i3 += 2) {
          matchIndexes.push(i3);
        }
        return matchIndexes;
      }),
      lt: createPositionalPseudo(function(matchIndexes, length, argument) {
        var i3 = argument < 0 ? argument + length : argument > length ? length : argument;
        for (; --i3 >= 0; ) {
          matchIndexes.push(i3);
        }
        return matchIndexes;
      }),
      gt: createPositionalPseudo(function(matchIndexes, length, argument) {
        var i3 = argument < 0 ? argument + length : argument;
        for (; ++i3 < length; ) {
          matchIndexes.push(i3);
        }
        return matchIndexes;
      })
    }
  };
  Expr.pseudos["nth"] = Expr.pseudos["eq"];
  for (i2 in {
    radio: true,
    checkbox: true,
    file: true,
    password: true,
    image: true
  }) {
    Expr.pseudos[i2] = createInputPseudo(i2);
  }
  for (i2 in { submit: true, reset: true }) {
    Expr.pseudos[i2] = createButtonPseudo(i2);
  }
  function setFilters() {
  }
  setFilters.prototype = Expr.filters = Expr.pseudos;
  Expr.setFilters = new setFilters();
  tokenize = Sizzle.tokenize = function(selector, parseOnly) {
    var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
    if (cached) {
      return parseOnly ? 0 : cached.slice(0);
    }
    soFar = selector;
    groups = [];
    preFilters = Expr.preFilter;
    while (soFar) {
      if (!matched || (match = rcomma.exec(soFar))) {
        if (match) {
          soFar = soFar.slice(match[0].length) || soFar;
        }
        groups.push(tokens = []);
      }
      matched = false;
      if (match = rcombinators.exec(soFar)) {
        matched = match.shift();
        tokens.push({
          value: matched,
          // Cast descendant combinators to space
          type: match[0].replace(rtrim, " ")
        });
        soFar = soFar.slice(matched.length);
      }
      for (type in Expr.filter) {
        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type,
            matches: match
          });
          soFar = soFar.slice(matched.length);
        }
      }
      if (!matched) {
        break;
      }
    }
    return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : (
      // Cache the tokens
      tokenCache(selector, groups).slice(0)
    );
  };
  function toSelector(tokens) {
    var i3 = 0, len = tokens.length, selector = "";
    for (; i3 < len; i3++) {
      selector += tokens[i3].value;
    }
    return selector;
  }
  function addCombinator(matcher, combinator, base) {
    var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && key === "parentNode", doneName = done++;
    return combinator.first ? (
      // Check against closest ancestor/preceding element
      function(elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
        return false;
      }
    ) : (
      // Check against all ancestor/preceding elements
      function(elem, context, xml) {
        var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return newCache[2] = oldCache[2];
              } else {
                uniqueCache[key] = newCache;
                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }
        return false;
      }
    );
  }
  function elementMatcher(matchers) {
    return matchers.length > 1 ? function(elem, context, xml) {
      var i3 = matchers.length;
      while (i3--) {
        if (!matchers[i3](elem, context, xml)) {
          return false;
        }
      }
      return true;
    } : matchers[0];
  }
  function multipleContexts(selector, contexts, results) {
    var i3 = 0, len = contexts.length;
    for (; i3 < len; i3++) {
      Sizzle(selector, contexts[i3], results);
    }
    return results;
  }
  function condense(unmatched, map2, filter2, context, xml) {
    var elem, newUnmatched = [], i3 = 0, len = unmatched.length, mapped = map2 != null;
    for (; i3 < len; i3++) {
      if (elem = unmatched[i3]) {
        if (!filter2 || filter2(elem, context, xml)) {
          newUnmatched.push(elem);
          if (mapped) {
            map2.push(i3);
          }
        }
      }
    }
    return newUnmatched;
  }
  function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
    if (postFilter && !postFilter[expando]) {
      postFilter = setMatcher(postFilter);
    }
    if (postFinder && !postFinder[expando]) {
      postFinder = setMatcher(postFinder, postSelector);
    }
    return markFunction(function(seed, results, context, xml) {
      var temp, i3, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
        selector || "*",
        context.nodeType ? [context] : context,
        []
      ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? (
        // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || (seed ? preFilter : preexisting || postFilter) ? (
          // ...intermediate processing is necessary
          []
        ) : (
          // ...otherwise use results directly
          results
        )
      ) : matcherIn;
      if (matcher) {
        matcher(matcherIn, matcherOut, context, xml);
      }
      if (postFilter) {
        temp = condense(matcherOut, postMap);
        postFilter(temp, [], context, xml);
        i3 = temp.length;
        while (i3--) {
          if (elem = temp[i3]) {
            matcherOut[postMap[i3]] = !(matcherIn[postMap[i3]] = elem);
          }
        }
      }
      if (seed) {
        if (postFinder || preFilter) {
          if (postFinder) {
            temp = [];
            i3 = matcherOut.length;
            while (i3--) {
              if (elem = matcherOut[i3]) {
                temp.push(matcherIn[i3] = elem);
              }
            }
            postFinder(null, matcherOut = [], temp, xml);
          }
          i3 = matcherOut.length;
          while (i3--) {
            if ((elem = matcherOut[i3]) && (temp = postFinder ? indexOf2(seed, elem) : preMap[i3]) > -1) {
              seed[temp] = !(results[temp] = elem);
            }
          }
        }
      } else {
        matcherOut = condense(
          matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
        );
        if (postFinder) {
          postFinder(null, results, matcherOut, xml);
        } else {
          push2.apply(results, matcherOut);
        }
      }
    });
  }
  function matcherFromTokens(tokens) {
    var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i3 = leadingRelative ? 1 : 0, matchContext = addCombinator(
      function(elem) {
        return elem === checkContext;
      },
      implicitRelative,
      true
    ), matchAnyContext = addCombinator(
      function(elem) {
        return indexOf2(checkContext, elem) > -1;
      },
      implicitRelative,
      true
    ), matchers = [
      function(elem, context, xml) {
        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
        checkContext = null;
        return ret;
      }
    ];
    for (; i3 < len; i3++) {
      if (matcher = Expr.relative[tokens[i3].type]) {
        matchers = [addCombinator(elementMatcher(matchers), matcher)];
      } else {
        matcher = Expr.filter[tokens[i3].type].apply(null, tokens[i3].matches);
        if (matcher[expando]) {
          j = ++i3;
          for (; j < len; j++) {
            if (Expr.relative[tokens[j].type]) {
              break;
            }
          }
          return setMatcher(
            i3 > 1 && elementMatcher(matchers),
            i3 > 1 && toSelector(
              // If the preceding token was a descendant combinator, insert an implicit any-element `*`
              tokens.slice(0, i3 - 1).concat({ value: tokens[i3 - 2].type === " " ? "*" : "" })
            ).replace(rtrim, "$1"),
            matcher,
            i3 < j && matcherFromTokens(tokens.slice(i3, j)),
            j < len && matcherFromTokens(tokens = tokens.slice(j)),
            j < len && toSelector(tokens)
          );
        }
        matchers.push(matcher);
      }
    }
    return elementMatcher(matchers);
  }
  function matcherFromGroupMatchers(elementMatchers, setMatchers) {
    var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
      var elem, j, matcher, matchedCount = 0, i3 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
      if (outermost) {
        outermostContext = context == document2 || context || outermost;
      }
      for (; i3 !== len && (elem = elems[i3]) != null; i3++) {
        if (byElement && elem) {
          j = 0;
          if (!context && elem.ownerDocument != document2) {
            setDocument(elem);
            xml = !documentIsHTML;
          }
          while (matcher = elementMatchers[j++]) {
            if (matcher(elem, context || document2, xml)) {
              results.push(elem);
              break;
            }
          }
          if (outermost) {
            dirruns = dirrunsUnique;
          }
        }
        if (bySet) {
          if (elem = !matcher && elem) {
            matchedCount--;
          }
          if (seed) {
            unmatched.push(elem);
          }
        }
      }
      matchedCount += i3;
      if (bySet && i3 !== matchedCount) {
        j = 0;
        while (matcher = setMatchers[j++]) {
          matcher(unmatched, setMatched, context, xml);
        }
        if (seed) {
          if (matchedCount > 0) {
            while (i3--) {
              if (!(unmatched[i3] || setMatched[i3])) {
                setMatched[i3] = pop.call(results);
              }
            }
          }
          setMatched = condense(setMatched);
        }
        push2.apply(results, setMatched);
        if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
          Sizzle.uniqueSort(results);
        }
      }
      if (outermost) {
        dirruns = dirrunsUnique;
        outermostContext = contextBackup;
      }
      return unmatched;
    };
    return bySet ? markFunction(superMatcher) : superMatcher;
  }
  compile = Sizzle.compile = function(selector, match) {
    var i3, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
    if (!cached) {
      if (!match) {
        match = tokenize(selector);
      }
      i3 = match.length;
      while (i3--) {
        cached = matcherFromTokens(match[i3]);
        if (cached[expando]) {
          setMatchers.push(cached);
        } else {
          elementMatchers.push(cached);
        }
      }
      cached = compilerCache(
        selector,
        matcherFromGroupMatchers(elementMatchers, setMatchers)
      );
      cached.selector = selector;
    }
    return cached;
  };
  select = Sizzle.select = function(selector, context, results, seed) {
    var i3, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
    results = results || [];
    if (match.length === 1) {
      tokens = match[0] = match[0].slice(0);
      if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
        context = (Expr.find["ID"](
          token.matches[0].replace(runescape, funescape),
          context
        ) || [])[0];
        if (!context) {
          return results;
        } else if (compiled) {
          context = context.parentNode;
        }
        selector = selector.slice(tokens.shift().value.length);
      }
      i3 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
      while (i3--) {
        token = tokens[i3];
        if (Expr.relative[type = token.type]) {
          break;
        }
        if (find = Expr.find[type]) {
          if (seed = find(
            token.matches[0].replace(runescape, funescape),
            rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
          )) {
            tokens.splice(i3, 1);
            selector = seed.length && toSelector(tokens);
            if (!selector) {
              push2.apply(results, seed);
              return results;
            }
            break;
          }
        }
      }
    }
    (compiled || compile(selector, match))(
      seed,
      context,
      !documentIsHTML,
      results,
      !context || rsibling.test(selector) && testContext(context.parentNode) || context
    );
    return results;
  };
  support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
  support.detectDuplicates = !!hasDuplicate;
  setDocument();
  support.sortDetached = assert9(function(el) {
    return el.compareDocumentPosition(document2.createElement("fieldset")) & 1;
  });
  if (!assert9(function(el) {
    el.innerHTML = "<a href='#'></a>";
    return el.firstChild.getAttribute("href") === "#";
  })) {
    addHandle("type|href|height|width", function(elem, name, isXML2) {
      if (!isXML2) {
        return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
      }
    });
  }
  if (!support.attributes || !assert9(function(el) {
    el.innerHTML = "<input/>";
    el.firstChild.setAttribute("value", "");
    return el.firstChild.getAttribute("value") === "";
  })) {
    addHandle("value", function(elem, _name, isXML2) {
      if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
        return elem.defaultValue;
      }
    });
  }
  if (!assert9(function(el) {
    return el.getAttribute("disabled") == null;
  })) {
    addHandle(booleans, function(elem, name, isXML2) {
      var val;
      if (!isXML2) {
        return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
      }
    });
  }
  var _sizzle = window2.Sizzle;
  Sizzle.noConflict = function() {
    if (window2.Sizzle === Sizzle) {
      window2.Sizzle = _sizzle;
    }
    return Sizzle;
  };
  if (typeof define === "function" && define.amd) {
    define(function() {
      return Sizzle;
    });
  } else if (typeof module !== "undefined" && module.exports) {
    module.exports = Sizzle;
  } else {
    window2.Sizzle = Sizzle;
  }
}

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/sizzle-types.ts
var DOM2 = sizzle_default;

// https://deno.land/x/deno_dom@v0.1.43/src/dom/selectors/selectors.ts
var codeGenerationAllowed = null;
function getSelectorEngine() {
  if (codeGenerationAllowed === null) {
    try {
      new Function("");
      codeGenerationAllowed = true;
    } catch (e) {
      codeGenerationAllowed = false;
    }
  }
  if (codeGenerationAllowed) {
    return DOM;
  } else {
    return DOM2;
  }
}

// https://deno.land/x/deno_dom@v0.1.43/src/dom/document.ts
var DOMImplementation = class {
  constructor(key) {
    if (key !== CTOR_KEY) {
      throw new TypeError("Illegal constructor.");
    }
  }
  createDocument() {
    throw new Error("Unimplemented");
  }
  createHTMLDocument(titleStr) {
    titleStr += "";
    const doc = new HTMLDocument(CTOR_KEY);
    const docType = new DocumentType("html", "", "", CTOR_KEY);
    doc.appendChild(docType);
    const html = new Element2("html", doc, [], CTOR_KEY);
    html._setOwnerDocument(doc);
    const head = new Element2("head", html, [], CTOR_KEY);
    const body = new Element2("body", html, [], CTOR_KEY);
    const title = new Element2("title", head, [], CTOR_KEY);
    const titleText = new Text2(titleStr);
    title.appendChild(titleText);
    doc.head = head;
    doc.body = body;
    return doc;
  }
  createDocumentType(qualifiedName, publicId, systemId) {
    const doctype = new DocumentType(
      qualifiedName,
      publicId,
      systemId,
      CTOR_KEY
    );
    return doctype;
  }
};
var DocumentType = class _DocumentType extends Node {
  #qualifiedName = "";
  #publicId = "";
  #systemId = "";
  constructor(name, publicId, systemId, key) {
    super(
      "html",
      10 /* DOCUMENT_TYPE_NODE */,
      null,
      key
    );
    this.#qualifiedName = name;
    this.#publicId = publicId;
    this.#systemId = systemId;
  }
  get name() {
    return this.#qualifiedName;
  }
  get publicId() {
    return this.#publicId;
  }
  get systemId() {
    return this.#systemId;
  }
  _shallowClone() {
    return new _DocumentType(
      this.#qualifiedName,
      this.#publicId,
      this.#systemId,
      CTOR_KEY
    );
  }
};
var Document2 = class _Document extends Node {
  head = null;
  body = null;
  implementation;
  #lockState = false;
  #documentURI = "about:blank";
  // TODO
  #title = "";
  #nwapi = null;
  constructor() {
    super(
      "#document",
      9 /* DOCUMENT_NODE */,
      null,
      CTOR_KEY
    );
    this.implementation = new DOMImplementation(CTOR_KEY);
  }
  _shallowClone() {
    return new _Document();
  }
  // Expose the document's NWAPI for Element's access to
  // querySelector/querySelectorAll
  get _nwapi() {
    return this.#nwapi || (this.#nwapi = getSelectorEngine()(this));
  }
  get documentURI() {
    return this.#documentURI;
  }
  get title() {
    return this.querySelector("title")?.textContent || "";
  }
  get cookie() {
    return "";
  }
  set cookie(newCookie) {
  }
  get visibilityState() {
    return "visible";
  }
  get hidden() {
    return false;
  }
  get compatMode() {
    return "CSS1Compat";
  }
  get documentElement() {
    for (const node of this.childNodes) {
      if (node.nodeType === 1 /* ELEMENT_NODE */) {
        return node;
      }
    }
    return null;
  }
  get doctype() {
    for (const node of this.childNodes) {
      if (node.nodeType === 10 /* DOCUMENT_TYPE_NODE */) {
        return node;
      }
    }
    return null;
  }
  get childElementCount() {
    let count4 = 0;
    for (const { nodeType } of this.childNodes) {
      if (nodeType === 1 /* ELEMENT_NODE */) {
        count4++;
      }
    }
    return count4;
  }
  appendChild(child) {
    super.appendChild(child);
    child._setOwnerDocument(this);
    return child;
  }
  createElement(tagName, options) {
    tagName = tagName.toUpperCase();
    switch (tagName) {
      case "TEMPLATE": {
        const frag = new DocumentFragment2();
        const elm = new HTMLTemplateElement(
          null,
          [],
          CTOR_KEY,
          frag
        );
        elm._setOwnerDocument(this);
        return elm;
      }
      default: {
        const elm = new Element2(tagName, null, [], CTOR_KEY);
        elm._setOwnerDocument(this);
        return elm;
      }
    }
  }
  createElementNS(namespace, qualifiedName, options) {
    if (namespace === "http://www.w3.org/1999/xhtml") {
      return this.createElement(qualifiedName, options);
    } else {
      throw new Error(
        `createElementNS: "${namespace}" namespace unimplemented`
      );
    }
  }
  createTextNode(data) {
    return new Text2(data);
  }
  createComment(data) {
    return new Comment2(data);
  }
  createDocumentFragment() {
    const fragment = new DocumentFragment2();
    fragment._setOwnerDocument(this);
    return fragment;
  }
  importNode(node, deep = false) {
    const copy7 = node.cloneNode(deep);
    copy7._setOwnerDocument(this);
    return copy7;
  }
  adoptNode(node) {
    if (node instanceof _Document) {
      throw new DOMException(
        "Adopting a Document node is not supported.",
        "NotSupportedError"
      );
    }
    node._setParent(null);
    node._setOwnerDocument(this);
    return node;
  }
  querySelector(selectors) {
    return this._nwapi.first(selectors, this);
  }
  querySelectorAll(selectors) {
    const nodeList = new NodeList();
    const mutator = nodeList[nodeListMutatorSym]();
    for (const match of this._nwapi.select(selectors, this)) {
      mutator.push(match);
    }
    return nodeList;
  }
  // TODO: DRY!!!
  getElementById(id) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        if (child.id === id) {
          return child;
        }
        const search2 = child.getElementById(id);
        if (search2) {
          return search2;
        }
      }
    }
    return null;
  }
  getElementsByTagName(tagName) {
    if (tagName === "*") {
      return this.documentElement ? this._getElementsByTagNameWildcard(
        this.documentElement,
        []
      ) : [];
    } else {
      return this._getElementsByTagName(tagName.toUpperCase(), []);
    }
  }
  _getElementsByTagNameWildcard(node, search2) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        search2.push(child);
        child._getElementsByTagNameWildcard(search2);
      }
    }
    return search2;
  }
  _getElementsByTagName(tagName, search2) {
    for (const child of this.childNodes) {
      if (child.nodeType === 1 /* ELEMENT_NODE */) {
        if (child.tagName === tagName) {
          search2.push(child);
        }
        child._getElementsByTagName(tagName, search2);
      }
    }
    return search2;
  }
  getElementsByTagNameNS(_namespace, localName) {
    return this.getElementsByTagName(localName);
  }
  getElementsByClassName(className) {
    return getElementsByClassName(this, className, []);
  }
  hasFocus() {
    return true;
  }
};
var HTMLDocument = class _HTMLDocument extends Document2 {
  constructor(key) {
    if (key !== CTOR_KEY) {
      throw new TypeError("Illegal constructor.");
    }
    super();
  }
  _shallowClone() {
    return new _HTMLDocument(CTOR_KEY);
  }
};
utils_types_default.Document = Document2;

// https://deno.land/x/deno_dom@v0.1.43/src/deserialize.ts
function nodesFromString(html) {
  const parsed = JSON.parse(parse18(html));
  const node = nodeFromArray(parsed, null);
  return node;
}
function fragmentNodesFromString(html, contextLocalName) {
  const parsed = JSON.parse(parseFrag(html, contextLocalName));
  const node = nodeFromArray(parsed, null);
  return node;
}
function nodeFromArray(data, parentNode) {
  if (data[1] === "template") {
    const content = nodeFromArray(data[3], null);
    const contentFrag = new DocumentFragment2();
    const fragMutator = contentFrag._getChildNodesMutator();
    for (const child of content.childNodes) {
      fragMutator.push(child);
      child._setParent(contentFrag);
    }
    return new HTMLTemplateElement(
      parentNode,
      data[2],
      CTOR_KEY,
      contentFrag
    );
  }
  const elm = new Element2(data[1], parentNode, data[2], CTOR_KEY);
  const childNodes = elm._getChildNodesMutator();
  let childNode;
  for (const child of data.slice(3)) {
    switch (child[0]) {
      case 3 /* TEXT_NODE */:
        childNode = new Text2(child[1]);
        childNode.parentNode = childNode.parentElement = elm;
        childNodes.push(childNode);
        break;
      case 8 /* COMMENT_NODE */:
        childNode = new Comment2(child[1]);
        childNode.parentNode = childNode.parentElement = elm;
        childNodes.push(childNode);
        break;
      case 9 /* DOCUMENT_NODE */:
      case 1 /* ELEMENT_NODE */:
        nodeFromArray(child, elm);
        break;
      case 10 /* DOCUMENT_TYPE_NODE */:
        childNode = new DocumentType(child[1], child[2], child[3], CTOR_KEY);
        childNode.parentNode = childNode.parentElement = elm;
        childNodes.push(childNode);
        break;
    }
  }
  return elm;
}

// https://deno.land/x/deno_dom@v0.1.43/src/dom/dom-parser.ts
var DOMParser = class {
  parseFromString(source, mimeType) {
    if (mimeType !== "text/html") {
      throw new Error(`DOMParser: "${mimeType}" unimplemented`);
    }
    const doc = new HTMLDocument(CTOR_KEY);
    const fakeDoc = nodesFromString(source);
    let htmlNode = null;
    let hasDoctype = false;
    for (const child of [...fakeDoc.childNodes]) {
      doc.appendChild(child);
      if (child instanceof DocumentType) {
        hasDoctype = true;
      } else if (child.nodeName === "HTML") {
        htmlNode = child;
      }
    }
    if (!hasDoctype) {
      const docType = new DocumentType("html", "", "", CTOR_KEY);
      if (doc.childNodes.length === 0) {
        doc.appendChild(docType);
      } else {
        doc.insertBefore(docType, doc.childNodes[0]);
      }
    }
    if (htmlNode) {
      for (const child of htmlNode.childNodes) {
        switch (child.tagName) {
          case "HEAD":
            doc.head = child;
            break;
          case "BODY":
            doc.body = child;
            break;
        }
      }
    }
    return doc;
  }
};

// https://deno.land/x/deno_dom@v0.1.43/src/api.ts
var oldHasInstance = Array[Symbol.hasInstance];
Object.defineProperty(Array, Symbol.hasInstance, {
  value(value) {
    switch (value?.constructor) {
      case HTMLCollection:
      case NodeList:
        return false;
      default:
        return oldHasInstance.call(this, value);
    }
  },
  configurable: true
});
var oldIsArray = Array.isArray;
Object.defineProperty(Array, "isArray", {
  value: (value) => {
    switch (value?.constructor) {
      case HTMLCollection:
      case NodeList:
        return false;
      default:
        return oldIsArray.call(Array, value);
    }
  },
  configurable: true
});

// https://deno.land/x/deno_dom@v0.1.43/deno-dom-wasm.ts
await deno_wasm_default();
register(
  parse17,
  parse_frag
);

// https://deno.land/x/quickr@0.6.54/main/file_system.js
ensure({ denoVersion: "1.17.1" });
var cache4 = {};
var PathInfo2 = class {
  constructor({ path: path10, _lstatData, _statData }) {
    this.path = path10;
    this._lstat = _lstatData;
    this._data = _statData;
  }
  // 
  // core data sources
  // 
  refresh() {
    this._lstat = null;
    this._data = null;
  }
  get lstat() {
    if (!this._lstat) {
      try {
        this._lstat = Deno.lstatSync(this.path);
      } catch (error) {
        this._lstat = { doesntExist: true };
      }
    }
    return this._lstat;
  }
  get stat() {
    if (!this._stat) {
      const lstat = this.lstat;
      if (!lstat.isSymlink) {
        this._stat = {
          isBrokenLink: false,
          isLoopOfLinks: false
        };
      } else {
        try {
          this._stat = Deno.statSync(this.path);
        } catch (error) {
          this._stat = {};
          if (error.message.match(/^Too many levels of symbolic links/)) {
            this._stat.isBrokenLink = true;
            this._stat.isLoopOfLinks = true;
          } else if (error.message.match(/^No such file or directory/)) {
            this._stat.isBrokenLink = true;
          } else {
            throw error;
          }
        }
      }
    }
    return this._stat;
  }
  // 
  // main attributes
  // 
  get exists() {
    const lstat = this.lstat;
    return !lstat.doesntExist;
  }
  get name() {
    return parse3(this.path).name;
  }
  get extension() {
    return parse3(this.path).ext;
  }
  get basename() {
    return this.path && basename3(this.path);
  }
  get parentPath() {
    return this.path && dirname3(this.path);
  }
  relativePathFrom(parentPath) {
    return relative3(parentPath, this.path);
  }
  get link() {
    const lstat = this.lstat;
    if (lstat.isSymlink) {
      return Deno.readLinkSync(this.path);
    } else {
      return null;
    }
  }
  get isSymlink() {
    const lstat = this.lstat;
    return !!lstat.isSymlink;
  }
  get isRelativeSymlink() {
    const lstat = this.lstat;
    const isNotSymlink = !lstat.isSymlink;
    if (isNotSymlink) {
      return false;
    }
    const relativeOrAbsolutePath = Deno.readLinkSync(this.path);
    return !isAbsolute3(relativeOrAbsolutePath);
  }
  get isAbsoluteSymlink() {
    const lstat = this.lstat;
    const isNotSymlink = !lstat.isSymlink;
    if (isNotSymlink) {
      return false;
    }
    const relativeOrAbsolutePath = Deno.readLinkSync(this.path);
    return isAbsolute3(relativeOrAbsolutePath);
  }
  get isBrokenLink() {
    const stat = this.stat;
    return !!stat.isBrokenLink;
  }
  get isLoopOfLinks() {
    const stat = this.stat;
    return !!stat.isLoopOfLinks;
  }
  get isFile() {
    const lstat = this.lstat;
    if (lstat.doesntExist) {
      return false;
    }
    if (!lstat.isSymlink) {
      return lstat.isFile;
    } else {
      return !!this.stat.isFile;
    }
  }
  get isFolder() {
    const lstat = this.lstat;
    if (lstat.doesntExist) {
      return false;
    }
    if (!lstat.isSymlink) {
      return lstat.isDirectory;
    } else {
      return !!this.stat.isDirectory;
    }
  }
  get sizeInBytes() {
    const lstat = this.lstat;
    return lstat.size;
  }
  get permissions() {
    const { mode } = this.lstat;
    return {
      owner: {
        //          rwxrwxrwx
        canRead: !!(256 & mode),
        canWrite: !!(128 & mode),
        canExecute: !!(64 & mode)
      },
      group: {
        canRead: !!(32 & mode),
        canWrite: !!(16 & mode),
        canExecute: !!(8 & mode)
      },
      others: {
        canRead: !!(4 & mode),
        canWrite: !!(2 & mode),
        canExecute: !!(1 & mode)
      }
    };
  }
  // aliases
  get isDirectory() {
    return this.isFolder;
  }
  get dirname() {
    return this.parentPath;
  }
  toJSON() {
    return {
      exists: this.exists,
      name: this.name,
      extension: this.extension,
      basename: this.basename,
      parentPath: this.parentPath,
      isSymlink: this.isSymlink,
      isBrokenLink: this.isBrokenLink,
      isLoopOfLinks: this.isLoopOfLinks,
      isFile: this.isFile,
      isFolder: this.isFolder,
      sizeInBytes: this.sizeInBytes,
      permissions: this.permissions,
      isDirectory: this.isDirectory,
      dirname: this.dirname
    };
  }
};
var defaultOptionsHelper2 = (options) => ({
  renameExtension: options.renameExtension || FileSystem2.defaultRenameExtension,
  overwrite: options.overwrite
});
var fileLockSymbol2 = Symbol.for("fileLock");
var locker2 = globalThis[fileLockSymbol2] || {};
var grabPathLock2 = async (path10) => {
  while (locker2[path10]) {
    await new Promise((resolve15) => setTimeout(resolve15, 70));
  }
  locker2[path10] = true;
};
var pathStandardize2 = (path10) => {
  path10 = path10.path || path10;
  if (typeof path10 == "string" && path10.startsWith("file:///")) {
    path10 = fromFileUrl3(path10);
  }
  return path10;
};
var FileSystem2 = {
  defaultRenameExtension: ".old",
  denoExecutablePath: Deno.execPath(),
  parentPath: dirname3,
  dirname: dirname3,
  basename: basename3,
  extname: extname3,
  join: join4,
  normalize: (path10) => normalize4(pathStandardize2(path10)).replace(/\/$/, ""),
  isAbsolutePath: isAbsolute3,
  isRelativePath: (...args) => !isAbsolute3(...args),
  makeRelativePath: ({ from, to }) => relative3(from.path || from, to.path || to),
  makeAbsolutePath: (path10) => {
    if (!isAbsolute3(path10)) {
      return normalize4(join4(Deno.cwd(), path10));
    } else {
      return normalize4(path10);
    }
  },
  pathDepth(path10) {
    path10 = FileSystem2.normalize(path10);
    let count4 = 0;
    for (const eachChar of path10.path || path10) {
      if (eachChar == "/") {
        count4++;
      }
    }
    if (path10[0] == "/") {
      count4--;
    }
    return count4 + 1;
  },
  pathPieces(path10) {
    path10 = path10.path || path10;
    const result2 = parse3(path10);
    const folderList = [];
    let dirname15 = result2.dir;
    while (true) {
      folderList.push(basename3(dirname15));
      if (dirname15 == dirname3(dirname15)) {
        break;
      }
      dirname15 = dirname3(dirname15);
    }
    folderList.reverse();
    return [folderList, result2.name, result2.ext];
  },
  /**
   * add to name, preserve file extension
   *
   * @example
   * ```js
   * let newName = FileSystem.extendName({ path: "a/blah.thing.js", string: ".old" })
   * newName == "a/blah.old.thing.js"
   * ```
   *
   * @param arg1.path - item path
   * @param arg1.string - the string to append to the name
   * @return {string} - the new path
   */
  extendName({ path: path10, string: string2 }) {
    path10 = pathStandardize2(path10);
    const [name, ...extensions] = basename3(path10).split(".");
    return `${dirname3(path10)}/${name}${string2}${extensions.length == 0 ? "" : `.${extensions.join(".")}`}`;
  },
  /**
   * All Parent Paths
   *
   * @param {String} path - path doesnt need to exist
   * @return {[String]} longest to shortest parent path
   */
  allParentPaths(path10) {
    const pathStartsWithDotSlash = path10.startsWith("./");
    path10 = FileSystem2.normalize(path10);
    if (path10 === ".") {
      return [];
    }
    const dotGotRemoved = pathStartsWithDotSlash && !path10.startsWith("./");
    let previousPath = null;
    let allPaths = [];
    while (1) {
      previousPath = path10;
      path10 = FileSystem2.parentPath(path10);
      if (previousPath === path10) {
        break;
      }
      allPaths.push(path10);
    }
    allPaths.reverse();
    allPaths = allPaths.filter((each2) => each2 != ".");
    if (dotGotRemoved) {
      allPaths.push(".");
    }
    return allPaths;
  },
  pathOfCaller(callerNumber = void 0) {
    const err = new Error();
    let filePaths = findAll(/^.+file:\/\/(\/[\w\W]*?):/gm, err.stack).map((each2) => each2[1]);
    if (callerNumber) {
      filePaths = filePaths.slice(callerNumber);
    }
    try {
      const secondPath = filePaths[1];
      if (secondPath) {
        try {
          if (Deno.statSync(secondPath).isFile) {
            return secondPath;
          }
        } catch (error) {
        }
      }
    } catch (error) {
    }
    return Deno.cwd();
  },
  get home() {
    if (!cache4.home) {
      if (Deno.build.os != "windows") {
        cache4.home = Deno.env.get("HOME");
      } else {
        cache4.home = Deno.env.get("HOMEPATH");
      }
    }
    return cache4.home;
  },
  get workingDirectory() {
    return Deno.cwd();
  },
  set workingDirectory(value) {
    Deno.chdir(value);
  },
  get cwd() {
    return FileSystem2.workingDirectory;
  },
  set cwd(value) {
    return FileSystem2.workingDirectory = value;
  },
  get pwd() {
    return FileSystem2.cwd;
  },
  set pwd(value) {
    return FileSystem2.cwd = value;
  },
  cd(path10) {
    Deno.chdir(path10);
  },
  changeDirectory(path10) {
    Deno.chdir(path10);
  },
  get thisFile() {
    const err = new Error();
    const filePaths = findAll(/^.+file:\/\/(\/[\w\W]*?):/gm, err.stack).map((each2) => each2[1]);
    const firstPath = filePaths[0];
    if (firstPath) {
      try {
        if (Deno.statSync(firstPath).isFile) {
          return firstPath;
        }
      } catch (error) {
      }
    }
    return ":<interpreter>:";
  },
  get thisFolder() {
    const err = new Error();
    const filePaths = findAll(/^.+file:\/\/(\/[\w\W]*?):/gm, err.stack).map((each2) => each2[1]);
    const firstPath = filePaths[0];
    if (firstPath) {
      try {
        if (Deno.statSync(firstPath).isFile) {
          return dirname3(firstPath);
        }
      } catch (error) {
      }
    }
    return Deno.cwd();
  },
  async read(path10) {
    path10 = pathStandardize2(path10);
    await grabPathLock2(path10);
    let output2;
    try {
      output2 = await Deno.readTextFile(path10);
    } catch (error) {
    }
    delete locker2[path10];
    return output2;
  },
  async readBytes(path10) {
    path10 = pathStandardize2(path10);
    await grabPathLock2(path10);
    let output2;
    try {
      output2 = await Deno.readFile(path10);
    } catch (error) {
    }
    delete locker2[path10];
    return output2;
  },
  async *readLinesIteratively(path10) {
    path10 = pathStandardize2(path10);
    await grabPathLock2(path10);
    try {
      const file = await Deno.open(path10);
      try {
        yield* readLines(file);
      } finally {
        Deno.close(file.rid);
      }
    } finally {
      delete locker2[path10];
    }
  },
  async info(fileOrFolderPath, _cachedLstat = null) {
    fileOrFolderPath = pathStandardize2(fileOrFolderPath);
    await grabPathLock2(fileOrFolderPath);
    try {
      const lstat = _cachedLstat || await Deno.lstat(fileOrFolderPath).catch(() => ({ doesntExist: true }));
      let stat = {};
      if (!lstat.isSymlink) {
        stat = {
          isBrokenLink: false,
          isLoopOfLinks: false
        };
      } else {
        try {
          stat = await Deno.stat(fileOrFolderPath);
        } catch (error) {
          if (error.message.match(/^Too many levels of symbolic links/)) {
            stat.isBrokenLink = true;
            stat.isLoopOfLinks = true;
          } else if (error.message.match(/^No such file or directory/)) {
            stat.isBrokenLink = true;
          } else {
            if (!error.message.match(/^PermissionDenied:/)) {
              return { doesntExist: true, permissionDenied: true };
            }
            throw error;
          }
        }
      }
      return new PathInfo2({ path: fileOrFolderPath, _lstatData: lstat, _statData: stat });
    } finally {
      delete locker2[fileOrFolderPath];
    }
  },
  async move({ path: path10, item, newParentFolder, newName, force = true, overwrite = false, renameExtension = null }) {
    item = item || path10;
    const oldPath = item.path || item;
    const oldName = FileSystem2.basename(oldPath);
    const pathInfo = item instanceof Object || FileSystem2.sync.info(oldPath);
    const newPath = `${newParentFolder || FileSystem2.parentPath(oldPath)}/${newName || oldName}`;
    if (pathInfo.isSymlink && !item.isBrokenLink) {
      const link2 = Deno.readLinkSync(pathInfo.path);
      if (!isAbsolute3(link2)) {
        const linkTargetBeforeMove = `${FileSystem2.parentPath(pathInfo.path)}/${link2}`;
        await FileSystem2.relativeLink({
          existingItem: linkTargetBeforeMove,
          newItem: newPath,
          force,
          overwrite,
          renameExtension
        });
        await FileSystem2.remove(pathInfo);
      }
    }
    if (force) {
      FileSystem2.sync.clearAPathFor(newPath, { overwrite, renameExtension });
    }
    await move(oldPath, newPath);
  },
  async remove(fileOrFolder) {
    fileOrFolder = pathStandardize2(fileOrFolder);
    if (fileOrFolder instanceof Array) {
      return Promise.all(fileOrFolder.map(FileSystem2.remove));
    }
    fileOrFolder = fileOrFolder.path || fileOrFolder;
    const pathInfo = await FileSystem2.info(fileOrFolder);
    if (pathInfo.isFile || pathInfo.isSymlink) {
      return Deno.remove(pathInfo.path.replace(/\/+$/, ""));
    } else if (pathInfo.exists) {
      return Deno.remove(pathInfo.path.replace(/\/+$/, ""), { recursive: true });
    }
  },
  async finalTargetOf(path10, options = {}) {
    const { _parentsHaveBeenChecked, cache: cache6 } = { _parentsHaveBeenChecked: false, cache: {}, ...options };
    const originalWasItem = path10 instanceof PathInfo2;
    path10 = path10.path || path10;
    let result2 = await Deno.lstat(path10).catch(() => ({ doesntExist: true }));
    if (result2.doesntExist) {
      return null;
    }
    path10 = await FileSystem2.makeHardPathTo(path10, { cache: cache6 });
    const pathChain = [];
    while (result2.isSymlink) {
      const relativeOrAbsolutePath = await Deno.readLink(path10);
      if (isAbsolute3(relativeOrAbsolutePath)) {
        path10 = relativeOrAbsolutePath;
      } else {
        path10 = `${FileSystem2.parentPath(path10)}/${relativeOrAbsolutePath}`;
      }
      result2 = await Deno.lstat(path10).catch(() => ({ doesntExist: true }));
      if (result2.doesntExist) {
        return null;
      }
      path10 = await FileSystem2.makeHardPathTo(path10, { cache: cache6 });
      if (pathChain.includes(path10)) {
        return null;
      }
      pathChain.push(path10);
    }
    path10 = FileSystem2.normalize(path10);
    if (originalWasItem) {
      return new PathInfo2({ path: path10 });
    } else {
      return path10;
    }
  },
  async nextTargetOf(path10, options = {}) {
    const originalWasItem = path10 instanceof PathInfo2;
    const item = originalWasItem ? path10 : new PathInfo2({ path: path10 });
    const lstat = item.lstat;
    if (lstat.isSymlink) {
      const relativeOrAbsolutePath = Deno.readLinkSync(item.path);
      if (isAbsolute3(relativeOrAbsolutePath)) {
        if (originalWasItem) {
          return new PathInfo2({ path: relativeOrAbsolutePath });
        } else {
          return relativeOrAbsolutePath;
        }
      } else {
        const path11 = `${await FileSystem2.makeHardPathTo(dirname3(item.path))}/${relativeOrAbsolutePath}`;
        if (originalWasItem) {
          return new PathInfo2({ path: path11 });
        } else {
          return path11;
        }
      }
    } else {
      if (originalWasItem) {
        return item;
      } else {
        return item.path;
      }
    }
  },
  async ensureIsFile(path10, options = { overwrite: false, renameExtension: null }) {
    const { overwrite, renameExtension } = defaultOptionsHelper2(options);
    await FileSystem2.ensureIsFolder(FileSystem2.parentPath(path10), { overwrite, renameExtension });
    path10 = path10.path || path10;
    const pathInfo = await FileSystem2.info(path10);
    if (pathInfo.isFile && !pathInfo.isDirectory) {
      return path10;
    } else {
      await FileSystem2.write({ path: path10, data: "" });
      return path10;
    }
  },
  async ensureIsFolder(path10, options = { overwrite: false, renameExtension: null }) {
    const { overwrite, renameExtension } = defaultOptionsHelper2(options);
    path10 = path10.path || path10;
    path10 = FileSystem2.makeAbsolutePath(path10);
    const parentPath = dirname3(path10);
    if (parentPath == path10) {
      return;
    }
    const parent = await FileSystem2.info(parentPath);
    if (!parent.isDirectory) {
      FileSystem2.sync.ensureIsFolder(parentPath, { overwrite, renameExtension });
    }
    let pathInfo = FileSystem2.sync.info(path10);
    if (pathInfo.exists && !pathInfo.isDirectory) {
      if (overwrite) {
        await FileSystem2.remove(path10);
      } else {
        await FileSystem2.moveOutOfTheWay(eachPath, { extension: renameExtension });
      }
    }
    await Deno.mkdir(path10, { recursive: true });
    return path10;
  },
  /**
   * Move/Remove everything and Ensure parent folders
   *
   * @param path
   * @param options.overwrite - if false, then things in the way will be moved instead of deleted
   * @param options.renameExtension - the string to append when renaming files to get them out of the way
   * 
   * @note
   *     very agressive: will change whatever is necessary to make sure a parent exists
   * 
   * @example
   * ```js
   * await FileSystem.clearAPathFor("./something")
   * ```
   */
  async clearAPathFor(path10, options = { overwrite: false, renameExtension: null }) {
    const { overwrite, renameExtension } = defaultOptionsHelper2(options);
    const originalPath = path10;
    const paths = [];
    while (dirname3(path10) !== path10) {
      paths.push(path10);
      path10 = dirname3(path10);
    }
    for (const eachPath2 of paths.reverse()) {
      const info = await FileSystem2.info(eachPath2);
      if (!info.exists) {
        break;
      } else if (info.isFile) {
        if (overwrite) {
          await FileSystem2.remove(eachPath2);
        } else {
          await FileSystem2.moveOutOfTheWay(eachPath2, { extension: renameExtension });
        }
      }
    }
    await Deno.mkdir(dirname3(originalPath), { recursive: true });
    return originalPath;
  },
  async moveOutOfTheWay(path10, options = { extension: null }) {
    const extension = options?.extension || FileSystem2.defaultRenameExtension;
    const info = await FileSystem2.info(path10);
    if (info.exists) {
      const newPath = path10 + extension;
      await FileSystem2.moveOutOfTheWay(newPath, { extension });
      await move(path10, newPath);
    }
  },
  /**
   * find a root folder based on a child path
   *
   * @example
   * ```js
   *     import { FileSystem } from "https://deno.land/x/quickr/main/file_system.js"
   * 
   *     var gitParentFolderOrNull = await FileSystem.walkUpUntil(".git")
   *     var gitParentFolderOrNull = await FileSystem.walkUpUntil({
   *         subPath:".git",
   *         startPath: FileSystem.pwd,
   *     })
   *
   *     // below will result in that^ same folder (assuming all your .git folders have config files)
   *     var gitParentFolderOrNull = await FileSystem.walkUpUntil(".git/config")
   * 
   *     // below will result in the same folder, but only if theres a local master branch
   *     var gitParentFolderOrNull = await FileSystem.walkUpUntil(".git/refs/heads/master")
   *```
   */
  async walkUpUntil(subPath, startPath = null) {
    subPath = subPath instanceof PathInfo2 ? subPath.path : subPath;
    if (subPath instanceof Object) {
      var { subPath, startPath } = subPath;
    }
    let here;
    if (!startPath) {
      here = Deno.cwd();
    } else if (isAbsolute3(startPath)) {
      here = startPath;
    } else {
      here = join4(here, startPath);
    }
    while (1) {
      let checkPath = join4(here, subPath);
      const pathInfo = await Deno.lstat(checkPath).catch(() => ({ doesntExist: true }));
      if (!pathInfo.doesntExist) {
        return here;
      }
      if (here == dirname3(here)) {
        return null;
      } else {
        here = dirname3(here);
      }
    }
  },
  // FIXME: make this work for folders with many options for how to handle symlinks
  async copy({ from, to, preserveTimestamps = true, force = true, overwrite = false, renameExtension = null }) {
    const existingItemDoesntExist = (await Deno.stat(from).catch(() => ({ doesntExist: true }))).doesntExist;
    if (existingItemDoesntExist) {
      throw Error(`
Tried to copy from:${from}, to:${to}
but "from" didn't seem to exist

`);
    }
    if (force) {
      FileSystem2.sync.clearAPathFor(to, { overwrite, renameExtension });
    }
    return copy(from, to, { force, preserveTimestamps: true });
  },
  async relativeLink({ existingItem, newItem, force = true, overwrite = false, allowNonExistingTarget = false, renameExtension = null }) {
    const existingItemPath = (existingItem.path || existingItem).replace(/\/+$/, "");
    const newItemPath = FileSystem2.normalize((newItem.path || newItem).replace(/\/+$/, ""));
    const existingItemDoesntExist = (await Deno.lstat(existingItemPath).catch(() => ({ doesntExist: true }))).doesntExist;
    if (!allowNonExistingTarget && existingItemDoesntExist) {
      throw Error(`
Tried to create a relativeLink between existingItem:${existingItemPath}, newItem:${newItemPath}
but existingItem didn't actually exist`);
    } else {
      const parentOfNewItem = FileSystem2.parentPath(newItemPath);
      await FileSystem2.ensureIsFolder(parentOfNewItem, { overwrite, renameExtension });
      const hardPathToNewItem = `${await FileSystem2.makeHardPathTo(parentOfNewItem)}/${FileSystem2.basename(newItemPath)}`;
      const hardPathToExistingItem = await FileSystem2.makeHardPathTo(existingItemPath);
      const pathFromNewToExisting = relative3(hardPathToNewItem, hardPathToExistingItem).replace(/^\.\.\//, "");
      if (force) {
        FileSystem2.sync.clearAPathFor(hardPathToNewItem, { overwrite, renameExtension });
      }
      return Deno.symlink(
        pathFromNewToExisting,
        hardPathToNewItem
      );
    }
  },
  async absoluteLink({ existingItem, newItem, force = true, allowNonExistingTarget = false, overwrite = false, renameExtension = null }) {
    existingItem = (existingItem.path || existingItem).replace(/\/+$/, "");
    const newItemPath = FileSystem2.normalize(newItem.path || newItem).replace(/\/+$/, "");
    const existingItemDoesntExist = (await Deno.lstat(existingItem).catch(() => ({ doesntExist: true }))).doesntExist;
    if (!allowNonExistingTarget && existingItemDoesntExist) {
      throw Error(`
Tried to create a relativeLink between existingItem:${existingItem}, newItemPath:${newItemPath}
but existingItem didn't actually exist`);
    } else {
      const parentOfNewItem = FileSystem2.parentPath(newItemPath);
      await FileSystem2.ensureIsFolder(parentOfNewItem, { overwrite, renameExtension });
      const hardPathToNewItem = `${await FileSystem2.makeHardPathTo(parentOfNewItem)}/${FileSystem2.basename(newItemPath)}`;
      if (force) {
        FileSystem2.sync.clearAPathFor(hardPathToNewItem, { overwrite, renameExtension });
      }
      return Deno.symlink(
        FileSystem2.makeAbsolutePath(existingItem),
        newItemPath
      );
    }
  },
  async *iterateBasenamesIn(pathOrFileInfo) {
    const info = pathOrFileInfo instanceof PathInfo2 ? pathOrFileInfo : await FileSystem2.info(pathOrFileInfo);
    if (info.isFolder) {
      for await (const dirEntry of Deno.readDir(info.path)) {
        yield dirEntry.name;
      }
    }
  },
  listBasenamesIn(pathOrFileInfo) {
    return asyncIteratorToList3(FileSystem2.iterateBasenamesIn(pathOrFileInfo));
  },
  async *iteratePathsIn(pathOrFileInfo, options = { recursively: false, shouldntInclude: null, shouldntExplore: null, searchOrder: "breadthFirstSearch", maxDepth: Infinity, dontFollowSymlinks: false, dontReturnSymlinks: false, maxDepthFromRoot: null }) {
    let info;
    try {
      info = pathOrFileInfo instanceof PathInfo2 ? pathOrFileInfo : await FileSystem2.info(pathOrFileInfo);
    } catch (error) {
      if (!error.message.match(/^PermissionDenied:/)) {
        throw error;
      }
    }
    const path10 = info.path;
    const startingDepth = FileSystem2.makeAbsolutePath(path10).split("/").length - 1;
    options.recursively = options.recursively == false && options.maxDepth == 1 ? false : options.recursively;
    if (options.maxDepthFromRoot == null) {
      options.maxDepthFromRoot = Infinity;
    }
    if (options.maxDepth != Infinity && options.maxDepth != null) {
      options.maxDepthFromRoot = startingDepth + options.maxDepth;
    }
    options.maxDepth = null;
    if (startingDepth < options.maxDepthFromRoot) {
      if (!options.recursively) {
        if (info.isFolder) {
          if (!options.shouldntInclude) {
            for await (const each2 of Deno.readDir(path10)) {
              if (options.dontReturnSymlinks && each2.isSymlink) {
                continue;
              }
              yield join4(path10, each2.name);
            }
          } else {
            const shouldntInclude = options.shouldntInclude;
            for await (const each2 of Deno.readDir(path10)) {
              const eachPath2 = join4(path10, each2.name);
              if (options.dontReturnSymlinks && each2.isSymlink) {
                continue;
              }
              const shouldntIncludeThis = shouldntInclude && await shouldntInclude(eachPath2);
              if (!shouldntIncludeThis) {
                yield eachPath2;
              }
            }
          }
        }
      } else {
        options = { exclude: /* @__PURE__ */ new Set(), searchOrder: "breadthFirstSearch", maxDepth: Infinity, ...options };
        options.searchOrder = options.searchOrder || "breadthFirstSearch";
        const { shouldntExplore, shouldntInclude } = options;
        if (!["breadthFirstSearch", "depthFirstSearch"].includes(options.searchOrder)) {
          throw Error(`when calling FileSystem.iterateItemsIn('${path10}', { searchOrder: ${options.searchOrder} })

    The searchOrder currently can only be 'depthFirstSearch' or 'breadthFirstSearch'
    However, it was not either of those: ${options.searchOrder}`);
        }
        const useBreadthFirstSearch = options.searchOrder == "breadthFirstSearch";
        const shouldntExploreThis = shouldntExplore && await shouldntExplore(info.path, info);
        if (!shouldntExploreThis && info.isFolder) {
          options.exclude = options.exclude instanceof Set ? options.exclude : new Set(options.exclude);
          if (!options.exclude.has(path10)) {
            const followSymlinks = !options.dontFollowSymlinks;
            const absolutePathVersion = FileSystem2.makeAbsolutePath(path10);
            options.exclude.add(absolutePathVersion);
            const searchAfterwords = [];
            for await (const entry of Deno.readDir(path10)) {
              const eachPath2 = join4(path10, entry.name);
              if (options.dontReturnSymlinks && each.isSymlink) {
                continue;
              }
              const shouldntIncludeThis = shouldntInclude && await shouldntInclude(eachPath2);
              if (!shouldntIncludeThis) {
                yield eachPath2;
              }
              if (entry.isFile) {
                continue;
              }
              if (followSymlinks && !entry.isDirectory) {
                let isSymlinkToDirectory = false;
                try {
                  isSymlinkToDirectory = (await Deno.stat(eachPath2)).isDirectory;
                } catch (error) {
                }
                if (!isSymlinkToDirectory) {
                  continue;
                }
              }
              if (useBreadthFirstSearch) {
                searchAfterwords.push(eachPath2);
              } else {
                for await (const eachSubPath of FileSystem2.iteratePathsIn(eachPath2, options)) {
                  yield eachSubPath;
                }
              }
            }
            options.recursively = false;
            while (searchAfterwords.length > 0) {
              const next = searchAfterwords.shift();
              for await (const eachSubPath of FileSystem2.iteratePathsIn(next, options)) {
                yield eachSubPath;
                searchAfterwords.push(eachSubPath);
              }
            }
          }
        }
      }
    }
  },
  listPathsIn(pathOrFileInfo, options) {
    return asyncIteratorToList3(FileSystem2.iteratePathsIn(pathOrFileInfo, options));
  },
  async *iterateItemsIn(pathOrFileInfo, options = { recursively: false, shouldntInclude: null, shouldntExplore: null, searchOrder: "breadthFirstSearch", maxDepth: Infinity }) {
    options = { exclude: /* @__PURE__ */ new Set(), searchOrder: "breadthFirstSearch", maxDepth: Infinity, ...options };
    options.searchOrder = options.searchOrder || "breadthFirstSearch";
    options.recursively = options.recursively == false && options.maxDepth == 1 ? false : options.recursively;
    const { shouldntExplore, shouldntInclude } = options;
    const info = pathOrFileInfo instanceof PathInfo2 ? pathOrFileInfo : await FileSystem2.info(pathOrFileInfo);
    const path10 = info.path;
    if (!["breadthFirstSearch", "depthFirstSearch"].includes(options.searchOrder)) {
      throw Error(`when calling FileSystem.iterateItemsIn('${path10}', { searchOrder: ${options.searchOrder} })

    The searchOrder currently can only be 'depthFirstSearch' or 'breadthFirstSearch'
    However, it was not either of those: ${options.searchOrder}`);
    }
    const useBreadthFirstSearch = options.searchOrder == "breadthFirstSearch";
    const shouldntExploreThis = shouldntExplore && await shouldntExplore(info);
    if (!shouldntExploreThis && options.maxDepth > 0 && info.isFolder) {
      options.exclude = options.exclude instanceof Set ? options.exclude : new Set(options.exclude);
      if (!options.exclude.has(path10)) {
        const absolutePathVersion = FileSystem2.makeAbsolutePath(path10);
        options.exclude.add(absolutePathVersion);
        options.maxDepth -= 1;
        const searchAfterwords = [];
        for await (const entry of Deno.readDir(path10)) {
          const eachItem = await FileSystem2.info(join4(path10, entry.name));
          const shouldntIncludeThis = shouldntInclude && await shouldntInclude(eachItem);
          if (!shouldntIncludeThis) {
            yield eachItem;
          }
          if (options.recursively) {
            if (eachItem.isFolder) {
              if (useBreadthFirstSearch) {
                searchAfterwords.push(eachItem);
              } else {
                for await (const eachSubPath of FileSystem2.iterateItemsIn(eachItem, options)) {
                  yield eachSubPath;
                }
              }
            }
          }
        }
        options.recursively = false;
        while (searchAfterwords.length > 0) {
          const next = searchAfterwords.shift();
          for await (const eachSubItem of FileSystem2.iterateItemsIn(next, options)) {
            yield eachSubItem;
            if (eachSubItem.isFolder) {
              searchAfterwords.push(eachSubItem);
            }
          }
        }
      }
    }
  },
  async listItemsIn(pathOrFileInfo, options) {
    const outputPromises = [];
    for await (const eachPath2 of FileSystem2.iteratePathsIn(pathOrFileInfo, options)) {
      outputPromises.push(FileSystem2.info(eachPath2));
    }
    return Promise.all(outputPromises);
  },
  // includes symlinks if they link to files and pipes
  async listFileItemsIn(pathOrFileInfo, options = { treatAllSymlinksAsFiles: false }) {
    const { treatAllSymlinksAsFiles } = { treatAllSymlinksAsFiles: false, ...options };
    const items = await FileSystem2.listItemsIn(pathOrFileInfo, options);
    if (treatAllSymlinksAsFiles) {
      return items.filter((eachItem) => eachItem.isFile || treatAllSymlinksAsFiles && eachItem.isSymlink);
    } else {
      return items.filter((eachItem) => eachItem.isFile);
    }
  },
  async listFilePathsIn(pathOrFileInfo, options = { treatAllSymlinksAsFiles: false }) {
    return (await FileSystem2.listFileItemsIn(pathOrFileInfo, options)).map((each2) => each2.path);
  },
  async listFileBasenamesIn(pathOrFileInfo, options = { treatAllSymlinksAsFiles: false }) {
    return (await FileSystem2.listFileItemsIn(pathOrFileInfo, options)).map((each2) => each2.basename);
  },
  async listFolderItemsIn(pathOrFileInfo, options = { ignoreSymlinks: false }) {
    const { ignoreSymlinks } = { ignoreSymlinks: false, ...options };
    const items = await FileSystem2.listItemsIn(pathOrFileInfo, options);
    if (ignoreSymlinks) {
      return items.filter((eachItem) => eachItem.isFolder && !eachItem.isSymlink);
    } else {
      return items.filter((eachItem) => eachItem.isFolder);
    }
  },
  async listFolderPathsIn(pathOrFileInfo, options = { ignoreSymlinks: false }) {
    return (await FileSystem2.listFolderItemsIn(pathOrFileInfo, options)).map((each2) => each2.path);
  },
  async listFolderBasenamesIn(pathOrFileInfo, options = { ignoreSymlinks: false }) {
    return (await FileSystem2.listFolderItemsIn(pathOrFileInfo, options)).map((each2) => each2.basename);
  },
  recursivelyIterateItemsIn(pathOrFileInfo, options = { onlyHardlinks: false, dontFollowSymlinks: false, searchOrder: "breadthFirstSearch", maxDepth: Infinity, shouldntExplore: null, shouldntInclude: null }) {
    options.recursively = true;
    if (options.onlyHardlinks) {
      if (options.shouldntInclude) {
        const originalshouldntInclude = options.shouldntInclude;
        options.shouldntInclude = (each2) => each2.isSymlink || originalshouldntInclude(each2);
      } else {
        options.shouldntInclude = (each2) => each2.isSymlink;
      }
    }
    if (options.dontFollowSymlinks) {
      if (options.shouldntExplore) {
        const originalShouldntExplore = options.shouldntInclude;
        options.shouldntExplore = (each2) => each2.isSymlink || originalShouldntExplore(each2);
      } else {
        options.shouldntExplore = (each2) => each2.isSymlink;
      }
    }
    return FileSystem2.iterateItemsIn(pathOrFileInfo, options);
  },
  recursivelyIteratePathsIn(pathOrFileInfo, options = { onlyHardlinks: false, dontFollowSymlinks: false, searchOrder: "breadthFirstSearch", maxDepth: Infinity, shouldntExplore: null, shouldntInclude: null }) {
    options.recursively = true;
    if (options.onlyHardlinks) {
      if (options.shouldntInclude) {
        const originalshouldntInclude = options.shouldntInclude;
        options.shouldntInclude = (each2) => each2.isSymlink || originalshouldntInclude(each2);
      } else {
        options.shouldntInclude = (each2) => each2.isSymlink;
      }
    }
    return FileSystem2.iteratePathsIn(pathOrFileInfo, options);
  },
  recursivelyListPathsIn(pathOrFileInfo, options = { onlyHardlinks: false, dontFollowSymlinks: false, searchOrder: "breadthFirstSearch", maxDepth: Infinity, shouldntExplore: null, shouldntInclude: null }) {
    return asyncIteratorToList3(FileSystem2.recursivelyIteratePathsIn(pathOrFileInfo, options));
  },
  recursivelyListItemsIn(pathOrFileInfo, options = { onlyHardlinks: false, dontFollowSymlinks: false, searchOrder: "breadthFirstSearch", maxDepth: Infinity, shouldntExplore: null, shouldntInclude: null }) {
    return asyncIteratorToList3(FileSystem2.recursivelyIterateItemsIn(pathOrFileInfo, options));
  },
  async *globIterator(pattern, options = { startPath: null }) {
    pattern = FileSystem2.normalize(pattern);
    var { startPath, ...iteratePathsOptions } = options;
    startPath = startPath || "./";
    const originalStartPath = startPath;
    startPath = FileSystem2.makeAbsolutePath(startPath);
    const firstGlob = pattern.indexOf("*");
    if (firstGlob != -1) {
      const startingString = pattern.slice(0, firstGlob);
      const furthestConstantSlash = startingString.lastIndexOf("/");
      if (furthestConstantSlash != -1) {
        if (pattern[0] == "/") {
          startPath = pattern.slice(0, furthestConstantSlash);
        } else {
          startPath = `${startPath}/${pattern.slice(0, furthestConstantSlash)}`;
        }
      }
      pattern = pattern.slice(furthestConstantSlash + 1);
    }
    let maxDepthFromRoot;
    if (pattern.match(/\*\*/)) {
      maxDepthFromRoot = Infinity;
    } else {
      maxDepthFromRoot = `${FileSystem2.makeAbsolutePath(startPath)}/${pattern}`.split("/").length - 1;
    }
    const fullPattern = `${startPath}/${pattern}`;
    const regex3 = globToRegExp2(fullPattern);
    const partials = fullPattern.split("/");
    let partialPattern = partials.shift();
    let partialRegexString = `^\\.$|${globToRegExp2(partialPattern).source}`;
    for (const each2 of partials) {
      partialPattern += "/" + each2;
      partialRegexString += "|" + globToRegExp2(partialPattern).source;
    }
    const partialRegex = new RegExp(partialRegexString);
    for await (const eachPath2 of FileSystem2.iteratePathsIn(startPath, { recursively: true, maxDepthFromRoot, ...iteratePathsOptions, shouldntExplore: (eachPath3) => !eachPath3.match(partialRegex) })) {
      if (eachPath2.match(regex3) || FileSystem2.makeAbsolutePath(eachPath2).match(regex3)) {
        yield FileSystem2.makeRelativePath({
          from: originalStartPath,
          to: eachPath2
        });
      }
    }
  },
  glob(pattern, options = { startPath: null }) {
    return asyncIteratorToList3(FileSystem2.globIterator(pattern, options));
  },
  async getPermissions({ path: path10 }) {
    const { mode } = await Deno.lstat(path10);
    return {
      owner: {
        //          rwxrwxrwx
        canRead: !!(256 & mode),
        canWrite: !!(128 & mode),
        canExecute: !!(64 & mode)
      },
      group: {
        canRead: !!(32 & mode),
        canWrite: !!(16 & mode),
        canExecute: !!(8 & mode)
      },
      others: {
        canRead: !!(4 & mode),
        canWrite: !!(2 & mode),
        canExecute: !!(1 & mode)
      }
    };
  },
  /**
  * Add/set file permissions
  *
  * @param {String} args.path - 
  * @param {Object|Boolean} args.recursively - 
  * @param {Object} args.permissions - 
  * @param {Object} args.permissions.owner - 
  * @param {Boolean} args.permissions.owner.canRead - 
  * @param {Boolean} args.permissions.owner.canWrite - 
  * @param {Boolean} args.permissions.owner.canExecute - 
  * @param {Object} args.permissions.group - 
  * @param {Boolean} args.permissions.group.canRead - 
  * @param {Boolean} args.permissions.group.canWrite - 
  * @param {Boolean} args.permissions.group.canExecute - 
  * @param {Object} args.permissions.others - 
  * @param {Boolean} args.permissions.others.canRead - 
  * @param {Boolean} args.permissions.others.canWrite - 
  * @param {Boolean} args.permissions.others.canExecute - 
  * @return {null} 
  *
  * @example
  * ```js
  *  await FileSystem.addPermissions({
  *      path: fileOrFolderPath,
  *      permissions: {
  *          owner: {
  *              canExecute: true,
  *          },
  *      }
  *  })
  * ```
  */
  async addPermissions({ path: path10, permissions = { owner: {}, group: {}, others: {} }, recursively = false }) {
    permissions = { owner: {}, group: {}, others: {}, ...permissions };
    let permissionNumber = 0;
    let fileInfo;
    if (!(Object.keys(permissions.owner).length === Object.keys(permissions.group).length === Object.keys(permissions.others).length === 3)) {
      fileInfo = await FileSystem2.info(path10);
      permissionNumber = fileInfo.lstat.mode & 511;
    }
    if (permissions.owner.canRead != null) {
      if (permissions.owner.canRead) {
        permissionNumber |= 256;
      } else {
        permissionNumber &= 767;
      }
    }
    if (permissions.owner.canWrite != null) {
      if (permissions.owner.canWrite) {
        permissionNumber |= 128;
      } else {
        permissionNumber &= 895;
      }
    }
    if (permissions.owner.canExecute != null) {
      if (permissions.owner.canExecute) {
        permissionNumber |= 64;
      } else {
        permissionNumber &= 959;
      }
    }
    if (permissions.group.canRead != null) {
      if (permissions.group.canRead) {
        permissionNumber |= 32;
      } else {
        permissionNumber &= 991;
      }
    }
    if (permissions.group.canWrite != null) {
      if (permissions.group.canWrite) {
        permissionNumber |= 16;
      } else {
        permissionNumber &= 1007;
      }
    }
    if (permissions.group.canExecute != null) {
      if (permissions.group.canExecute) {
        permissionNumber |= 8;
      } else {
        permissionNumber &= 1015;
      }
    }
    if (permissions.others.canRead != null) {
      if (permissions.others.canRead) {
        permissionNumber |= 4;
      } else {
        permissionNumber &= 1019;
      }
    }
    if (permissions.others.canWrite != null) {
      if (permissions.others.canWrite) {
        permissionNumber |= 2;
      } else {
        permissionNumber &= 1021;
      }
    }
    if (permissions.others.canExecute != null) {
      if (permissions.others.canExecute) {
        permissionNumber |= 1;
      } else {
        permissionNumber &= 1022;
      }
    }
    if (recursively == false || fileInfo instanceof Object && fileInfo.isFile || !(fileInfo instanceof Object) && (await FileSystem2.info(path10)).isFile) {
      return Deno.chmod(path10.path || path10, permissionNumber);
    } else {
      const promises = [];
      const paths = await FileSystem2.recursivelyListPathsIn(path10, { onlyHardlinks: false, dontFollowSymlinks: false, ...recursively });
      for (const eachPath2 of paths) {
        promises.push(
          Deno.chmod(eachPath2, permissionNumber).catch(console.error)
        );
      }
      return new Promise(async (resolve15, reject) => {
        for (const each2 of promises) {
          await each2;
        }
        resolve15();
      });
    }
  },
  // alias
  setPermissions(...args) {
    return FileSystem2.addPermissions(...args);
  },
  async write({ path: path10, data, force = true, overwrite = false, renameExtension = null }) {
    path10 = pathStandardize2(path10);
    await grabPathLock2(path10);
    if (force) {
      FileSystem2.sync.ensureIsFolder(FileSystem2.parentPath(path10), { overwrite, renameExtension });
      const info = FileSystem2.sync.info(path10);
      if (info.isDirectory) {
        FileSystem2.sync.remove(path10);
      }
    }
    let output2;
    if (typeof data == "string") {
      output2 = await Deno.writeTextFile(path10, data);
    } else if (typedArrayClasses4.some((dataClass) => data instanceof dataClass)) {
      output2 = await Deno.writeFile(path10, data);
    } else if (isGeneratorType3(data) || data[Symbol.iterator] || data[Symbol.asyncIterator]) {
      const file = await Deno.open(path10, { read: true, write: true, create: true, truncate: true });
      const encoder3 = new TextEncoder();
      const encode2 = encoder3.encode.bind(encoder3);
      try {
        let index = 0;
        for await (let packet of data) {
          if (typeof packet == "string") {
            packet = encode2(packet);
          }
          await Deno.write(file.rid, packet);
        }
      } finally {
        Deno.close(file.rid);
      }
    }
    delete locker2[path10];
    return output2;
  },
  async append({ path: path10, data, force = true, overwrite = false, renameExtension = null }) {
    path10 = pathStandardize2(path10);
    await grabPathLock2(path10);
    if (force) {
      FileSystem2.sync.ensureIsFolder(FileSystem2.parentPath(path10), { overwrite, renameExtension });
      const info = FileSystem2.sync.info(path10);
      if (info.isDirectory) {
        FileSystem2.sync.remove(path10);
      }
    }
    const file = await Deno.open(path10, { read: true, write: true, create: true });
    await file.seek(0, Deno.SeekMode.End);
    if (typeof data == "string") {
      await file.write(new TextEncoder().encode(data));
    } else {
      await file.write(data);
    }
    await file.close();
    delete locker2[path10];
  },
  async makeHardPathTo(path10, options = {}) {
    var { cache: cache6 } = { cache: {}, ...options };
    if (cache6[path10]) {
      return cache6[path10];
    }
    const [folders, name, extension] = FileSystem2.pathPieces(FileSystem2.makeAbsolutePath(path10));
    let topDownPath = ``;
    for (const eachFolderName of folders) {
      topDownPath += `/${eachFolderName}`;
      if (cache6[topDownPath]) {
        topDownPath = cache6[topDownPath];
        continue;
      }
      const unchangedPath = topDownPath;
      const info = await FileSystem2.info(topDownPath);
      if (info.isSymlink) {
        const absolutePathToIntermediate = await FileSystem2.finalTargetOf(info.path, { _parentsHaveBeenChecked: true, cache: cache6 });
        if (absolutePathToIntermediate == null) {
          return null;
        }
        topDownPath = topDownPath.slice(0, -(eachFolderName.length + 1));
        const relativePath = FileSystem2.makeRelativePath({
          from: topDownPath,
          to: absolutePathToIntermediate
        });
        topDownPath += `/${relativePath}`;
        topDownPath = normalize4(topDownPath);
      }
      cache6[unchangedPath] = topDownPath;
    }
    const hardPath = normalize4(`${topDownPath}/${name}${extension}`);
    cache6[path10] = hardPath;
    return hardPath;
  },
  async walkUpImport(path10, start) {
    const startPath = start || FileSystem2.pathOfCaller(1);
    const nearestPath = await FileSystem2.walkUpUntil(path10, startPath);
    if (nearestPath) {
      const absolutePath = FileSystem2.makeAbsolutePath(`${nearestPath}/${path10}`);
      return import(toFileUrl3(absolutePath).href);
    } else {
      throw Error(`Tried to walkUpImport ${path10}, starting at ${startPath}, but was unable to find any files`);
    }
  },
  sync: {
    // things that are already sync
    get parentPath() {
      return FileSystem2.parentPath;
    },
    get dirname() {
      return FileSystem2.dirname;
    },
    get basename() {
      return FileSystem2.basename;
    },
    get extname() {
      return FileSystem2.extname;
    },
    get join() {
      return FileSystem2.join;
    },
    get thisFile() {
      return FileSystem2.thisFile;
    },
    get thisFolder() {
      return FileSystem2.thisFolder;
    },
    get normalize() {
      return FileSystem2.normalize;
    },
    get isAbsolutePath() {
      return FileSystem2.isAbsolutePath;
    },
    get isRelativePath() {
      return FileSystem2.isRelativePath;
    },
    get makeRelativePath() {
      return FileSystem2.makeRelativePath;
    },
    get makeAbsolutePath() {
      return FileSystem2.makeAbsolutePath;
    },
    get pathDepth() {
      return FileSystem2.pathDepth;
    },
    get pathPieces() {
      return FileSystem2.pathPieces;
    },
    get extendName() {
      return FileSystem2.extendName;
    },
    get allParentPaths() {
      return FileSystem2.allParentPaths;
    },
    get pathOfCaller() {
      return FileSystem2.pathOfCaller;
    },
    get home() {
      return FileSystem2.home;
    },
    get workingDirectory() {
      return FileSystem2.workingDirectory;
    },
    get cwd() {
      return FileSystem2.cwd;
    },
    get pwd() {
      return FileSystem2.pwd;
    },
    get cd() {
      return FileSystem2.cd;
    },
    get changeDirectory() {
      return FileSystem2.changeDirectory;
    },
    set workingDirectory(value) {
      return FileSystem2.workingDirectory = value;
    },
    set cwd(value) {
      return FileSystem2.workingDirectory = value;
    },
    set pwd(value) {
      return FileSystem2.workingDirectory = value;
    },
    info(fileOrFolderPath, _cachedLstat = null) {
      let lstat = _cachedLstat;
      try {
        lstat = Deno.lstatSync(fileOrFolderPath);
      } catch (error) {
        lstat = { doesntExist: true };
      }
      let stat = {};
      if (!lstat.isSymlink) {
        stat = {
          isBrokenLink: false,
          isLoopOfLinks: false
        };
      } else {
        try {
          stat = Deno.statSync(fileOrFolderPath);
        } catch (error) {
          if (error.message.match(/^Too many levels of symbolic links/)) {
            stat.isBrokenLink = true;
            stat.isLoopOfLinks = true;
          } else if (error.message.match(/^No such file or directory/)) {
            stat.isBrokenLink = true;
          } else {
            throw error;
          }
        }
      }
      return new PathInfo2({ path: fileOrFolderPath, _lstatData: lstat, _statData: stat });
    },
    read(path10) {
      path10 = pathStandardize2(path10);
      let output2;
      try {
        output2 = Deno.readTextFileSync(path10);
      } catch (error) {
      }
      return output2;
    },
    readBytes(path10) {
      path10 = pathStandardize2(path10);
      let output2;
      try {
        output2 = Deno.readFileSync(path10);
      } catch (error) {
      }
      return output2;
    },
    *readLinesIteratively(path10) {
      path10 = pathStandardize2(path10);
      const file = Deno.openSync(path10);
      try {
        yield* readLines(file);
      } finally {
        Deno.close(file.rid);
      }
    },
    /**
     * find a root folder based on a child path
     *
     * @example
     * ```js
     *     import { FileSystem } from "https://deno.land/x/quickr/main/file_system.js"
     * 
     *     var gitParentFolderOrNull = FileSystem.sync.walkUpUntil(".git")
     *     var gitParentFolderOrNull = FileSystem.sync.walkUpUntil({
     *         subPath:".git",
     *         startPath: FileSystem.pwd,
     *     })
     *
     *     // below will result in that^ same folder (assuming all your .git folders have config files)
     *     var gitParentFolderOrNull = FileSystem.sync.walkUpUntil(".git/config")
     * 
     *     // below will result in the same folder, but only if theres a local master branch
     *     var gitParentFolderOrNull = FileSystem.sync.walkUpUntil(".git/refs/heads/master")
     *```
     */
    walkUpUntil(subPath, startPath = null) {
      subPath = subPath instanceof PathInfo2 ? subPath.path : subPath;
      if (subPath instanceof Object) {
        var { subPath, startPath } = subPath;
      }
      let here;
      if (!startPath) {
        here = Deno.cwd();
      } else if (isAbsolute3(startPath)) {
        here = startPath;
      } else {
        here = join4(here, startPath);
      }
      while (1) {
        let checkPath = join4(here, subPath);
        const pathInfo = Deno.lstatSync(checkPath).catch(() => ({ doesntExist: true }));
        if (!pathInfo.doesntExist) {
          return here;
        }
        if (here == dirname3(here)) {
          return null;
        } else {
          here = dirname3(here);
        }
      }
    },
    nextTargetOf(path10, options = {}) {
      const originalWasItem = path10 instanceof PathInfo2;
      const item = originalWasItem ? path10 : new PathInfo2({ path: path10 });
      const lstat = item.lstat;
      if (lstat.isSymlink) {
        const relativeOrAbsolutePath = Deno.readLinkSync(item.path);
        if (isAbsolute3(relativeOrAbsolutePath)) {
          if (originalWasItem) {
            return new PathInfo2({ path: relativeOrAbsolutePath });
          } else {
            return relativeOrAbsolutePath;
          }
        } else {
          const path11 = `${FileSystem2.sync.makeHardPathTo(dirname3(item.path))}/${relativeOrAbsolutePath}`;
          if (originalWasItem) {
            return new PathInfo2({ path: path11 });
          } else {
            return path11;
          }
        }
      } else {
        if (originalWasItem) {
          return item;
        } else {
          return item.path;
        }
      }
    },
    finalTargetOf(path10, options = {}) {
      const { _parentsHaveBeenChecked, cache: cache6 } = { _parentsHaveBeenChecked: false, cache: {}, ...options };
      const originalWasItem = path10 instanceof PathInfo2;
      path10 = path10.path || path10;
      let result2 = Deno.lstatSync(path10).catch(() => ({ doesntExist: true }));
      if (result2.doesntExist) {
        return null;
      }
      path10 = FileSystem2.sync.makeHardPathTo(path10, { cache: cache6 });
      const pathChain = [];
      while (result2.isSymlink) {
        const relativeOrAbsolutePath = Deno.readLinkSync(path10);
        if (isAbsolute3(relativeOrAbsolutePath)) {
          path10 = relativeOrAbsolutePath;
        } else {
          path10 = `${FileSystem2.parentPath(path10)}/${relativeOrAbsolutePath}`;
        }
        result2 = Deno.lstatSync(path10).catch(() => ({ doesntExist: true }));
        if (result2.doesntExist) {
          return null;
        }
        path10 = FileSystem2.sync.makeHardPathTo(path10, { cache: cache6 });
        if (pathChain.includes(path10)) {
          return null;
        }
        pathChain.push(path10);
      }
      path10 = FileSystem2.normalize(path10);
      if (originalWasItem) {
        return new PathInfo2({ path: path10 });
      } else {
        return path10;
      }
    },
    makeHardPathTo(path10, options = {}) {
      var { cache: cache6 } = { cache: {}, ...options };
      if (cache6[path10]) {
        return cache6[path10];
      }
      const [folders, name, extension] = FileSystem2.pathPieces(FileSystem2.makeAbsolutePath(path10));
      let topDownPath = ``;
      for (const eachFolderName of folders) {
        topDownPath += `/${eachFolderName}`;
        if (cache6[topDownPath]) {
          topDownPath = cache6[topDownPath];
          continue;
        }
        const unchangedPath = topDownPath;
        const info = FileSystem2.sync.info(topDownPath);
        if (info.isSymlink) {
          const absolutePathToIntermediate = FileSystem2.sync.finalTargetOf(info.path, { _parentsHaveBeenChecked: true, cache: cache6 });
          if (absolutePathToIntermediate == null) {
            return null;
          }
          topDownPath = topDownPath.slice(0, -(eachFolderName.length + 1));
          const relativePath = FileSystem2.makeRelativePath({
            from: topDownPath,
            to: absolutePathToIntermediate
          });
          topDownPath += `/${relativePath}`;
          topDownPath = normalize4(topDownPath);
        }
        cache6[unchangedPath] = topDownPath;
      }
      const hardPath = normalize4(`${topDownPath}/${name}${extension}`);
      cache6[path10] = hardPath;
      return hardPath;
    },
    remove(fileOrFolder) {
      if (fileOrFolder instanceof Array) {
        return fileOrFolder.map(FileSystem2.sync.remove);
      }
      fileOrFolder = fileOrFolder.path || fileOrFolder;
      let exists2 = false;
      let item;
      try {
        item = Deno.lstatSync(fileOrFolder);
        exists2 = true;
      } catch (error) {
      }
      if (exists2) {
        if (item.isFile || item.isSymlink) {
          return Deno.removeSync(fileOrFolder.replace(/\/+$/, ""));
        } else {
          return Deno.removeSync(fileOrFolder.replace(/\/+$/, ""), { recursive: true });
        }
      }
    },
    moveOutOfTheWay(path10, options = { extension: null }) {
      path10 = pathStandardize2(path10);
      const extension = options?.extension || FileSystem2.defaultRenameExtension;
      const info = FileSystem2.sync.info(path10);
      if (info.exists) {
        const newPath = path10 + extension;
        FileSystem2.sync.moveOutOfTheWay(newPath, { extension });
        moveSync(path10, newPath);
      }
    },
    ensureIsFolder(path10, options = { overwrite: false, renameExtension: null }) {
      path10 = pathStandardize2(path10);
      const { overwrite, renameExtension } = defaultOptionsHelper2(options);
      path10 = path10.path || path10;
      path10 = FileSystem2.makeAbsolutePath(path10);
      const parentPath = dirname3(path10);
      if (parentPath == path10) {
        return;
      }
      const parent = FileSystem2.sync.info(parentPath);
      if (!parent.isDirectory) {
        FileSystem2.sync.ensureIsFolder(parentPath, { overwrite, renameExtension });
      }
      let pathInfo = FileSystem2.sync.info(path10);
      if (pathInfo.exists && !pathInfo.isDirectory) {
        if (overwrite) {
          FileSystem2.sync.remove(path10);
        } else {
          FileSystem2.sync.moveOutOfTheWay(path10, { extension: renameExtension });
        }
      }
      Deno.mkdirSync(path10, { recursive: true });
      return path10;
    },
    /**
     * Move/Remove everything and Ensure parent folders
     *
     * @param path
     * @param options.overwrite - if false, then things in the way will be moved instead of deleted
     * @param options.extension - the string to append when renaming files to get them out of the way
     * 
     * @example
     * ```js
     *     FileSystem.sync.clearAPathFor("./something")
     * ```
     */
    clearAPathFor(path10, options = { overwrite: false, renameExtension: null }) {
      const { overwrite, renameExtension } = defaultOptionsHelper2(options);
      const originalPath = path10;
      const paths = [];
      while (dirname3(path10) !== path10) {
        paths.push(path10);
        path10 = dirname3(path10);
      }
      for (const eachPath2 of paths.reverse()) {
        const info = FileSystem2.sync.info(eachPath2);
        if (!info.exists) {
          break;
        } else if (info.isFile) {
          if (overwrite) {
            FileSystem2.sync.remove(eachPath2);
          } else {
            FileSystem2.sync.moveOutOfTheWay(eachPath2, { extension: renameExtension });
          }
        }
      }
      Deno.mkdirSync(dirname3(originalPath), { recursive: true });
      return originalPath;
    },
    append({ path: path10, data, force = true, overwrite = false, renameExtension = null }) {
      path10 = pathStandardize2(path10);
      if (force) {
        FileSystem2.sync.ensureIsFolder(FileSystem2.parentPath(path10), { overwrite, renameExtension });
        const info = FileSystem2.sync.info(path10);
        if (info.isDirectory) {
          FileSystem2.sync.remove(path10);
        }
      }
      const file = Deno.openSync(path10, { read: true, write: true, create: true });
      file.seekSync(0, Deno.SeekMode.End);
      if (typeof data == "string") {
        file.writeSync(new TextEncoder().encode(data));
      } else {
        file.writeSync(data);
      }
      file.close();
    },
    write({ path: path10, data, force = true, overwrite = false, renameExtension = null }) {
      path10 = pathStandardize2(path10);
      if (force) {
        FileSystem2.sync.ensureIsFolder(FileSystem2.parentPath(path10), { overwrite, renameExtension });
        const info = FileSystem2.sync.info(path10);
        if (info.isDirectory) {
          FileSystem2.sync.remove(path10);
        }
      }
      let output2;
      if (typeof data == "string") {
        output2 = Deno.writeTextFileSync(path10, data);
      } else if (typedArrayClasses4.some((dataClass) => data instanceof dataClass)) {
        output2 = Deno.writeFileSync(path10, data);
      } else if (isGeneratorType3(data) || data[Symbol.iterator] || data[Symbol.asyncIterator]) {
        const file = Deno.openSync(path10, { read: true, write: true, create: true, truncate: true });
        const encoder3 = new TextEncoder();
        const encode2 = encoder3.encode.bind(encoder3);
        try {
          let index = 0;
          for (let packet of data) {
            if (typeof packet == "string") {
              packet = encode2(packet);
            }
            Deno.writeSync(file.rid, packet);
          }
        } finally {
          Deno.close(file.rid);
        }
      }
      return output2;
    }
    // TODO:
    // move
    // ensureIsFile
    // copy
    // relativeLink
    // absoluteLink
    // iterateBasenamesIn
    // iteratePathsIn
    // iterateItemsIn
    // listItemsIn
    // listFileItemsIn
    // listFilePathsIn
    // listFileBasenamesIn
    // listFolderItemsIn
    // listFolderPathsIn
    // listFolderBasenamesIn
    // globIterator
    // getPermissions
    // addPermissions
    // Note:
    // cannot be sync:
    // walkUpImport 
  }
};
var glob2 = FileSystem2.glob;

// https://deno.land/x/quickr@0.6.54/main/operating_system.js
var cache5 = {};
var stdoutRun2 = async (args) => {
  const process = Deno.run({ cmd: args, stdout: "piped", stderr: "piped" });
  const output2 = await process.output();
  return new TextDecoder().decode(output2).replace(/\n$/, "");
};
var OperatingSystem2 = {
  commonChecks: {
    isMac: Deno.build.os == "darwin",
    isWindows: Deno.build.os == "windows",
    isLinux: Deno.build.os == "linux",
    get isWsl() {
      if (cache5.isWsl != null) {
        return cache5.isWsl;
      }
      if (!(OperatingSystem2.commonChecks.isMac || OperatingSystem2.commonChecks.isWindows)) {
        if (Deno.env.get("WSLENV")) {
          return cache5.isWsl = true;
        }
        try {
          const { isFile } = Deno.lstatSync("/mnt/c");
          return cache5.isWsl = true;
        } catch (error) {
        }
      }
      return cache5.isWsl = false;
    }
  },
  commonName: {
    "darwin": "MacOS",
    "windows": "Windows",
    "linux": "Linux"
  }[Deno.build.os],
  kernel: {
    commonName: Deno.build.os
  },
  architecture: Deno.build.architecture,
  get versionArray() {
    return new Promise(async (resolve15, reject) => {
      let versionArray = [];
      if (OperatingSystem2.commonChecks.isWindows) {
        try {
          const windowsVersionString = await stdoutRun2(["pwsh", "-Command", `[System.Environment]::OSVersion.Version`]);
          versionArray = windowsVersionString.replace(/^[\w\W]*?(\d+\.\d+\.\d+)[\w\W]*/, "$1").split(".").map((each2) => each2 - 0);
        } catch (error) {
          console.warn(`unable to get version string for Windows: ${error.message}`);
        }
      } else if (OperatingSystem2.commonChecks.isMac) {
        try {
          const macVersionString = await stdoutRun2(["/usr/bin/sw_vers", "-productVersion"]);
          versionArray = macVersionString.replace(/^[\w\W]*?(\d+\.\d+(\.\d+)?)[\w\W]*/, "$1").split(".").map((each2) => each2 - 0);
        } catch (error) {
          console.warn(`unable to get version string for MacOS: ${error.message}`);
        }
      } else {
        try {
          const outputString = await stdoutRun2(["uname", "-r"]);
          versionArray = outputString.replace(/^[\w\W]*?((\d+\.)+\d+)[\w\W]*/, "$1").split(".").map((each2) => each2 - 0);
        } catch (error) {
          console.warn(`unable to get version string for Linux: ${error.message}`);
        }
      }
    });
  },
  get username() {
    if (!cache5.username) {
      if (Deno.build.os != "windows") {
        cache5.username = Deno.env.get("USER");
      } else {
        cache5.username = Deno.env.get("USERNAME");
      }
    }
    return cache5.username;
  },
  get home() {
    if (!cache5.home) {
      if (Deno.build.os != "windows") {
        cache5.home = Deno.env.get("HOME");
      } else {
        cache5.home = Deno.env.get("HOMEPATH");
      }
    }
    return cache5.home;
  },
  async idForUsername(username) {
    if (OperatingSystem2.commonChecks.isMac) {
      if (!cache5.macOsUserToUid) {
        const userListString = await stdoutRun2(["dscl", ".", "-list", "/Users", "UniqueID"]);
        const userList = userListString.split(/\n/);
        const userNamesAndIds = userList.map((each2) => {
          const match = each2.match(/(.+?)(-?\d+)$/, "$1");
          if (match) {
            const username2 = match[1].trim();
            const uid = match[2];
            return [username2, uid];
          }
        }).filter((each2) => each2);
        const idsAndUsernames = userNamesAndIds.map(([username2, id]) => [id, username2]);
        cache5.macOsUserToUid = Object.fromEntries(userNamesAndIds);
        cache5.macOsUidToUser = Object.fromEntries(idsAndUsernames);
      }
      return cache5.macOsUserToUid[username];
    } else if (OperatingSystem2.commonChecks.isWindows) {
      return await stdoutRun2(["pwsh", "-Command", `Get-ADUser -Identity '${username.replace(/'/, "''")}' | select SID`]);
    } else if (OperatingSystem2.commonChecks.isLinux) {
      return await stdoutRun2(["id", "-u", OperatingSystem2.username]);
    }
  }
};

// https://deno.land/x/quickr@0.6.54/main/console.js
var realConsole2 = globalThis.console;
var isBrowserContext2 = typeof document != "undefined" && typeof window != "undefined";
var env2 = null;
var originalThing2 = realConsole2;
var symbolForConsoleLog2 = Symbol.for("console.log");
var proxySymbol2 = Symbol.for("Proxy");
var thisProxySymbol2 = Symbol("thisProxy");
globalThis.console = new Proxy(originalThing2, {
  defineProperty: Reflect.defineProperty,
  getPrototypeOf: Reflect.getPrototypeOf,
  // Object.keys
  ownKeys(...args) {
    return Reflect.ownKeys(...args);
  },
  // function call (original value needs to be a function)
  apply(original, context, ...args) {
    console.log(args);
  },
  // new operator (original value needs to be a class)
  construct(...args) {
  },
  get(original, key, ...args) {
    if (key == proxySymbol2 || key == thisProxySymbol2) {
      return true;
    }
    if (key == "log") {
      return (...args2) => {
        realConsole2.log(
          ...args2.map((each2) => {
            if (each2 instanceof Object && each2[symbolForConsoleLog2] instanceof Function) {
              return each2[symbolForConsoleLog2]();
            }
            return each2;
          })
        );
      };
    }
    return Reflect.get(original, key, ...args);
  },
  set(original, key, ...args) {
    if (key == proxySymbol2 || key == thisProxySymbol2) {
      return;
    }
    return Reflect.set(original, key, ...args);
  }
});
var codeToEscapeString2 = (code2) => `\x1B[${code2}m`;
var ansiRegexPattern2 = /[\u001B\u009B][[\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\d\/#&.:=?%@~_]+)*|[a-zA-Z\d]+(?:;[-a-zA-Z\d\/#&.:=?%@~_]*)*)?\u0007)|(?:(?:\d{1,4}(?:;\d{0,4})*)?[\dA-PR-TZcf-nq-uy=><~]))/g;
function clearAnsiStylesFrom2(string2) {
  return `${string2}`.replace(ansiRegexPattern2, "");
}
var styleStrings2 = {
  reset: codeToEscapeString2(0),
  bold: codeToEscapeString2(1),
  dim: codeToEscapeString2(2),
  italic: codeToEscapeString2(3),
  underline: codeToEscapeString2(4),
  slowBlink: codeToEscapeString2(5),
  // not widely supported
  fastBlink: codeToEscapeString2(6),
  // not widely supported
  inverse: codeToEscapeString2(7),
  strikethrough: codeToEscapeString2(9),
  primary: codeToEscapeString2(11),
  // forground colors
  black: codeToEscapeString2(30),
  red: codeToEscapeString2(31),
  green: codeToEscapeString2(32),
  yellow: codeToEscapeString2(33),
  blue: codeToEscapeString2(34),
  magenta: codeToEscapeString2(35),
  cyan: codeToEscapeString2(36),
  white: codeToEscapeString2(37),
  lightBlack: codeToEscapeString2(90),
  lightRed: codeToEscapeString2(91),
  lightGreen: codeToEscapeString2(92),
  lightYellow: codeToEscapeString2(93),
  lightBlue: codeToEscapeString2(94),
  lightMagenta: codeToEscapeString2(95),
  lightCyan: codeToEscapeString2(96),
  lightWhite: codeToEscapeString2(97),
  // background
  blackBackground: codeToEscapeString2(40),
  redBackground: codeToEscapeString2(41),
  greenBackground: codeToEscapeString2(42),
  yellowBackground: codeToEscapeString2(43),
  blueBackground: codeToEscapeString2(44),
  magentaBackground: codeToEscapeString2(45),
  cyanBackground: codeToEscapeString2(46),
  whiteBackground: codeToEscapeString2(47),
  lightBlackBackground: codeToEscapeString2(100),
  lightRedBackground: codeToEscapeString2(101),
  lightGreenBackground: codeToEscapeString2(102),
  lightYellowBackground: codeToEscapeString2(103),
  lightBlueBackground: codeToEscapeString2(104),
  lightMagentaBackground: codeToEscapeString2(105),
  lightCyanBackground: codeToEscapeString2(106),
  lightWhiteBackground: codeToEscapeString2(107)
};
Object.assign(styleStrings2, {
  gray: styleStrings2.lightBlack,
  grey: styleStrings2.lightBlack,
  lightGray: styleStrings2.white,
  // lightWhite is "true" white
  lightGrey: styleStrings2.white,
  // lightWhite is "true" white
  grayBackground: styleStrings2.lightBlackBackground,
  greyBackground: styleStrings2.lightBlackBackground,
  lightGrayBackground: styleStrings2.whiteBackground,
  lightGreyBackground: styleStrings2.whiteBackground
});
var styleObjectSymbol2 = Symbol("consoleStyle");
var styleObject2 = (rootStyleString) => {
  const createStyleAccumulator = (styleString) => {
    const styleAccumulator = (strings, ...values) => {
      const objectToStyledString = (interpolatedValue, styles) => {
        let singleCombinedString2 = "";
        if (interpolatedValue instanceof Object && interpolatedValue[styleObjectSymbol2] instanceof Function) {
          singleCombinedString2 += interpolatedValue[styleObjectSymbol2]();
        } else {
          singleCombinedString2 += toString(interpolatedValue);
        }
        singleCombinedString2 += styleStrings2.reset + styleAccumulator.styles.join("");
        return singleCombinedString2;
      };
      let singleCombinedString = "";
      if (!(strings instanceof Array) || strings.length < 1 || !strings.every((each2) => typeof each2 == "string")) {
        for (const each2 of [strings, ...values]) {
          singleCombinedString += objectToStyledString(each2);
        }
      } else {
        for (const index in values) {
          singleCombinedString += strings[index];
          singleCombinedString += objectToStyledString(values[index]);
        }
        const lastString = strings.slice(-1)[0];
        singleCombinedString += lastString;
      }
      styleAccumulator.sequence.push(singleCombinedString);
      return styleAccumulator;
    };
    styleAccumulator[styleObjectSymbol2] = true;
    styleAccumulator.styles = [styleString];
    styleAccumulator.sequence = [styleString];
    styleAccumulator.toString = () => styleAccumulator.sequence.join("") + styleStrings2.reset;
    styleAccumulator[Deno.customInspect] = () => styleAccumulator.sequence.join("") + styleStrings2.reset;
    styleAccumulator[symbolForConsoleLog2] = () => {
      const asString3 = styleAccumulator.toString();
      if (Console2.reliableColorSupport.includesAnsi) {
        return asString3;
      } else {
        return clearAnsiStylesFrom2(asString3);
      }
    };
    return Object.defineProperties(styleAccumulator, Object.fromEntries(Object.entries(styleStrings2).map(
      ([key, value]) => [
        key,
        {
          get() {
            styleAccumulator.styles.push(value);
            styleAccumulator.sequence.push(value);
            return styleAccumulator;
          }
        }
      ]
    )));
  };
  const topLevelStyleAccumulator = (strings, ...values) => createStyleAccumulator(rootStyleString)(strings, ...values);
  topLevelStyleAccumulator[styleObjectSymbol2] = true;
  topLevelStyleAccumulator.toString = () => rootStyleString;
  topLevelStyleAccumulator[symbolForConsoleLog2] = () => {
    const asString3 = topLevelStyleAccumulator.toString();
    if (Console2.reliableColorSupport.includesAnsi) {
      return asString3;
    } else {
      return clearAnsiStylesFrom2(asString3);
    }
  };
  return Object.defineProperties(topLevelStyleAccumulator, Object.fromEntries(Object.entries(styleStrings2).map(
    ([eachStyleName, eachStyleString]) => [
      eachStyleName,
      {
        get() {
          const styleAccumulator = createStyleAccumulator(rootStyleString);
          styleAccumulator.styles.push(eachStyleString);
          styleAccumulator.sequence.push(eachStyleString);
          return styleAccumulator;
        }
      }
    ]
  )));
};
var bold4 = styleObject2(styleStrings2.bold);
var reset3 = styleObject2(styleStrings2.reset);
var dim3 = styleObject2(styleStrings2.dim);
var italic3 = styleObject2(styleStrings2.italic);
var underline3 = styleObject2(styleStrings2.underline);
var inverse2 = styleObject2(styleStrings2.inverse);
var strikethrough2 = styleObject2(styleStrings2.strikethrough);
var black2 = styleObject2(styleStrings2.black);
var white3 = styleObject2(styleStrings2.white);
var red4 = styleObject2(styleStrings2.red);
var green4 = styleObject2(styleStrings2.green);
var blue2 = styleObject2(styleStrings2.blue);
var yellow3 = styleObject2(styleStrings2.yellow);
var cyan3 = styleObject2(styleStrings2.cyan);
var magenta2 = styleObject2(styleStrings2.magenta);
var lightBlack2 = styleObject2(styleStrings2.lightBlack);
var lightWhite2 = styleObject2(styleStrings2.lightWhite);
var lightRed2 = styleObject2(styleStrings2.lightRed);
var lightGreen2 = styleObject2(styleStrings2.lightGreen);
var lightBlue2 = styleObject2(styleStrings2.lightBlue);
var lightYellow2 = styleObject2(styleStrings2.lightYellow);
var lightMagenta2 = styleObject2(styleStrings2.lightMagenta);
var lightCyan2 = styleObject2(styleStrings2.lightCyan);
var blackBackground2 = styleObject2(styleStrings2.blackBackground);
var whiteBackground2 = styleObject2(styleStrings2.whiteBackground);
var redBackground2 = styleObject2(styleStrings2.redBackground);
var greenBackground2 = styleObject2(styleStrings2.greenBackground);
var blueBackground2 = styleObject2(styleStrings2.blueBackground);
var yellowBackground2 = styleObject2(styleStrings2.yellowBackground);
var magentaBackground2 = styleObject2(styleStrings2.magentaBackground);
var cyanBackground2 = styleObject2(styleStrings2.cyanBackground);
var lightBlackBackground2 = styleObject2(styleStrings2.lightBlackBackground);
var lightRedBackground2 = styleObject2(styleStrings2.lightRedBackground);
var lightGreenBackground2 = styleObject2(styleStrings2.lightGreenBackground);
var lightYellowBackground2 = styleObject2(styleStrings2.lightYellowBackground);
var lightBlueBackground2 = styleObject2(styleStrings2.lightBlueBackground);
var lightMagentaBackground2 = styleObject2(styleStrings2.lightMagentaBackground);
var lightCyanBackground2 = styleObject2(styleStrings2.lightCyanBackground);
var lightWhiteBackground2 = styleObject2(styleStrings2.lightWhiteBackground);
var gray3 = styleObject2(styleStrings2.gray);
var grey2 = styleObject2(styleStrings2.grey);
var lightGray2 = styleObject2(styleStrings2.lightGray);
var lightGrey2 = styleObject2(styleStrings2.lightGrey);
var grayBackground2 = styleObject2(styleStrings2.grayBackground);
var greyBackground2 = styleObject2(styleStrings2.greyBackground);
var lightGrayBackground2 = styleObject2(styleStrings2.lightGrayBackground);
var lightGreyBackground2 = styleObject2(styleStrings2.lightGreyBackground);
var colorSupportCache2 = {
  includesAnsi: null,
  includes256: null,
  includes16m: null
};
var Console2 = {
  // TODO: add signal handler
  // Deno.addSignalListener("SIGINT", (...args)=>{
  //     console.debug(`args is:`,args)
  // })
  log(...args) {
    if (args.length == 0) {
      console.log();
    }
    let [arg1, ...others] = args.map((each2) => {
      if (each2 instanceof Object && each2[symbolForConsoleLog2] instanceof Function) {
        return each2[symbolForConsoleLog2]();
      }
      return each2;
    });
    if (typeof arg1 == "string") {
      arg1 = arg1.replace("%", "%%");
    }
    if (!isBrowserContext2) {
      if (!Console2.reliableColorSupport.includesAnsi) {
        arg1 = clearAnsiStylesFrom2(arg1);
        others = others.map((each2) => {
          if (typeof each2 == "string") {
            return clearAnsiStylesFrom2(each2);
          } else {
            return each2;
          }
        });
      }
      realConsole2.log(arg1, ...others);
    } else {
      if (args[0][symbolForConsoleLog2] && typeof args[0].styleString == "string") {
        realConsole2.log(`%c${arg1}${others.map((each2) => `${each2}`).join("")}`, args[0].styleString);
      } else {
        realConsole2.log(arg1, ...others);
      }
    }
    return Console2;
  },
  get env() {
    return env2 = env2 || new Proxy(
      Deno.env.toObject(),
      {
        // Object.keys
        ownKeys(target) {
          return Object.keys(Deno.env.toObject());
        },
        has(original, key) {
          if (typeof key === "symbol") {
            return false;
          } else {
            return Deno.env.get(key) !== void 0;
          }
        },
        get(original, key) {
          if (typeof key === "symbol") {
            return original[key];
          } else {
            return Deno.env.get(key);
          }
        },
        set(original, key, value) {
          original[key] = value;
          if (typeof key !== "symbol") {
            Deno.env.set(key, value);
          }
          return true;
        },
        deleteProperty(original, key) {
          if (typeof key === "symbol") {
            return void 0;
          } else {
            return Deno.env.delete(key);
          }
        }
      }
    );
  },
  disableColorIfNonIteractive: true,
  askFor: {
    // in the future once Deno.setRaw is stable, add a askFor.password using: https://github.com/caspervonb/deno-prompts
    line(question) {
      return prompt(question);
    },
    confirmation(question) {
      console.log(question);
      prompt("[use CTRL+C to quit, or press enter to continue]");
    },
    positiveIntegerOrZero(question) {
      while (1) {
        console.log(question);
        const answer = prompt(question);
        const asNumber = answer - 0;
        const isRealNumber = asNumber !== asNumber && asNumber * 2 !== asNumber;
        const isInteger2 = Math.round(asNumber) === asNumber;
        const isNonNegative = asNumber >= 0;
        if (isRealNumber && isInteger2 && isNonNegative) {
          return asNumber;
        } else {
          if (!isRealNumber) {
            console.log(`I don't think ${answer} is a real number, please try again`);
          }
          if (!isInteger2) {
            console.log(`I don't think ${answer} is an integer, please try again`);
          }
          if (!isNonNegative) {
            console.log(`I don't think ${answer} is \u2265 0, please try again`);
          }
        }
      }
    },
    yesNo(question) {
      while (true) {
        let answer = prompt(question);
        const match = `${answer}`.match(/^ *(y|yes|n|no) *\n?$/i);
        if (match) {
          if (match[1][0] == "y" || match[1][0] == "Y") {
            return true;
          } else {
            return false;
          }
        } else {
          console.log("[ please respond with y/n, yes/no, or use CTRL+C to cancel ]");
        }
      }
    },
    oneOf(keyValues, question = "Please type one of the names from the list above") {
      if (keyValues instanceof Array) {
        keyValues = Object.fromEntries(keyValues.map((each2, index) => [index, each2]));
      }
      const keys = Object.keys(keyValues);
      if (keys.length == 0) {
        console.warn(`Tried to perform Console.askFor.oneOf(object) but the object was empty`);
        return void 0;
      }
      const longest2 = Math.max(keys.map((each2) => each2.length));
      while (true) {
        for (const [key, value] of Object.entries(keyValues)) {
          const valueAsString = indent2({ string: `${value}
`, by: " ".repeat(longest2 + 2), noLead: true });
          console.log(``, `${key}: ${valueAsString}`);
        }
        let answer = prompt(question);
        if (keys.includes(answer)) {
          return keyValues[answer];
        } else {
          console.log("\n\n[ please pick one of the listed names, or use CTRL+C to cancel ]");
        }
      }
    }
  },
  get paths() {
    const spliter = OperatingSystem2.commonChecks.isWindows ? ";" : ":";
    return Deno.env.get("PATH").split(spliter);
  },
  get reliableColorSupport() {
    if (colorSupportCache2.includesAnsi != null) {
      return colorSupportCache2;
    }
    let terminalSupport;
    if (!Deno.isatty(0)) {
      terminalSupport = {
        includesAnsi: false,
        includes256: false,
        includes16m: false
      };
    } else if ("NO_COLOR" in Console2.env) {
      terminalSupport = {
        includesAnsi: false,
        includes256: false,
        includes16m: false
      };
    } else {
      if (OperatingSystem2.commonChecks.isWindows || OperatingSystem2.commonChecks.isWsl) {
        if (Deno.env.get("WT_SESSION")) {
          terminalSupport = {
            includesAnsi: true,
            includes256: true,
            includes16m: true
          };
        } else {
          terminalSupport = {
            includesAnsi: false,
            includes256: false,
            includes16m: false
          };
        }
      } else {
        if ("TERM_PROGRAM" in Console2.env) {
          const version = Number.parseInt((Console2.env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          if (Console2.env.TERM_PROGRAM == "iTerm.app") {
            if (version >= 3) {
              terminalSupport = {
                includesAnsi: true,
                includes256: true,
                includes16m: true
              };
            } else {
              terminalSupport = {
                includesAnsi: true,
                includes256: true,
                includes16m: false
              };
            }
          } else if (Console2.env.TERM_PROGRAM == "Apple_Terminal") {
            terminalSupport = {
              includesAnsi: true,
              includes256: true,
              includes16m: false
            };
          }
        }
        if (Console2.env.TERM === "dumb") {
          terminalSupport = {
            includesAnsi: false,
            includes256: false,
            includes16m: false
          };
        } else if ("CI" in Console2.env) {
          terminalSupport = {
            includesAnsi: ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => sign in Console2.env) || Console2.env.CI_NAME === "codeship",
            includes256: false,
            includes16m: false
          };
        } else if (Console2.env.COLORTERM === "truecolor") {
          terminalSupport = {
            includesAnsi: true,
            includes256: true,
            includes16m: true
          };
        } else if (/-256(color)?$/i.test(Console2.env.TERM)) {
          terminalSupport = {
            includesAnsi: true,
            includes256: true,
            includes16m: false
          };
        } else if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(Console2.env.TERM)) {
          terminalSupport = {
            includesAnsi: true,
            includes256: false,
            includes16m: false
          };
        } else if ("COLORTERM" in Console2.env) {
          terminalSupport = {
            includesAnsi: true,
            includes256: false,
            includes16m: false
          };
        } else {
          terminalSupport = {
            includesAnsi: false,
            includes256: false,
            includes16m: false
          };
        }
      }
    }
    colorSupportCache2.includesAnsi = terminalSupport.includesAnsi;
    colorSupportCache2.includes256 = terminalSupport.includes256;
    colorSupportCache2.includes16m = terminalSupport.includes16m;
    return colorSupportCache2;
  }
};

// https://deno.land/x/quickr@0.6.54/main/run.js
var timeoutSymbol2 = Symbol("timeout");
var envSymbol2 = Symbol("env");
var cwdSymbol2 = Symbol("cwd");
var stdinSymbol2 = Symbol("stdin");
var stdoutSymbol2 = Symbol("stdout");
var stderrSymbol2 = Symbol("stderr");
var stdoutAndErrSymbol2 = Symbol("stdoutAndErr");
var overwriteSymbol2 = Symbol("overwrite");
var appendSymbol2 = Symbol("append");
var asString2 = Symbol("asString");
var throwIfFails2 = Symbol("throwIfFails");
var zipInto2 = Symbol("zipInto");
var mergeInto2 = Symbol("mergeInto");
var returnAsString2 = Symbol("returnAsString");
var Timeout2 = ({ gentlyBy, waitBeforeUsingForce }) => [timeoutSymbol2, { gentlyBy, waitBeforeUsingForce }];
var Env2 = (envVars) => [envSymbol2, envVars];
var Cwd2 = (newDirectory) => [cwdSymbol2, newDirectory];
var Stdin2 = (...streamsFilesOrStrings) => [stdinSymbol2, streamsFilesOrStrings];
var Stdout2 = (...pathsFilesStreamsOrSymbols) => [stdoutSymbol2, pathsFilesStreamsOrSymbols];
var Stderr2 = (...pathsFilesStreamsOrSymbols) => [stderrSymbol2, pathsFilesStreamsOrSymbols];
var Out2 = (...pathsFilesStreamsOrSymbols) => [stdoutAndErrSymbol2, pathsFilesStreamsOrSymbols];
var Overwrite2 = (fileOrFilePath) => [overwriteSymbol2, fileOrFilePath];
var AppendTo2 = (fileOrFilePath) => [appendSymbol2, fileOrFilePath];
var isReadable2 = (obj) => obj instanceof Object && obj.read instanceof Function;
var isWritable2 = (obj) => obj instanceof Object && obj.write instanceof Function;
var concatUint8Arrays2 = (arrays) => new Uint8Array(
  // simplified from: https://stackoverflow.com/questions/49129643/how-do-i-merge-an-array-of-uint8arrays
  arrays.reduce((acc, curr) => (acc.push(...curr), acc), [])
);
var { isWindows: isWindows7, isLinux: isLinux2, isMac: isMac2 } = OperatingSystem2.commonChecks;
var alreadyOpenFiles2 = {};
var ridToPath2 = {};
var realDenoOpen2 = Deno.open.bind(Deno);
Deno.open = function(...args) {
  const path10 = FileSystem2.makeAbsolutePath(args[0]);
  if (!alreadyOpenFiles2[path10]) {
    alreadyOpenFiles2[path10] = realDenoOpen2(...args).then((file) => {
      ridToPath2[file.rid] = path10;
      const realClose = file.close;
      file.close = function(...args2) {
        delete alreadyOpenFiles2[path10];
        realClose(...args2);
      }.bind(file);
      return file;
    });
  }
  return alreadyOpenFiles2[path10];
}.bind(Deno);
var realDenoOpenSync2 = Deno.openSync.bind(Deno);
Deno.openSync = function(...args) {
  const path10 = FileSystem2.makeAbsolutePath(args[0]);
  if (!alreadyOpenFiles2[path10]) {
    const file = realDenoOpenSync2(...args);
    ridToPath2[file.rid] = path10;
    const realClose = file.close;
    file.close = function(...args2) {
      delete alreadyOpenFiles2[path10];
      realClose(...args2);
    }.bind(file);
    alreadyOpenFiles2[path10] = file;
  }
  return alreadyOpenFiles2[path10];
}.bind(Deno);
var run3 = (maybeStrings, ...args) => {
  let newArgs = [];
  const argSplitter = /[ \t]+/;
  if (maybeStrings instanceof Array) {
    maybeStrings = [...maybeStrings];
    const lastString = maybeStrings.pop();
    for (const eachString of maybeStrings) {
      const innerArgs = eachString.split(argSplitter);
      for (const each2 of innerArgs) {
        if (each2.length > 0) {
          newArgs.push(each2);
        }
      }
      newArgs.push(args.shift());
    }
    const endingArgsString = lastString.trim();
    if (endingArgsString.length > 0) {
      const endingArgs = endingArgsString.split(argSplitter);
      for (const each2 of endingArgs) {
        newArgs.push(each2);
      }
    }
    args = newArgs;
  } else {
    args = [maybeStrings, ...args];
  }
  const commandMetaData = {
    timeout: { gentlyBy: void 0, waitBeforeUsingForce: void 0 },
    env: void 0,
    cwd: void 0,
    stdin: void 0,
    stdout: void 0,
    stderr: void 0,
    outAndError: []
  };
  for (const each2 of args) {
    if (typeof each2 == "symbol") {
      if (each2 == throwIfFails2) {
        commandMetaData.throwIfFails = true;
      }
    }
    if (each2 instanceof Array && typeof each2[0] == "symbol") {
      const [symbol, value] = each2;
      if (symbol === timeoutSymbol2) {
        Object.assign(commandMetaData.timeout, value);
      }
      if (symbol === envSymbol2) {
        commandMetaData.env = value;
      }
      if (symbol === cwdSymbol2) {
        commandMetaData.cwd = value;
      }
      if (symbol === stdinSymbol2) {
        commandMetaData.stdin = value;
      }
      if (symbol === stdoutSymbol2) {
        commandMetaData.stdout = value;
      }
      if (symbol === stderrSymbol2) {
        commandMetaData.stderr = value;
      }
      if (symbol === stdoutAndErrSymbol2) {
        commandMetaData.outAndError = value;
      }
    }
  }
  const runArg = {
    cmd: args.filter((each2) => typeof each2 == "string"),
    env: commandMetaData.env,
    cwd: commandMetaData.cwd,
    stdin: void 0,
    stdout: void 0,
    stderr: void 0
  };
  const syncStatus = { done: false, exitCode: void 0, success: void 0 };
  const asyncPart = async () => {
    if (
      // either both should be null or both should be set
      commandMetaData.timeout.gentlyBy == null !== (commandMetaData.timeout.waitBeforeUsingForce == null) || commandMetaData.timeout.gentlyBy != null && (!(commandMetaData.timeout.gentlyBy >= 0) || !(commandMetaData.timeout.waitBeforeUsingForce >= 0))
    ) {
      throw Error(`
When running command:
    ${JSON.stringify(runArg.cmd)}
it was given a:
    Timeout(${JSON.stringify(commandMetaData.timeout)})
however both "gentlyBy" and "waitBeforeUsingForce" are needed.
For example, if 
    gentlyBy: 1000
    waitBeforeUsingForce: 500
it would be force killed 1.5sec after the process started.
If you never want force to be used, do {waitBeforeUsingForce: Infinity}

`);
    }
    if (runArg.cwd !== void 0) {
      const folderExists = await Deno.stat(runArg.cwd).then(({ isDirectory: isDirectory2 }) => isDirectory2).catch(() => false);
      if (!folderExists) {
        throw Error(`
When running command:
    ${JSON.stringify(runArg.cmd)}
it was given a Cwd (cwd) of:
${JSON.stringify(runArg.cwd)}
but that doesn't seem to be a path to a folder, so the command would fail.

`);
      }
    }
    let stdinWriter = void 0;
    if (commandMetaData.stdin !== void 0) {
      let stdinArgs = commandMetaData.stdin;
      let index = 0;
      for (const each2 of stdinArgs) {
        if (each2 instanceof Promise) {
          stdinArgs[index] = await each2;
        }
        ++index;
      }
      if (stdinArgs.length == 0) {
        runArg.stdin = "piped";
      } else if (stdinArgs.length == 1 && stdinArgs[0] == null) {
        runArg.stdin = "null";
      } else {
        stdinArgs = stdinArgs.filter((each2) => each2 != null);
        if (stdinArgs.length == 0) {
          throw Error(`when calling run() with the command: 
    ${JSON.stringify(runArg.cmd)}
An Stdin() was given, but it wasn't given any arguments
if you want Stdin to be nothing (instead of the default Stdin(Deno.stdin)) put Stdin(null)

`);
        } else {
          runArg.stdin = "piped";
          if (stdinArgs.every((each2) => typeof each2 == "string" || each2 instanceof Uint8Array)) {
            const allUint8Arrays = stdinArgs.map((each2) => typeof each2 != "string" ? each2 : new TextEncoder().encode(each2));
            stdinWriter = concatUint8Arrays2(allUint8Arrays);
          } else {
            const first = stdinArgs[0];
            let prev;
            if (typeof first == "string") {
              stdinWriter = readableStreamFromReader(new StringReader(first));
              prev = "string";
            } else if (first instanceof Uint8Array) {
              stdinWriter = readableStreamFromReader(new Buffer(first));
              prev = "uint8array";
            } else if (first instanceof ReadableStream) {
              stdinWriter = first;
              prev = "readableStream";
            } else if (isReadable2(first)) {
              stdinWriter = readableStreamFromReader(first);
              prev = "readable";
            } else {
              throw Error(`when calling run() with the command: 
    ${JSON.stringify(runArg.cmd)}
An Stdin() was given, but there was a problem with one of the arguments.
The argument can be a string, a file (Deno.open("./path")), bytes (Uint8Array), or any readable object (like Deno.stdin or the .stdout of another run command)
but instead of any of those I received:
    ${first}

`);
            }
            for (const each2 of stdinArgs.slice(1)) {
              if (each2 === mergeInto2 || each2 === zipInto2) {
                prev = each2;
                continue;
              }
              let newStream;
              if (typeof each2 == "string") {
                newStream = readableStreamFromReader(new StringReader(each2));
                current = "string";
              } else if (each2 instanceof Uint8Array) {
                newStream = readableStreamFromReader(new Buffer(each2));
                current = "uint8";
              } else if (each2 instanceof ReadableStream) {
                newStream = each2;
                current = "readableStream";
              } else if (isReadable2(each2)) {
                newStream = readableStreamFromReader(each2);
                current = "readable";
              } else {
                throw Error(`when calling run() with the command: 
    ${JSON.stringify(runArg.cmd)}
An Stdin() was given, but there was a problem with one of the arguments.
The argument can be a string, a file (Deno.open("./path")), bytes (Uint8Array), or any readable object (like Deno.stdin or the .stdout of another run command)
but instead of any of those I received:
    ${each2}

`);
              }
              if (prev !== zipInto2 && (prev === mergeInto2 || prev == "string" || prev == "uint8array" || current == "string" || current == "uint8array")) {
                stdinWriter = stdinWriter.mergeReadableStreams(stdinWriter, newStream);
              } else {
                stdinWriter = stdinWriter.zipReadableStreams(stdinWriter, newStream);
              }
            }
          }
        }
      }
    }
    const outStreamNames = ["stdout", "stderr"];
    if (commandMetaData.outAndError.length > 0) {
      for (const each2 of outStreamNames) {
        if (!(commandMetaData[each2] instanceof Array)) {
          commandMetaData[each2] = [];
        }
        commandMetaData[each2] = commandMetaData[each2].concat(commandMetaData.outAndError);
      }
    }
    for (const each2 of outStreamNames) {
      if (commandMetaData[each2] !== void 0) {
        if (commandMetaData[each2].length == 0) {
          runArg[each2] = "piped";
        } else if (commandMetaData[each2].length == 1 && commandMetaData[each2][0] === null) {
          runArg[each2] = "null";
        } else {
          runArg[each2] = "piped";
          commandMetaData[each2] = [...new Set(commandMetaData[each2].filter((each3) => each3 != null))];
        }
      }
    }
    const openFiles = {};
    const convertReturnStreamArg = async (arg) => {
      if (arg === returnAsString2) {
        return arg;
      }
      if (arg instanceof Array) {
        if (typeof arg[0] == "symbol") {
          let [symbol, value] = arg;
          if (symbol === overwriteSymbol2) {
            if (typeof value == "string") {
              const path10 = FileSystem2.makeAbsolutePath(value);
              if (!openFiles[path10]) {
                await FileSystem2.clearAPathFor(value, { overwrite: true });
                openFiles[path10] = await Deno.open(value, { write: true, truncate: true, create: true });
              }
              value = openFiles[path10];
            }
            if (value instanceof Deno.File) {
              value.truncate();
            } else {
              throw Error(`
When running command:
    ${JSON.stringify(runArg.cmd)}
it was given one of:
    Stdout(Overwrite(arg))
    Stdin(Overwrite(arg))
    Out(Overwrite(arg))
However the given arg was not a string path or a file object.
Here's what I know about the argument:${debugValueAsString(value)}

`);
            }
          } else if (symbol === appendSymbol2) {
            if (typeof value == "string") {
              const path10 = FileSystem2.makeAbsolutePath(value);
              if (!openFiles[path10]) {
                await FileSystem2.ensureIsFolder(FileSystem2.parentPath(value));
                openFiles[path10] = await Deno.open(value, { write: true, create: true });
              }
              value = openFiles[path10];
            }
            if (value instanceof Deno.File) {
              await Deno.seek(value.rid, 0, Deno.SeekMode.End);
            } else {
              throw Error(`
When running command:
    ${JSON.stringify(runArg.cmd)}
it was given one of:
    Stdout(AppendTo(arg))
    Stdin(AppendTo(arg))
    Out(AppendTo(arg))
However the given arg was not a string path or a file object.
Here's what I know about the argument:${debugValueAsString(value)}

`);
            }
          }
          arg = value;
        }
      }
      if (arg instanceof WritableStream) {
        return arg;
      } else if (isWritable2(arg)) {
        return writableStreamFromWriter(arg);
      } else if (typeof arg == "string") {
        throw Error(`
When running command:
    ${JSON.stringify(runArg.cmd)}
it was given one of:
    Stdout(${JSON.stringify(arg)})
    Stdin(${JSON.stringify(arg)})
    Out(${JSON.stringify(arg)})
if you want to have them write to a file:
    dont:    Out(${JSON.stringify(arg)})
    instead: Out(Overwrite(${JSON.stringify(arg)}))
    or:      Out(AppendTo(${JSON.stringify(arg)}))

`);
      }
    };
    const alreadyComputed = /* @__PURE__ */ new Map();
    const convertArgsToWritables = (...args2) => args2.map((eachArg) => {
      let key;
      if (eachArg instanceof Array) {
        key = JSON.stringify(eachArg.map((each2) => {
          if (typeof each2 == "symbol") {
            return each2.toString();
          } else if (each2 instanceof Deno.File) {
            if (ridToPath2[each2.id]) {
              return FileSystem2.makeAbsolutePath(ridToPath2[each2.id]);
            }
            return `Deno.File(${each2.rid})`;
          } else if (typeof each2 == "string") {
            return FileSystem2.makeAbsolutePath(each2);
          } else {
            return JSON.stringify(each2);
          }
        }));
      } else {
        key = JSON.stringify(eachArg);
      }
      if (alreadyComputed.has(key)) {
        return alreadyComputed.get(key);
      } else {
        const output2 = convertReturnStreamArg(eachArg);
        alreadyComputed.set(key, output2);
        return output2;
      }
    });
    const stdoutWritables = await Promise.all(convertArgsToWritables(...commandMetaData.stdout || []));
    const stderrWritables = await Promise.all(convertArgsToWritables(...commandMetaData.stderr || []));
    let process = {};
    try {
      process = Deno.run(runArg);
    } catch (error) {
      const rejection = new Promise((resolve15, reject) => reject(`
${error}
This was from a run() call, which was converted to Deno.run(${JSON.stringify(runArg, 0, 4)})`));
      return [rejection, rejection, rejection];
    }
    if (commandMetaData.timeout.gentlyBy) {
      let outcome = false;
      process.status().then(() => outcome = true);
      setTimeout(async () => {
        if (!outcome) {
          process.kill("SIGINT");
          setTimeout(() => {
            if (!outcome) {
              process.kill("SIGKILL");
            }
          }, commandMetaData.timeout.waitBeforeUsingForce);
        }
      }, commandMetaData.timeout.gentlyBy);
    }
    let hasReturnString = false;
    let stdoutAndStderrDoneWritingPromise = { then(func2) {
      func2();
    } };
    const returnStringChunks = [];
    if (runArg.stdout == "piped" || runArg.stderr == "piped") {
      stdoutAndStderrDoneWritingPromise = deferredPromise();
      let stdoutIsDone = false;
      let stderrIsDone = false;
      const writableToWriter = /* @__PURE__ */ new Map();
      for (const eachWritable of stdoutWritables.concat(stderrWritables)) {
        if (!writableToWriter.has(eachWritable)) {
          if (eachWritable == returnAsString2) {
            hasReturnString = true;
            const decoder3 = new TextDecoder();
            writableToWriter.set(eachWritable, {
              write(value) {
                const stringValue = decoder3.decode(value);
                returnStringChunks.push(stringValue);
              }
            });
          } else {
            writableToWriter.set(eachWritable, eachWritable.getWriter());
          }
        }
      }
      const stdoutWriters = stdoutWritables.map((each2) => writableToWriter.get(each2));
      const stderrWriters = stderrWritables.map((each2) => writableToWriter.get(each2));
      if (runArg.stdout != "piped") {
        stdoutIsDone = true;
      } else {
        const reader = readableStreamFromReader(process.stdout).getReader();
        setTimeout(async () => {
          while (1) {
            const { value, done } = await reader.read();
            if (done) {
              stdoutIsDone = true;
              if (stderrIsDone) {
                stdoutAndStderrDoneWritingPromise.resolve();
              }
              break;
            }
            for (const each2 of stdoutWriters) {
              each2.write(value);
            }
          }
        });
      }
      if (runArg.stderr != "piped") {
        stderrIsDone = true;
      } else {
        const reader = readableStreamFromReader(process.stderr).getReader();
        setTimeout(async () => {
          while (1) {
            const { value, done } = await reader.read();
            if (done) {
              stderrIsDone = true;
              if (stdoutIsDone) {
                stdoutAndStderrDoneWritingPromise.resolve();
              }
              break;
            }
            for (const each2 of stderrWriters) {
              each2.write(value);
            }
          }
        });
      }
    }
    if (runArg.stdin == "piped") {
      if (stdinWriter instanceof Uint8Array) {
        process.stdin.write(stdinWriter).then(() => process.stdin.close());
      } else if (stdinWriter instanceof ReadableStream) {
        writableStreamFromWriter(process.stdin);
      }
    }
    let statusPromise2 = process.status();
    statusPromise2.then(({ code: code2, success }) => {
      syncStatus.done = true;
      syncStatus.exitCode = code2;
      syncStatus.success = success;
    });
    let processFinishedValue;
    if (hasReturnString) {
      processFinishedValue = statusPromise2.then(() => stdoutAndStderrDoneWritingPromise.then(() => returnStringChunks.join("")));
    } else {
      processFinishedValue = statusPromise2.then(({ success, code: code2 }) => {
        return {
          isDone: true,
          status: syncStatus,
          sendSignal: () => 0,
          success,
          exitCode: code2,
          pid: process.pid,
          rid: process.rid,
          kill: () => 0,
          close: process.close,
          stdin: runArg.stdin == "null" ? null : process.stdin || Deno.stdin,
          stdout: process.stdout || Deno.stdout,
          stderr: process.stderr || Deno.stderr
        };
      });
    }
    const returnValueOrError = new Promise(async (resolve15, reject) => {
      if (commandMetaData.throwIfFails) {
        const status = await statusPromise2;
        if (!status.success) {
          reject(await processFinishedValue);
          return;
        }
      }
      resolve15(processFinishedValue);
    });
    return [process, returnValueOrError, statusPromise2];
  };
  const asyncPartPromise = asyncPart();
  const processPromise = asyncPartPromise.then(([process, processFinishedValue, statusPromise2]) => process).catch((err) => err);
  const statusPromise = asyncPartPromise.then(([process, processFinishedValue, statusPromise2]) => statusPromise2).catch((err) => err);
  const returnValuePromise = asyncPartPromise.then(([process, processFinishedValue, statusPromise2]) => processFinishedValue);
  Object.defineProperties(returnValuePromise, {
    status: { get() {
      return syncStatus;
    } },
    isDone: { get() {
      return syncStatus.done;
    } },
    sendSignal: { get() {
      return (...args2) => processPromise.then((process) => process.kill(...args2)).catch((error) => error);
    } },
    kill: { get() {
      return (signal = "SIGKILL") => processPromise.then((process) => process.kill(signal));
    } },
    close: { get() {
      return (...args2) => processPromise.then((process) => process.close(...args2));
    } },
    success: { get() {
      return statusPromise.then(({ success }) => success);
    } },
    exitCode: { get() {
      return statusPromise.then(({ code: code2 }) => code2);
    } },
    outcome: { get() {
      return statusPromise;
    } },
    rid: { get() {
      return processPromise.then(({ rid }) => rid);
    } },
    pid: { get() {
      return processPromise.then(({ pid }) => pid);
    } },
    stdout: { get() {
      return processPromise.then(({ stdout }) => stdout || Deno.stdout);
    } },
    stderr: { get() {
      return processPromise.then(({ stderr }) => stderr || Deno.stderr);
    } },
    stdin: {
      get() {
        const realStdinPromise = processPromise.then(({ stdin }) => stdin || Deno.stdin);
        return {
          send(rawDataOrString) {
            if (typeof rawDataOrString == "string") {
              return { ...realStdinPromise.then((realStdin) => realStdin.write(new TextEncoder().encode(rawDataOrString))), ...this };
            } else {
              return { ...realStdinPromise.then((realStdin) => realStdin.write(rawDataOrString)), ...this };
            }
          },
          close(...args2) {
            return realStdinPromise.then((realStdin) => (realStdin.close(...args2), this));
          }
        };
      }
    }
  });
  return returnValuePromise;
};
run3.Timeout = Timeout2;
run3.Env = Env2;
run3.Cwd = Cwd2;
run3.Stdin = Stdin2;
run3.Stdout = Stdout2;
run3.Stderr = Stderr2;
run3.Out = Out2;
run3.Overwrite = Overwrite2;
run3.AppendTo = AppendTo2;
run3.zipInto = zipInto2;
run3.mergeInto = mergeInto2;
run3.returnAsString = returnAsString2;

// tools/misc.js
var versionToList = (version) => `${version}`.split(".").map((each2) => each2.split(/(?<=\d)(?=\D)|(?<=\D)(?=\d)/)).flat(1).map((each2) => each2.match(/^\d+$/) ? each2 - 0 : each2);
var versionSort = ({ array, elementToVersion }) => {
  return [...array].sort(
    (a, b) => {
      for (let [numberForA, numberForB] of zip2(versionToList(elementToVersion(a)), versionToList(elementToVersion(b)))) {
        if (numberForA != numberForB) {
          if (typeof numberForB == "number" && typeof numberForB == "number") {
            return numberForB - numberForA;
          } else if (typeof numberForB == "number") {
            return numberForB;
          } else if (typeof numberForA == "number") {
            return -numberForA;
          } else {
            return `${numberForB}`.localeCompare(numberForA);
          }
        }
      }
      return 0;
    }
  );
};

// tools/search_tools.js
var rikudoeSage = {
  async searchBasePackage(query) {
    try {
      return [];
    } catch (error) {
      throw Error(`Unable to connect to history.nix-packages.com:
    ${error}`);
    }
  },
  async getVersionsFor(attrPath) {
    const url = `https://api.history.nix-packages.com/packages/${encodeURIComponent(attrPath)}`;
    let results;
    try {
      results = await fetch(url).then((result2) => result2.json());
    } catch (error) {
      return [];
    }
    return results.map(({ name, revision, version }) => ({ version, hash: revision, attrPath: name }));
  }
};
var devbox = {
  async searchBasePackage(query) {
    try {
      const url = `https://www.nixhub.io/search?q=${encodeURIComponent(query)}`;
      const htmlResult = await fetch(url).then((result2) => result2.text());
      var document2 = new DOMParser().parseFromString(
        htmlResult,
        "text/html"
      );
      const list = document2.querySelector("ul");
      if (!list) {
        throw Error(`Looks like www.nixhub.io has updated, meaning this CLI tool needs to be updated (issue finding base names $("ul"))`);
      }
      const searchResults = [...list.querySelectorAll("li")];
      return searchResults.map((each2) => {
        const dataDiv = each2.querySelector("div");
        const output2 = {
          attrPath: each2.querySelector("h3").innerText
        };
        if (dataDiv) {
          let key;
          for (const each3 of [...dataDiv.children]) {
            if (each3.tagName == "DT") {
              key = each3.innerText.trim();
            }
            if (key && each3.tagName == "DD") {
              output2[key] = each3.innerText;
            }
          }
        }
        return output2;
      });
    } catch (error) {
      throw Error(`Unable to connect to nixhub.io, ${error}`);
    }
  },
  async getVersionsFor(attrPath) {
    const url = `https://www.nixhub.io/packages/${encodeURIComponent(attrPath)}`;
    let htmlResult;
    try {
      htmlResult = await fetch(url).then((result2) => result2.text());
    } catch (error) {
      return [];
    }
    const document2 = new DOMParser().parseFromString(
      htmlResult,
      "text/html"
    );
    const list = document2.querySelector("main ul");
    if (!list) {
      throw Error(`Looks like www.nixhub.io has updated, meaning this CLI tool needs to be updated (issue finding list $("main ul"))`);
    }
    const versionElements = [...list.querySelectorAll("li")];
    const versionResults = [];
    const prefixForVersionString = "Version ";
    for (const eachVersion of versionElements) {
      const divs = [...eachVersion.querySelectorAll("div")];
      const versionStringDiv = divs.filter((each2) => each2.innerText.startsWith(prefixForVersionString));
      if (!versionStringDiv) {
        throw Error(`Looks like www.nixhub.io has updated, meaning this CLI tool needs to be updated (issue finding version string div)`);
      }
      const version = versionStringDiv[0].innerText.slice(prefixForVersionString.length);
      const referenceInfoOuterDiv = divs.filter((each2) => [...each2.children].some((subChild) => subChild.innerText.match(/Nixpkgs Reference/)))[0];
      if (!referenceInfoOuterDiv) {
        throw Error(`Looks like www.nixhub.io has updated, meaning this CLI tool needs to be updated (issue finding version info within list element)`);
      }
      const referenceInfoInnerDiv = [...referenceInfoOuterDiv.querySelectorAll("div")].filter((each2) => each2.innerText.match("#"))[0];
      if (!referenceInfoInnerDiv) {
        throw Error(`Looks like www.nixhub.io has updated, meaning this CLI tool needs to be updated (issue extracting inner referece hash div)`);
      }
      const hashAndAttrName = referenceInfoInnerDiv.innerText.replace(/^\s*Nixpkgs Reference\s*/, "").split(/ *# */);
      if (!(hashAndAttrName.length == 2)) {
        throw Error(`Looks like www.nixhub.io has updated, meaning this CLI tool needs to be updated (issue extracting referece hash from referece hash div)`);
      }
      versionResults.push({
        version,
        hash: hashAndAttrName[0],
        attrPath: hashAndAttrName[1]
      });
    }
    return versionResults;
  }
};
var lazamar = {
  searchBasePackage(query) {
    return [];
  },
  async getVersionsFor(attrPath) {
    let query = attrPath.split(".").slice(-1)[0];
    const url = `https://lazamar.co.uk/nix-versions/?channel=nixpkgs-unstable&package=${encodeURIComponent(query)}`;
    let htmlResult;
    try {
      htmlResult = await fetch(url).then((result2) => result2.text());
    } catch (error) {
      return [];
    }
    const document2 = new DOMParser().parseFromString(
      htmlResult,
      "text/html"
    );
    const table = document2.querySelector(".pure-table-bordered.pure-table tbody");
    const dataPerAttributePath = {};
    for (let each2 of [...table.children]) {
      let [packageNameNode, versionNode, revisionNode, dateNode] = [...each2.children];
      const anchor = revisionNode.querySelector("a");
      const params = new URLSearchParams(anchor.getAttribute("href"));
      const attrPath2 = params.get("keyName");
      if (attrPath2) {
        dataPerAttributePath[attrPath2] = dataPerAttributePath[attrPath2] || { attrPath: attrPath2, versions: [] };
        dataPerAttributePath[attrPath2].versions.push({
          version: params.get("version"),
          hash: params.get("revision"),
          attrPath: attrPath2,
          date: dateNode.innerText
        });
      }
    }
    return dataPerAttributePath[attrPath]?.versions || [];
  }
};
var sources = {
  "lazamar.co.uk": lazamar,
  "history.nix-packages.com": rikudoeSage,
  "nixhub.io": devbox
};
async function search(query) {
  let basePackages = [];
  for (const [name, sourceTools] of Object.entries(sources)) {
    try {
      basePackages = basePackages.concat(await sourceTools.searchBasePackage(query));
    } catch (error) {
      console.warn(`Failed getting packages from one of the sources (${name}):
    ${error}
`);
    }
  }
  for (const value of basePackages) {
    value.versionsPromise = new Promise(async (resolve15, reject) => {
      let versions = [];
      for (const [name, sourceTools] of Object.entries(sources)) {
        try {
          versions = versions.concat(await sourceTools.getVersionsFor(value.attrPath));
        } catch (error) {
          console.warn(`Failed getting version info from one of the sources (${name}):
    ${error}
`);
          resolve15(null);
        }
      }
      const alreadySeen = /* @__PURE__ */ new Set();
      versions = versions.filter((each2) => {
        if (alreadySeen.has(each2.version)) {
          return false;
        }
        alreadySeen.add(each2.version);
        return true;
      });
      versions = versionSort({ array: versions, elementToVersion: (each2) => each2.version });
      resolve15(versions);
    });
  }
  return basePackages;
}
var determinateSystems = {
  async searchBasePackage(query) {
    const output2 = await fetch("https://b4lflfxxy4-dsn.algolia.net/1/indexes/*/queries?x-algolia-agent=Algolia%20for%20JavaScript%20(4.20.0)%3B%20Browser%3B%20instantsearch.js%20(4.58.0)%3B%20react%20(18.2.0)%3B%20react-instantsearch%20(7.2.0)%3B%20react-instantsearch-core%20(7.2.0)%3B%20JS%20Helper%20(3.14.2)", {
      "credentials": "omit",
      "headers": {
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/119.0",
        "Accept": "*/*",
        "Accept-Language": "en-CA,en-US;q=0.7,en;q=0.3",
        "x-algolia-api-key": "1673b56771c2f826310f4bdf25a43c42",
        "x-algolia-application-id": "B4LFLFXXY4",
        "content-type": "application/x-www-form-urlencoded",
        "Sec-Fetch-Dest": "empty",
        "Sec-Fetch-Mode": "cors",
        "Sec-Fetch-Site": "cross-site"
      },
      "referrer": "https://flakehub.com/",
      "body": `{"requests":[{"indexName":"flakes","params":"clickAnalytics=true&facets=%5B%5D&highlightPostTag=__%2Fais-highlight__&highlightPreTag=__ais-highlight__&hitsPerPage=100&query=${JSON.stringify(encodeURIComponent(query)).slice(1, -1)}l&tagFilters="}]}`,
      "method": "POST",
      "mode": "cors"
    }).then((result2) => result2.json());
    return output2.results[0]?.hits || [];
  },
  async getVersionsFor(flakePackage) {
    const { org, project, description, labels } = flakePackage;
    const url = `https://flakehub.com/f/${org}/${project}`;
    let versionInfo;
    try {
      versionInfo = await fetch(`${url}/releases`).then((result2) => result2.json());
    } catch (error) {
      return [];
    }
    const extractOutputs = async (version) => {
      try {
        const info = await run3`nix flake show --json --all-systems ${`https://api.flakehub.com/f/${org}/${project}/${version}.tar.gz`} ${Stdout2(returnAsString2)} ${Stderr2(null)}`;
        return [...new Set(Object.values(JSON.parse(info).packages).map((each2) => Object.keys(each2)).flat(1))];
      } catch (error) {
        return [];
      }
    };
    await Promise.all(
      versionInfo.map(
        (each2) => extractOutputs(each2.simplified_version).then(
          (result2) => {
            each2.packageOutputs = result2;
          }
        )
      )
    );
    return versionInfo;
  },
  async search(query) {
    const results = await this.searchBasePackage(query);
    for (const each2 of results) {
      each2.versionsPromise = this.getVersionsFor(each2);
    }
    return results;
  }
};

// main.js
var posixShellEscape = (string2) => "'" + string2.replace(/'/g, `'"'"'`) + "'";
var clearScreen2 = () => console.log("\x1B[2J");
var escapeNixString = (string2) => {
  return `"${string2.replace(/\$\{|[\\"]/g, "\\$&").replace(/\u0000/g, "\\0")}"`;
};
var listNixPackages = async () => {
  const packageList = await run2`nix profile list ${Stdout(returnAsString)}`;
  return parse12(
    clearAnsiStylesFrom(
      indent3({ string: packageList, by: "    " }).replace(/^    Index:/gm, "-\n    Index:")
    )
  );
};
var cachePath = `${FileSystem.home}/.cache/nvs/has_flakes_enabled.check`;
var hasFlakesEnabledString = FileSystem.sync.read(cachePath);
if (hasFlakesEnabledString == null) {
  console.log(`
Let me check real quick if you have flakes enabled`);
  console.log(`(this will only run once)`);
  try {
    const result2 = await run2`nix profile list ${Stdout(returnAsString)} ${Stderr(null)}`;
    hasFlakesEnabledString = !!result2.match(/^Flake attribute: /m);
  } catch (error) {
    hasFlakesEnabledString = false;
  }
  hasFlakesEnabledString = JSON.stringify(hasFlakesEnabledString);
  console.log(`
`);
  FileSystem.sync.write({
    data: hasFlakesEnabledString,
    path: cachePath
  });
}
var hasFlakesEnabled = JSON.parse(hasFlakesEnabledString);
var command = await new Command().name("Nix Version Search").version("1.0.0").description(`Find/install exact versions of nix packages

Examples:
    nvs --install python@3
    nvs python@3
    nvs --shell python@3`).globalOption("--install", "Install into the system").globalOption("--dry-install", "Show the nix command for installing into the system").globalOption("--shell", "Show the shell command info").globalOption("--force", "Uninstall any packages that conflict with an install").globalOption("--json", "Return json output of the results (force enables non-interactive)").globalOption("--explain", "Include beginner-friendly explanations with the output").arguments("[...args:string]").action(async function(options, ...args) {
  args = args.concat(this.getLiteralArgs());
  if (args.length == 0) {
    return command.parse(["--help"].concat(Deno.args));
  }
  if (args[0].startsWith("https://") && options.install) {
    if (hasFlakesEnabled) {
      var { success } = await run2`nix profile install ${args[0]}`;
      Deno.exit(success);
    } else {
      var { success } = await run2`nix-env -i -f ${args[0]}`;
      await run2`nix profile install ${args[0]}`;
      Deno.exit(success);
    }
  }
  var [name, versionPrefix] = args[0].split("@");
  versionPrefix = versionPrefix || "";
  const results = await search(name);
  let flakeResults = [];
  if (hasFlakesEnabled) {
    flakeResults = await determinateSystems.search(name);
  }
  const choiceOptions = {};
  for (const each2 of flakeResults) {
    choiceOptions[each2.project + ` \u2744\uFE0F ${each2.org}`] = each2;
  }
  for (const each2 of results) {
    let oldVersionsPromise = choiceOptions[each2.attrPath]?.versionsPromise;
    choiceOptions[each2.attrPath] = { ...choiceOptions[each2.attrPath], ...each2 };
    if (oldVersionsPromise) {
      choiceOptions[each2.attrPath].versionsPromise = new Promise(async (resolve15, reject) => {
        try {
          resolve15(
            (await oldVersionsPromise || []).concat(await each2.versionsPromise)
          );
        } catch (error) {
          reject(error);
        }
      });
    }
  }
  for (const [key, value] of Object.entries(choiceOptions)) {
    value.versionsPromise.then((versions) => {
      if (versions.filter((each2) => each2.version.startsWith(versionPrefix)).length == 0) {
        delete choiceOptions[key];
      }
    });
  }
  if (options.json) {
    await Promise.all(
      Object.values(choiceOptions).map(
        (eachPackage) => eachPackage.versionsPromise.then((versions) => {
          eachPackage.versions = (eachPackage.versions || []).concat(
            versions.filter((each2) => each2.version.startsWith(versionPrefix))
          );
          delete eachPackage.versionsPromise;
          return eachPackage;
        })
      )
    );
    console.log(JSON.stringify(choiceOptions));
    return;
  }
  while (1) {
    const optionDescriptions = Object.values(choiceOptions).map((each2) => (each2.Description || each2.description || "").replace(/\n/g, " "));
    const packageInfo = await selectOne({
      message: "Which Package [type OR press enter OR use arrow keys]",
      showList: true,
      showInfo: false,
      options: choiceOptions,
      optionDescriptions
    });
    if (!packageInfo) {
      console.log(red2`Sorry, I checked just now`);
      console.log(red2`it looks like that package doesn't have any versions matching ${JSON.stringify(versionPrefix)}\n`);
      continue;
    }
    const versionOptions = (await packageInfo?.versionsPromise || []).filter((each2) => each2.version.startsWith(versionPrefix));
    if (versionOptions.length == 0) {
      console.log(red2`Sorry, I checked just now`);
      console.log(red2`it looks like ${cyan2(packageInfo.attrPath)} doesn't have any versions matching ${JSON.stringify(versionPrefix)}\n`);
      delete choiceOptions[packageInfo.attrPath];
      continue;
    }
    const version = await selectOne({
      message: "Pick a version",
      showList: true,
      showInfo: false,
      autocompleteOnSubmit: false,
      options: versionOptions.map((each2) => each2.version)
    });
    const viableVersions = versionOptions.filter((each2) => each2.version.startsWith(version));
    if (viableVersions.length == 0) {
      throw Error(`Sorry I don't see that version`);
    }
    const pureVersions = viableVersions.filter((each2) => each2.version.match(/^[\.0-9]+$/));
    let versionInfo;
    if (pureVersions.length != 0) {
      versionInfo = versionSort({ array: pureVersions, elementToVersion: (each2) => each2.version })[0];
    } else {
      versionInfo = versionSort({ array: viableVersions, elementToVersion: (each2) => each2.version })[0];
    }
    let didSomething = false;
    let humanPackageSummary;
    let url;
    let packageName;
    if (hasFlakesEnabled) {
      if (packageInfo.project) {
        packageName = packageInfo.project;
        humanPackageSummary = `${green2(packageInfo.project)}${cyan2`@${versionInfo.version}`}${dim2` from `}${yellow2(packageInfo.org)}`;
        url = `https://flakehub.com/f/${packageInfo.org}/${packageInfo.project}/${versionInfo.simplified_version}.tar.gz`;
      } else {
        packageName = packageInfo.attrPath;
        humanPackageSummary = `${green2(packageInfo.attrPath)}${cyan2`@${versionInfo.version}`}${dim2` from `}${yellow2("nixpkgs")}`;
        url = `https://github.com/NixOS/nixpkgs/archive/${versionInfo.hash}.tar.gz#${versionInfo.attrPath}`;
      }
    }
    if (options.install) {
      didSomething = true;
      if (hasFlakesEnabled) {
        console.log(`Okay installing ${humanPackageSummary}`);
        let noProgressLoopDetection;
        install:
          while (1) {
            var stderrOutput = "";
            var listener = {
              async write(chunk) {
                stderrOutput += new TextDecoder().decode(chunk);
              }
            };
            await run2`nix profile install ${url} ${Stderr(Deno.stderr, listener)}`;
            if (noProgressLoopDetection == stderrOutput) {
              console.error(`
Sorry, it looks like I was unable to install the package`);
              Deno.exit(7);
            }
            noProgressLoopDetection = stderrOutput;
            const conflictMatch = stderrOutput.match(/error: An existing package already provides the following file:(?:\w|\W)+?(?<existing>\/nix\/store\/.+)(?:\w|\W)+?This is the conflicting file from the new package:(?:\w|\W)+?(?<newPackage>\/nix\/store\/.+)(?:\w|\W)+?To remove the existing package:(?:\w|\W)+?(?<removeExisting>nix profile remove.+)(?:\w|\W)+?To prioritise the new package:(?:\w|\W)+?(?<prioritiseNew>nix profile install.+)(?:\w|\W)+?To prioritise the existing package:(?:\w|\W)+?(?<prioritiseExisting>nix profile install.+)/);
            if (conflictMatch) {
              const { existing, newPackage, removeExisting, prioritiseNew, prioritiseExisting } = conflictMatch.groups;
              const [folders, name2, ext] = FileSystem.pathPieces(existing);
              const simpleName = cyan2(folders.slice(4).join("/")) + cyan2("/") + green2(name2 + ext);
              clearScreen2();
              const packages = await listNixPackages();
              const removeExistingPackage = async () => {
                try {
                  if (removeExisting) {
                    const url2 = (removeExisting.slice("nix profile remove ".length).match(/(.+?)#/) || "")[1];
                    const uninstallList = packages.filter((each2) => each2["Original flake URL"] == url2 || each2["Store paths"] == existing);
                    for (const each2 of uninstallList) {
                      if (each2.Index != null) {
                        try {
                          await run2`nix profile remove ${`${each2.Index}`.trim()}`;
                        } catch (error) {
                        }
                      }
                    }
                  }
                } catch (error) {
                }
              };
              if (options.force) {
                await removeExistingPackage();
                continue install;
              } else {
                console.log(bold2`Looks like there was a conflict:`);
                console.log(`    The install adds: ${simpleName}`);
                console.log(`    Which already exists from:
        ${yellow2((removeExisting || "").trim().slice("nix profile remove ".length) || existing)}`);
                console.log(``);
                const uninstallOption = "uninstall: remove the old package, install the one you just picked";
                const newHigherPriorityOption = "higher: install the one you just picked with a higher priority";
                const installAsLowerOption = "lower: install one you just picked, but have it be lower priority";
                const choice = await selectOne({
                  message: "Choose an action:",
                  showList: true,
                  showInfo: false,
                  options: [
                    uninstallOption,
                    ...prioritiseNew ? [newHigherPriorityOption] : [],
                    installAsLowerOption,
                    "cancel"
                  ]
                });
                if (choice == "cancel") {
                  Deno.exit(0);
                  return;
                } else if (choice == newHigherPriorityOption) {
                  await run2(prioritiseNew.trim().split(/\s/g));
                } else if (choice == installAsLowerOption) {
                  await run2(prioritiseExisting.trim().split(/\s/g));
                } else if (choice == uninstallOption) {
                  await removeExistingPackage();
                }
                continue install;
              }
            } else {
              console.log(`
 - \u2705 ${humanPackageSummary} should now be installed`);
            }
            break;
          }
      } else {
        await run2`nix-env -iA ${versionInfo.attrPath} -f {https://github.com/NixOS/nixpkgs/archive/${versionInfo.hash}.tar.gz}`;
        console.log(`
 - \u2705 ${versionInfo.attrPath}@${versionInfo.version} should now be installed`);
      }
    }
    if (options.dryInstall) {
      didSomething = true;
      if (hasFlakesEnabled) {
        console.log(`Okay run the following to get ${humanPackageSummary}`);
        console.log(``);
        console.log(cyan2`nix profile install ${posixShellEscape(url)}`);
        console.log(``);
      } else {
        console.log(`Okay run the following to get version ${yellow2(versionInfo.version)} of ${yellow2(packageInfo.attrPath)}`);
        console.log(``);
        console.log(cyan2`nix-env -iA ${posixShellEscape(versionInfo.attrPath)} -f https://github.com/NixOS/nixpkgs/archive/${versionInfo.hash}.tar.gz`);
        console.log(``);
      }
    }
    if (options.shell) {
      didSomething = true;
      if (hasFlakesEnabled) {
        console.log(`Okay, run the following to a shell that has ${humanPackageSummary}`);
        console.log(``);
        console.log(cyan2`nix develop ${posixShellEscape(url)}`);
        console.log(``);
      } else {
        console.log(`Okay, run the following to a shell that has version ${yellow2(versionInfo.version)} of ${yellow2(packageInfo.attrPath)}`);
        console.log(``);
        console.log(cyan2`nix-shell -p ${posixShellEscape(versionInfo.attrPath)} -I https://github.com/NixOS/nixpkgs/archive/${versionInfo.hash}.tar.gz`);
        console.log(``);
      }
    }
    if (!didSomething) {
      if (hasFlakesEnabled) {
        const name2 = toCamelCase(packageName);
        const nonDefaultPackages = (versionInfo?.packageOutputs || []).filter((each2) => each2 != "default");
        if (!options.explain) {
          console.log(`Okay use the following to get ${humanPackageSummary}`);
          console.log(``);
          console.log(cyan2`    ${name2}.url = ${escapeNixString(url)}`);
          if (nonDefaultPackages.length > 0) {
            console.log(``);
            console.log(dim2`Note: you may need to use one of the following to get what you want:`);
            console.log(nonDefaultPackages.map((each2) => dim2.lightRed`    ${name2}.${each2}`).join("\n"));
          }
          console.log(``);
          console.log(dim2`Run again with ${yellow2`--explain`} if you're not sure how to use this^`);
        } else {
          console.log(`If you have a ${yellow2`flake.nix`} file it might look like:
`);
          console.log(dim2`   {`);
          console.log(dim2`     description = "something";`);
          console.log(dim2`     inputs = {`);
          console.log(dim2`       nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";`);
          console.log(dim2`     };`);
          console.log(dim2`     outputs = { self, nixpkgs, }:`);
          console.log(dim2`       let`);
          console.log(dim2`          somethingSomething = 10;`);
          console.log(dim2`       in`);
          console.log(dim2`         {`);
          console.log(dim2`         }`);
          console.log(dim2`   }`);
          console.log(dim2``);
          prompt(cyan2`[press enter to continue]`);
          console.log(``);
          console.log(`To make it work with ${humanPackageSummary}`);
          console.log(`You would change it to be:
`);
          console.log(dim2`   {`);
          console.log(dim2`     description = "something";`);
          console.log(dim2`     inputs = {`);
          console.log(dim2`       nixpkgs.url = "github:NixOS/nixpkgs/nixpkgs-unstable";`);
          console.log(green2`       ${name2}.url = ${escapeNixString(url)};`);
          console.log(dim2`     };`);
          console.log(`     outputs = { self, nixpkgs, ${green2(name2)} }:`);
          console.log(dim2`       let`);
          console.log(dim2`          somethingSomething = 10;`);
          if (nonDefaultPackages.length > 0) {
            console.log(dim2.cyan`          # Note: you may need to use one of the following to get what you want:`);
            console.log(nonDefaultPackages.map((each2) => dim2.cyan`          #    ${name2}.${each2}`).join("\n"));
          }
          console.log(dim2`       in`);
          console.log(dim2`         {`);
          console.log(dim2`         }`);
          console.log(dim2`   }`);
          console.log(``);
        }
      } else {
        if (!options.explain) {
          console.log(`Here's what to include in your nix code:`);
          console.log(``);
          console.log(cyan2`    yourVarName = (`);
          console.log(cyan2`      (import (builtins.fetchTarball {`);
          console.log(cyan2`          url = "https://github.com/NixOS/nixpkgs/archive/${versionInfo.hash}.tar.gz";`);
          console.log(cyan2`      }) {}).${versionInfo.attrPath}`);
          console.log(cyan2`    );`);
          console.log(``);
          console.log(dim2`Run again with ${yellow2`--explain`} if you're not sure how to use this^`);
        } else {
          console.log(`If you have a ${yellow2`shell.nix`} or ${yellow2`default.nix`} file it might look like:
`);
          console.log(dim2`     { pkgs ? import <nixpkgs> {} }:`);
          console.log(dim2`     let`);
          console.log(dim2`       python = pkgs.python;`);
          console.log(dim2`     in`);
          console.log(dim2`       pkgs.mkShell {`);
          console.log(dim2`         buildInputs = [`);
          console.log(dim2`           python`);
          console.log(dim2`         ];`);
          console.log(dim2`         nativeBuildInputs = [`);
          console.log(dim2`         ];`);
          console.log(dim2`         shellHook = ''`);
          console.log(dim2`             # blah blah blah`);
          console.log(dim2`         '';`);
          console.log(dim2`       }`);
          console.log(dim2``);
          prompt(cyan2`[press enter to continue]`);
          console.log(``);
          console.log(`To make it work with version ${yellow2(versionInfo.version)} of ${yellow2(packageInfo.attrPath)}`);
          console.log(`You would change it to be:
`);
          console.log(dim2`     { pkgs ? import <nixpkgs> {} }:`);
          console.log(dim2`     let`);
          console.log(dim2`       python = pkgs.python;`);
          console.log(green2`       YOUR_THING = (`);
          console.log(green2`         (import (builtins.fetchTarball {`);
          console.log(green2`            url = "https://github.com/NixOS/nixpkgs/archive/${versionInfo.hash}.tar.gz";`);
          console.log(green2`         }) {}).${versionInfo.attrPath}`);
          console.log(green2`       );`);
          console.log(dim2`     in`);
          console.log(dim2`       pkgs.mkShell {`);
          console.log(dim2`         buildInputs = [`);
          console.log(dim2`           python`);
          console.log(green2`           YOUR_THING`);
          console.log(dim2`         ];`);
          console.log(dim2`         nativeBuildInputs = [`);
          console.log(dim2`         ];`);
          console.log(dim2`         shellHook = ''`);
          console.log(dim2`             # blah blah blah`);
          console.log(dim2`         '';`);
          console.log(dim2`       }`);
        }
      }
    }
    break;
  }
});
await command.parse(Deno.args);
/*!
 * Sizzle CSS Selector Engine v2.3.7-pre
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2022-04-02
 *
 * git commit hash for Deno DOM: ede0e97563c8473b8cfa4045c7c2cd6129ecc1aa
 */
